[{"title":"Java面试题汇总","url":"/post/interview/interview-java/","content":"<!-- more -->\n\n前言：本文 Android 均是基于 Java 开发，开发工具为 AndroidStudio。因为部分知识体系有交集，所以会出现重复内容，如果是链接形式，则具体以链接实际内容为准。\n\n***\n\n# 多线程\n\n## - ThreadPool线程池\n\n***\n\n# Java集合框架\n\n## - HashMap\n\n***\n\n# JVM\n\n## - JVM的五个区\n\n答：[JVM内存模型](/post/java/java-jvm/ \"TOLINKS\")\n\n<br/>\n\n## - 方法区是否会OOM\n\n答：会。在 JDK 1.8 以前，HotSpot 虚拟机的方法区是用永久代实现的，方法区的内存固定，因此如果频繁调用 ``String.intern()`` 方法，或者一次性加载太多类，会导致OOM。JDK 1.8 之后，虽然用元数据取代了方法区，直接使用本地内存，支持扩容，也取消了永久代，但并不是无限扩容的，所以仍然会，只是几率会小一些。\n\n<br/>\n\n## - GC垃圾回收机制\n\n***\n\n# 同步锁\n\n***\n\n# Java反射\n\n***\n\n# 其他\n\n## - finally什么时候执行\n\n当 ``try - catch`` 中使用 ``break`` 或 ``return`` 返回时，``finally`` 会执行，当调用了 ``System.exit(0)`` 退出时，由于直接终止了 JVM，因此 ``finally`` 不会执行。\n\n<br/>\n\n## - 为什么方法参数要加final才能在子线程内使用\n\n","tags":["Interview","面试题","Java"],"categories":["Interview"]},{"title":"Android面试题汇总","url":"/post/interview/interview-android/","content":"<!-- more -->\n\n前言：本文 Android 均是基于 Java 开发，开发工具为 AndroidStudio。因为部分知识体系有交集，所以会出现重复内容，如果是链接形式，则具体以链接实际内容为准。\n\n***\n\n# 四大组件\n\n  - [Activity](/post/android/android-activity/ \"TOLINKS\")\n  - [Service](/post/android/android-service/ \"TOLINKS\")\n  - [BroadcastReceiver](/post/android/android-broadcastreceiver/ \"TOLINKS\")\n  - [ContentProvider](/post/android/android-contentprovider/ \"TOLINKS\")\n\n***\n\n# 五大存储\n\n  - [SharedPreferences](/post/android/android-sharedpreference/ \"TOLINKS\")：\n  - [SQLite](\"TOLINKS\")：\n  - [文件存储](\"TOLINKS\")：\n  - [网络存储](\"TOLINKS\")：\n  - [ContentProvider](/post/android/android-contentprovider/ \"TOLINKS\")：\n\n***\n\n# 六大布局\n\n  - LinearLayout\n  - RelativeLayout\n  - FrameLayout\n  - GridLayout\n  - TableLayout\n  - AbsoluteLayout\n\n***\n\n# 其他组件\n\n## - Fragment生命周期及回调\n\n***\n\n# Android消息处理机制\n\n  - [ThreadLocal](/post/java/java-threadlocal/ \"TOOINKS\")\n  - [Message](/post/android/android-message/ \"TOOINKS\")\n  - [MessageQueue](/post/android/android-messagequeue/ \"TOLINKS\")\n  - [Looper](/post/android/android-looper/ \"TOLINKS\")\n  - [Handler](/post/android/android-handler/ \"TOLINKS\")\n\n***\n\n# 进程间通信\n\n  - [AIDL](\"TOLINKS\")\n  - [Socket](\"TOLINKS\")\n  - [ContentProvider](\"TOLINKS\")\n  - [BroadcastReceiver](\"TOLINKS\")\n  - Messenger\n  - 文件共享：多进程读写同一文件是难以控制、不安全的。\n  - ~~SharedPrefernces：公共读（``MODE_WORLD_READABLE``）模式、公共写（``MODE_WORLD_WRITEABLE``）模式、跨进程（``MODE_MULTI_PROCESS``）模式均已弃用，多进程读写同一文件是难以控制、不安全的，Google 推荐使用基于 ContentProvider 的 FileProvider 来实现。~~\n\n***\n\n# Android中的缓存\n\n## - 内存缓存\n\n<br/>\n\n## - 本地缓存\n\n***\n\n# 图片加载框架\n\n  - [Glide](\"TOOINKS\")\n\n***\n\n# 网络框架\n\n  - [OKHttp](\"TOOINKS\")\n  - [基于OKHttp二次封装](\"TOOINKS\")\n\n***\n\n# 断点下载\n\n***\n\n# 性能和优化\n\n## - 如何检测性能以及如何优化\n\n<br/>\n\n## - 内存抖动的检测和优化\n\n<br/>\n\n## - ANR和OOM的定位和优化\n\n<br/>\n\n## - 分析堆栈输出\n\n***\n\n# 打包和发布\n\n## - 代码混淆\n\n<br/>\n\n## - App加固\n\n<br/>\n\n## - 热更新和热修复\n\n<br/>\n\n## - VersionCode和VersionName的区别\n\n***\n\n# 源码分析\n\n  - [Message](/post/android/android-message/ \"TOOINKS\")\n  - [MessageQueue](/post/android/android-messagequeue/ \"TOLINKS\")\n  - [Looper](/post/android/android-looper/ \"TOLINKS\")\n  - [Handler](/post/android/android-handler/ \"TOLINKS\")\n  - [Glide](\"TOLINKS\")\n\n***\n\n# 其他细节\n\n## - getWidth和getMeasureWidth的区别\n\n``getMeasureWidth`` 是 View 自己测量自己的宽度，``getWidth`` 是 View 的父布局测量的高度，当屏幕可显示范围小于 View 本身的宽高时，``getMeasureWidth`` 得到的仍然是 View 本身的宽高，而 ``getWidth`` 得到的是屏幕实际显示的宽高\n\n<br/>\n\n## - SparseArray的改进\n\n***\n\n# 同步锁\n\n***\n\n# Java反射\n\n***\n\n# 其他细节\n\n## - finally什么时候执行\n\n当 ``try - catch`` 中使用 ``break`` 或 ``return`` 返回时，``finally`` 会执行，当调用了 ``System.exit(0)`` 退出时，由于直接终止了 JVM，因此 ``finally`` 不会执行。\n\n## - 为什么方法参数要加final才能在子线程内使用\n\n***\n\n# App架构\n\nApp 架构的核心思想，主要就是为了降低 UI 逻辑和数据业务逻辑之间的耦合度。\n\n<br/>\n\n## - MVC模式\n\nMVC 即：Model - View - Controller 模式，Model 与 View、View 与 Controller、Controller 与 Model，都是单向直接通信，View 层负责 UI 逻辑，Model 层负责数据，Controller 负责替 View 层操作 Model 层，但由于 Android 中，Activity 通常会同时担任 View 层和 Controller 层，随着业务变得复杂，Activity 也会越来越臃肿，而且 Activity 与 Model 层交互时，相当于 View 层可以与 Model 层直接交互，没有完全解耦。\n\n<br/>\n\n## - MVP模式\n\nMVP 即：Model - View - Presenter 模式，Presenter 与 View、Presenter 与 Model 之间都是双向通信，而 Model 与 View 之间完全没有直接通信，从而彻底解耦。并且由于将 MVC 模式中的 Controller 完全解放成独立的 Presenter，也避免了 Activity 中逻辑代码过多的情况。\n\n  - MVP 模式的变种：Passive View\n\n  Passive View 即：被动 View 层，是 MVP 模式最广泛的一个变种，其核心思想就是：View 层所需的数据，不是由其主动拉取 Presenter 获得的，而是被动地由 Presenter 推送的，在 Android 中，也就是 View 层开放自己被动接受数据的接口，Presenter 在转发 View 层请求数据的逻辑给 Model 后，由 Model 通过 Presenter 来主动调用 View 的接口来回传数据。\n\n<br/>\n\n## - MVVM模式\n\nMVVM 即：Model - View - ViewModel 模式，View 仍然对应了 UI 层，Model 仍然是负责主要的数据处理，但一些和 View 层有关的属性及操作则放入了 ViewModel 中实现，其关键在于 DataBinding 技术，View 的变化和 ViewModel 的操作会双向同步，实际上是 Jetpack 框架替开发人员做了一些工作。\n\n  - DataBinding 原理\n  \n  DataBinding 会对布局文件中使用 ``<layout>`` 标签包裹的元素预处理，会为每个元素增加一个 ``tag`` 属性，然后将各个元素抽取出来生成一个名为 ``xxxxx-layout.xml`` 的文件（``xxxxx`` 是原本 xml 布局文件的命名），文件中将原本的所有 View 标签，都转换成了 ``<Target id=\"xxx\" tag=\"yyy\" view=\"ZzzView\">`` 的形式，其中根布局对应的 tag 是 ``layout``，然后根据原布局文件和新生成的文件，生成一个继承自 ``ViewDataBinding`` 的类，并将布局文件中的元素，都根据类型和 id 创建成员变量。\n\n***\n\n# 设计模式\n\n## - 单例模式\n\n## - 工厂模式\n\n## - DCL双锁检测\n\n## - 观察者模式\n\n## - 中介者模式\n\n## - EventBus\n\n***","tags":["Android","Interview","面试题"],"categories":["Interview"]},{"title":"Network面试题汇总","url":"/post/interview/interview-network/","content":"<!-- more -->\n\n前言：本文 Android 均是基于 Java 开发，开发工具为 AndroidStudio。因为部分知识体系有交集，所以会出现重复内容，如果是链接形式，则具体以链接实际内容为准。\n\n***\n\n# 网络协议\n\n## - TCP\n\n## - UDP\n\n## - HTTP\n\n## - SSL\n\n## - HTTPS","tags":["Interview","面试题","Network"],"categories":["Interview"]},{"title":"Android反编译和混淆加固","url":"/post/android/android-decompile-proguard/","content":"<!-- more -->\n\n***\n\n","tags":["Android","反编译","混淆","加固"],"categories":["Android"]},{"title":"Mac编译FFmpeg踩坑记录","url":"/post/note/note-build-ffmpeg/","content":"<!-- more -->\n\n前言：实际上网上关于如何编译 FFmpeg 的文章已经相当多了，但是等到自己真的要用的时候才发现，能找到的大部分文章多少都有些不够完善，或是有遗漏的说明，或是版本、环境太久远，为此踩了不少的坑，最后发现还是读官方文档最省事。特地记录一篇文章，并尽可能详细地写出具体步骤。\n\n***\n\n# 1. 环境和所需的文件\n\n先是环境：\n\n  - FFmpeg：3.3.9\n  - NDK：android-ndk-r14b\n  - 系统：MacOS 10.15\n  - 编译目标：给 Android 用的 ARM 平台\n\n再给出几个下载链接：\n\n  - FFmpeg：[点此下载](https://ffmpeg.org/download.html#releases \"TOLINKS\")\n  - NDK：[点此下载](https://developer.android.google.cn/ndk/downloads/index.html \"TOLINKS\")\n\n<font color=red>※ 注 | 不建议使用 AndroidStudio 自带的 ndk-bundle 编译，不建议使用最新版 FFmpeg，不建议使用最新版 NDK，理由不明（笑）。</font>\n\n使用最新的 FFmpeg 4.x，按照网上主流的做法，修改 ``configure`` 文件然后新建脚本 ``build_android.sh`` 的方法，会报如下错误：\n\n```shell\nMakefile:2: config.mak: No such file or directory\nMakefile:67: /common.mak: No such file or directory\nMakefile:114: /libavutil/Makefile: No such file or directory\n\n......\n\nC compiler test failed.\n\nIf you think configure made a mistake, make sure you are using the latest\nversion from Git.  If the latest version fails, report the problem to the\nffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net.\nInclude the log file \"config.log\" produced by configure as this will help\nsolve the problem.\nsed: config.h: No such file or directory\nsed: config.h: No such file or directory\n\n......\n\nMakefile:2: config.mak: No such file or directory\n\n......\n\nmake: *** No rule to make target `/tests/Makefile'.  Stop.\n```\n\n报了一堆 ``No such file or directory`` 错误，第一行的 ``config.mak`` 也可能是 ``ffbuild/config.mak``，带着错误去搜也搜不到什么头绪，根据报错信息去 FFmpeg 的根目录下或者 ``ffbuild/`` 下也确实找不到所谓的 ``config.mak``，一个解决方案是：\n\n  - 1. 先不要修改 ``configure`` 文件，直接执行：``./configure``，但是大概率会报这个错误：\n\n  ```shell\n  nasm/yasm not found or too old. Use --disable-x86asm for a crippled build.\n  ```\n\n  只要按照提示加上 ``--disable-x86asm`` 参数即可，重新执行完会自动生成缺失的文件。\n\n  - 2. 再重新执行脚本：``sudo ./build_android.sh``。\n\n但是这么做，如果是最新的 NDK 或者最新的 FFmpeg，执行完倒是不报错，但是并不会编译输出 SO 文件，所以还是老老实实用已有方案的版本吧！\n\n***\n\n# 2. 编译SO文件\n\n<br/>\n\n## 2.1 配置NDK\n\n首先，NDK 下载好后，放到自定义目录中，需要添加到环境变量中去：\n\n```shell\n# 如果用的是 bash 终端：\nvim ~/.bash_profile\n\n# 如果用的是 zsh 终端：\nvim ~/.zshrc\n\n# 添加环境变量（按照实际目录）：\nexport NDK_HOME=/Applications/AndroidStudio/android-ndk-r14b/build\n......\nexport PATH=${NDK_HOME}:${PATH}:\n```\n\n保存退出，然后刷新并测试环境变量，执行：``ndk-build``，如果有类似以下输出则表明配置成功：\n\n```shell\nAndroid NDK: Could not find application project directory !\n......\n```\n\n还需要给所有文件加上权限，进入 NDK 的目录并执行：\n\n```shell\nchmod -R 777 ./*\n```\n\n<font color=red>温馨提示：可千万不要把 ``./*`` 给打错了，要是不小心把“.”漏了可就麻烦了（请务必不要尝试）。</font>\n\n<br/>\n\n## 2.2 配置FFmpeg\n\n把下载好的 FFmpeg 源码解压到任意目录，同样也按上述操作给所有文件加上权限，接下来再在 FFmpeg 根目录下创建一个脚本（命名随意）：``build_android.sh``，修改内容：\n\n```shell\n#!/bin/bash\n\n# 以实际自定义临时目录为准，必须指定否则报错：Unable to create temporary file in\nexport TMPDIR=/....../TEMP\n# 以 NDK 实际路径为准\nNDK=/Applications/Androidstudio/android-ndk-r14b\n# 编译目标平台，本例选择最低 API 22 的 ARM 平台，输出 SO 文件放在 Android 项目的 libs/armeabi/ 目录下\n# x86 架构则选择 arch-x86\nPLATFORM=$NDK/platforms/android-22/arch-arm\n# 编译所需工具链，arm-linux-androideabi 对应上面的 ARM 平台，4.9 为版本号，以 NDK 中的实际版本为准\nTOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64\nfunction build_one\n{\n./configure \\\n    --prefix=$PREFIX \\\n    --target-os=linux \\\n    --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \\\n    --arch=arm \\\n    --sysroot=$PLATFORM \\\n    --extra-cflags=\"-I$PLATFORM/usr/include\" \\\n    --cc=$TOOLCHAIN/bin/arm-linux-androideabi-gcc \\\n    --nm=$TOOLCHAIN/bin/arm-linux-androideabi-nm \\\n    --disable-shared \\\n    --enable-runtime-cpudetect \\\n    --enable-gpl \\\n    --enable-small \\\n    --enable-cross-compile \\\n    --disable-debug \\\n    --enable-static \\\n    --disable-doc \\\n    --disable-asm \\\n    --disable-ffmpeg \\\n    --disable-ffplay \\\n    --disable-ffprobe \\\n    --disable-ffserver \\\n    --disable-postproc \\\n    --disable-avdevice \\\n    --disable-symver \\\n    --disable-stripping \\\n$ADDITIONAL_CONFIGURE_FLAG\nsed -i '' 's/HAVE_LRINT 0/HAVE_LRINT 1/g' config.h\nsed -i '' 's/HAVE_LRINTF 0/HAVE_LRINTF 1/g' config.h\nsed -i '' 's/HAVE_ROUND 0/HAVE_ROUND 1/g' config.h\nsed -i '' 's/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g' config.h\nsed -i '' 's/HAVE_TRUNC 0/HAVE_TRUNC 1/g' config.h\nsed -i '' 's/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g' config.h\nsed -i '' 's/HAVE_CBRT 0/HAVE_CBRT 1/g' config.h\nsed -i '' 's/HAVE_RINT 0/HAVE_RINT 1/g' config.h\nmake clean\nmake -j4\nmake install\n$TOOLCHAIN/bin/arm-linux-androideabi-ld \\\n-rpath-link=$PLATFORM/usr/lib \\\n-L$PLATFORM/usr/lib \\\n-L$PREFIX/lib \\\n-soname libffmpeg.so -shared -nostdlib -Bsymbolic --whole-archive --no-undefined -o \\\n$PREFIX/libffmpeg.so \\\n    libavcodec/libavcodec.a \\\n    libavfilter/libavfilter.a \\\n    libswresample/libswresample.a \\\n    libavformat/libavformat.a \\\n    libavutil/libavutil.a \\\n    libswscale/libswscale.a \\\n    -lc -lm -lz -ldl -llog --dynamic-linker=/system/bin/linker \\\n    $TOOLCHAIN/lib/gcc/arm-linux-androideabi/4.9.x/libgcc.a\n}\n# 平台类型，可以是 arm 或 armv7-a 或 x86 等\nCPU=armv7-a\nOPTIMIZE_CFLAGS=\"-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU \"\n# 输出 SO 的目录\nPREFIX=./android/$CPU\nADDITIONAL_CONFIGURE_FLAG=\nbuild_one\n```\n\n接下来在当前目录执行：\n\n```shell\n# 按实际创建的脚本名\n./build_android.sh\n```\n\n需要等一段编译时间，但总之是成功编译了，脚本配置中的“编译后 SO 文件输出目录” ``PREFIX=./android/$CPU-vfp`` 表示：``当前目录/android/平台类型``，比如我当前目录为 ``/Applications/FFmpeg``，平台类型是 ``arm``，则输出目录为：``/Applications/FFmpeg/android/arm/``。\n\n编译完可能会报如下错误：\n\n```shell\ninstall: /usr/local/share/man/man1/ffmpeg.1: Permission denied\nmake: *** [install-man] Error 71\n```\n\n权限错误，也可能是 ``man3`` 报的错，简便一点的方法就是直接用 Super User 权限安装：\n\n```shell\nsudo ./build_android.sh\n```\n\n安装完成后，在 FFmpeg 根目录下的 ``android/armv7-a/`` 下即可看到 ``libffmpeg.so`` 文件，复制到 Android 项目中再配置 NDK 即可。\n\n***\n\n# 3. 附录[参考指导]\n\n> - [【1】Android Studio下编译FFmpeg so文件（作者：Galaxy北爱）<sup>【注】</sup>](https://www.jianshu.com/p/dfe9404e001a \"TOLINKS\")\n> - [【1】win10子系统编译ffmpeg for android遇到的问题记录（作者：wellchang）<sup>【注】</sup>](https://blog.csdn.net/vichild/article/details/82686343 \"TOLINKS\")\n> - [【1】Android编译ffmpeg常见错误（作者：JXiaoNiu）<sup>【注】</sup>](https://www.jianshu.com/p/c8ad83dd5585 \"TOLINKS\")\n> - [【1】Mac中编译FFmpeg教程(Android版)（作者：码出世界）<sup>【注】</sup>](https://segmentfault.com/a/1190000015631928 \"TOLINKS\")\n","tags":["FFMPEG","SO库","编译"],"categories":["Note"]},{"title":"Android——Looper","url":"/post/android/android-looper/","content":"<!-- more -->\n\n前言：本文是针对 Looper 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：\n\n  - [Java——ThreadLocal](/post/java/java-threadlocal/ \"TOLINKS\")\n  - [Android——Message](/post/android/android-message/ \"TOLINKS\")\n  - [Android——MessageQueue](/post/android/android-messagequeue/ \"TOLINKS\")\n  - [Android——Looper](/post/android/android-looper/ \"TOLINKS\")\n  - [Android——Handler](/post/android/android-handler/ \"TOLINKS\")\n\n***\n\n# 1. Looper简介\n\n首先看一下源码中对 Looper 的注释说明：\n\n```java\n/**\n  * Class used to run a message loop for a thread.  Threads by default do\n  * not have a message loop associated with them; to create one, call\n  * {@link #prepare} in the thread that is to run the loop, and then\n  * {@link #loop} to have it process messages until the loop is stopped.\n  *\n  * <p>Most interaction with a message loop is through the\n  * {@link Handler} class.\n  *\n  * <p>This is a typical example of the implementation of a Looper thread,\n  * using the separation of {@link #prepare} and {@link #loop} to create an\n  * initial Handler to communicate with the Looper.\n  *\n  * <pre>\n  *  class LooperThread extends Thread {\n  *      public Handler mHandler;\n  *\n  *      public void run() {\n  *          Looper.prepare();\n  *\n  *          mHandler = new Handler() {\n  *              public void handleMessage(Message msg) {\n  *                  // process incoming messages here\n  *              }\n  *          };\n  *\n  *          Looper.loop();\n  *      }\n  *  }</pre>\n  */\npublic final class Looper {\n    /*\n     * API Implementation Note:\n     *\n     * This class contains the code required to set up and manage an event loop\n     * based on MessageQueue.  APIs that affect the state of the queue should be\n     * defined on MessageQueue or Handler rather than on Looper itself.  For example,\n     * idle handlers and sync barriers are defined on the queue whereas preparing the\n     * thread, looping, and quitting are defined on the looper.\n     */\n\n    ......\n}\n```\n\n大致翻译：\n\n（1）Looper 被 Thread 用于运行一个消息循环。一个线程默认不具有与之关联的消息循环（消息队列），如果想要为线程创建一个消息队列，在该线程中调用 ``Looper.prepare()``，然后再调用 ``Looper.loop()`` 来启动消息处理循环，该循环将一直运行直到被终止。\n\n（2）大多数情况下，和消息循环的交互是通过 ``Handler`` 完成的。\n\n（3）以下代码是实现一个具有消息循环的线程的典型方式，通过分别调用 ``prepare()`` 和 ``loop()`` 来创建一个初始化的 ``Handler`` 并用于和 ``Looper`` 交互：\n\n```java\nclass LooperThread extends Thread {\n    public Handler mHandler;\n    public void run() {\n        Looper.prepare();\n        mHandler = new Handler() {\n            public void handleMessage(Message msg) {\n                // process incoming messages here\n            }\n        };\n        Looper.loop();\n    }\n}\n```\n\n（4）Looper 类中包含某些代码，是需要通过 MessageQueue 来设置和管理事件循环的。影响消息队列的状态的 API 应该在 MessageQueue 或 Handler 中而不是在 Looper 本身定义，例如 ``Idle Handler`` 和同步障栅是在消息队列中定义的，而 Thread 的前期准备、消息循环、退出则是在 Looper 中完成的。\n\n以上内容可能涉及到 Handler 或 Message 的内容，可以通过系列对应的文章查阅。\n\n***\n\n# 2. Looper初始化和实例化\n\nLooper 类光是从名字就能看出来作用，通过之前对 Handler 的源码分析可以知道，Handler 构造时，可以手动传入一个 Looper 对象和处理消息的回调 Callback，用来与 Handler 绑定，此时这个 Handler 则会用来处理该 Looper 的消息队列中的消息，并且与该 Looper 处在同一线程，而默认构造方法则最终都调用了以下构造方法，并且内部给 Looper 传入了一个 ``null``：\n\n```java\n/**\n  * Use the {@link Looper} for the current thread with the specified callback interface\n  * and set whether the handler should be asynchronous.\n  *\n  * Handlers are synchronous by default unless this constructor is used to make\n  * one that is strictly asynchronous.\n  *\n  * Asynchronous messages represent interrupts or events that do not require global ordering\n  * with respect to synchronous messages.  Asynchronous messages are not subject to\n  * the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}.\n  *\n  * @param callback The callback interface in which to handle messages, or null.\n  * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for\n  * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.\n  *\n  * @hide\n  */\npublic Handler(@Nullable Callback callback, boolean async) {\n    if (FIND_POTENTIAL_LEAKS) {\n        final Class<? extends Handler> klass = getClass();\n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                klass.getCanonicalName());\n        }\n    }\n\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()\n                    + \" that has not called Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n可以看到默认情况下会调用 ``Looper.myLooper()``，再查看一下这个方法：\n\n```java\n/**\n  * Return the Looper object associated with the current thread.  Returns\n  * null if the calling thread is not associated with a Looper.\n  */\npublic static @Nullable Looper myLooper() {\n    return sThreadLocal.get();\n}\n```\n\n这个方法也就是从 ``ThreadLocal`` 中获取一个对象，ThreadLocal 的相关内容在系列文章中已有介绍，简单来说，首先需要向当前线程中 ``set()`` 一个对象，才能 ``get()`` 出来，并且 ThreadLocal 中存放的对象是和线程绑定的，不同线程只能 ``get()`` 到该线程自己 ``set()`` 进去的对象，再看一下这个 ``sThreadLocal`` 在一开始的声明：\n\n```java\n// sThreadLocal.get() will return null unless you've called prepare().\n@UnsupportedAppUsage\nstatic final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();\n```\n\n说明存取的都是 Looper 对象。Looper 其实有两个 ``prepare()`` 方法，一个无参，另一个就是以下这个有一个布尔类型参数的，但无参的 ``prepare()`` 最终也是调用的有参这个：\n\n```java\n/** Initialize the current thread as a looper.\n  * This gives you a chance to create handlers that then reference\n  * this looper, before actually starting the loop. Be sure to call\n  * {@link #loop()} after calling this method, and end it by calling\n  * {@link #quit()}.\n  */\npublic static void prepare() {\n    prepare(true);\n}\n```\n\n在 ``Looper.prepare(boolean)`` 方法中有这么一段：\n\n```java\nprivate static void prepare(boolean quitAllowed) {\n    if (sThreadLocal.get() != null) {\n        throw new RuntimeException(\"Only one Looper may be created per thread\");\n    }\n    sThreadLocal.set(new Looper(quitAllowed));\n}\n```\n\n到这里就清楚了，Looper 在调用 ``prepare()`` 方法后，会往对应的 ThreadLocal 中存放一个实例化的 Looper 对象，而 ``Looper.myLooper()`` 则是从 ThreadLocal 中取出这个对象，因此如果一个 Looper 没有先调用 ``prepare()`` 就直接使用会报错。但是为什么不直接通过 ``new`` 来生成实例对象呢？因为 Looper 的构造方法是私有的：\n\n```java\nprivate Looper(boolean quitAllowed) {\n    mQueue = new MessageQueue(quitAllowed);\n    mThread = Thread.currentThread();\n}\n```\n\n这么设计的好处我个人理解为：① Looper、Handler、Thread 这些类都是由系统进行资源管理的，用户不应具有太大的修改权限，并且 Looper 类是 ``final`` 修饰的，也不允许用户继承重写。② Looper 必须和指定的线程绑定，指定调用 ``prepare()`` 方法可以强调这一特性。③ Looper 只能和一个线程绑定，使用 ThreadLocal 管理，采用 ``new`` 的方式可能会有多线程的问题。\n\n***\n\n# 3. Looper总结\n\n其实到这里 Looper 的工作原理和流程就已经可以总结了：\n\n  - ① Looper 是一个消息循环。\n  - ② Looper 内有成员变量 MessageQueue，并通过它循环取出、派发消息进行事件处理。\n  - ③ Looper 无法通过构造方法实例化，而是通过 ``prepare()`` 方法，并在内部调用了 ``myLooper()`` 方法来实例化一个 Looper 对象，且会和线程绑定，通过对应线程的 ThreadLocal 来存取。\n  - ④ Looper 所在的线程决定了 Handler 处理消息时所在的线程。实例化 Handler 时，可以自行创建某线程的 Looper 实例化对象，并将其与 Handler 绑定，则 Handler 处理的消息即来自于 Looper 所在的线程。\n  - ⑤ 线程默认是不具有消息循环的，也即默认情况下一个 Thread 是不会维护 Looper 的，通过继承重写 Thread，并在其中调用 ``Looper.prepare()`` 来创建消息循环，再通过 ``Looper.loop()`` 来开启循环。\n\n但在实际开发中其实有些比较常见的问题：\n\n（1）平时用 Handler 处理消息时，并没有调用 ``Looper.prepare()`` 或通过其手动创建一个 Looper 对象，但依然可以正常处理消息。这是因为，Android 的主线程即 UI 线程，有一定的特殊性，整个 App 过程中仅允许存在一个 UI 线程，而 App 的主线程对应在 ``ActivityThread.main()`` 方法，其也是整个 App 的入口方法，在这个方法里面就生成了 Looper 的实例：\n\n```java\nLooper.prepareMainLooper();\n```\n\n对应 Looper 中的源码为：\n\n```java\n/**\n  * Initialize the current thread as a looper, marking it as an\n  * application's main looper. The main looper for your application\n  * is created by the Android environment, so you should never need\n  * to call this function yourself.  See also: {@link #prepare()}\n  */\npublic static void prepareMainLooper() {\n    prepare(false);\n    synchronized (Looper.class) {\n        if (sMainLooper != null) {\n            throw new IllegalStateException(\"The main Looper has already been prepared.\");\n        }\n        sMainLooper = myLooper();\n    }\n}\n```\n\n虽然本质上仍然是通过 ``prepare(boolean)`` 方法生成了一个成员变量 ``sMainLooper``，但是加了类锁，并且只允许创建一次，由于 App 运行期间，主线程一直存在，因此主线程的对应的 Looper 实例对象 ``sMainLooper`` 在 App 运行期间有且仅有一个，所以在主线程中使用 Handler 无需手动创建 Looper 实例对象以及显式调用 ``prepare()``：\n\n```java\n// 主线程中实例化 Handler\nprivate Handler mainHandler = new Handler(new Handler.Callback() {\n    @Override\n    public boolean handleMessage(@NonNull Message msg) {\n        return false;\n    }\n});\n```\n\n（2）即使在子线程中，也可以不显式调用 ``prepare()`` 方法，这时 Handler 的初始化方式为：\n\n```java\nprivate Handler mainHandler = new Handler(Looper.getMainLooper()) {\n    @Override\n    public void handleMessage(@NonNull Message msg) {\n        super.handleMessage(msg);\n    }\n};\n```\n\n※ 注 | 这里是 ``void handleMessage(Message)``和（1）中使用匿名 Callback 的 ``boolean handleMessage(Message)`` 不同。\n\n这里不需要显式调用 ``prepare()`` 的原因是给 Handler 传了一个 ``Looper.getMainLooper()`` 的参数，源码如下：\n\n```java\n/**\n  * Returns the application's main looper, which lives in the main thread of the application.\n  */\npublic static Looper getMainLooper() {\n    synchronized (Looper.class) {\n        return sMainLooper;\n    }\n}\n```\n\n可以看到实际上就是返回了主线程的 ``sMainLooper``，所以也不需要手动创建 Looper 实例对象。\n\n（3）利用 <font color=#EB6D39>“Handler 处理消息所在线程由其实例化时传入的 Looper 对象决定”</font> 这一特性，可以衍生出主线程和子线程之间交互的方式：\n\n  - ① 子线程向主线程发送消息：在子线程实例化 Handler 时传入 ``Looper.getMainLooper()`` 参数。\n  - ② 主线程向子线程发送消息：在主线程实例化 Handler 时传入一个在子线程中调用过 ``prepare()`` 方法已初始化的 Looper 对象。\n\n针对以上情形 ②，主线程开启子线程后向下执行，如果主线程发送消息的时间较早，可能子线程还没有完成对 Looper 的实例化，则会导致空指针异常，此时可以将子线程用 ``HandlerThread`` 类代替，实例化时传入一个 ``String`` 类型的线程标记名，HandlerThread 不能重写 ``run()`` 方法，当然也不需要显式调用 ``prepare()`` 和 ``loop()``，通过 ``HandlerThread.getLooper()`` 即可获取 Looper 实例对象。","tags":["Android","源码","Looper"],"categories":["Android"]},{"title":"Android——Handler","url":"/post/android/android-handler/","content":"<!-- more -->\n\n前言：本文是针对 Handler 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：\n\n  - [Java——ThreadLocal](/post/java/java-threadlocal/ \"TOLINKS\")\n  - [Android——Message](/post/android/android-message/ \"TOLINKS\")\n  - [Android——MessageQueue](/post/android/android-messagequeue/ \"TOLINKS\")\n  - [Android——Looper](/post/android/android-looper/ \"TOLINKS\")\n  - [Android——Handler](/post/android/android-handler/ \"TOLINKS\")\n\n***\n\n# 1. Handler的实例化和初始化\n\nHandler 在 Android 开发中还是相当相当常见的，其涉及到了很多 Android 和 Java 的数据结构。Handler 的源码并不复杂，原理也很有意思，常用的方法里实例化和初始化就占了很大一部分，消息 Message 的传递也占了很大一部分，本文主要也是分析这两点，剩下的用的不是太多，直接阅读源码也很快，在本文就不分析了。通过阅读 Handler 以及相关类的源码，可以深刻体会到 Android 的一些通用设计理念。\n\n<br/>\n\n## 1.1 什么是Handler\n\n在 Handler 的源码中，有一段很长的注释：\n\n```java\n/**\n * A Handler allows you to send and process {@link Message} and Runnable\n * objects associated with a thread's {@link MessageQueue}.  Each Handler\n * instance is associated with a single thread and that thread's message\n * queue.  When you create a new Handler, it is bound to the thread /\n * message queue of the thread that is creating it -- from that point on,\n * it will deliver messages and runnables to that message queue and execute\n * them as they come out of the message queue.\n * \n * <p>There are two main uses for a Handler: (1) to schedule messages and\n * runnables to be executed at some point in the future; and (2) to enqueue\n * an action to be performed on a different thread than your own.\n * \n * <p>Scheduling messages is accomplished with the\n * {@link #post}, {@link #postAtTime(Runnable, long)},\n * {@link #postDelayed}, {@link #sendEmptyMessage},\n * {@link #sendMessage}, {@link #sendMessageAtTime}, and\n * {@link #sendMessageDelayed} methods.  The <em>post</em> versions allow\n * you to enqueue Runnable objects to be called by the message queue when\n * they are received; the <em>sendMessage</em> versions allow you to enqueue\n * a {@link Message} object containing a bundle of data that will be\n * processed by the Handler's {@link #handleMessage} method (requiring that\n * you implement a subclass of Handler).\n * \n * <p>When posting or sending to a Handler, you can either\n * allow the item to be processed as soon as the message queue is ready\n * to do so, or specify a delay before it gets processed or absolute time for\n * it to be processed.  The latter two allow you to implement timeouts,\n * ticks, and other timing-based behavior.\n * \n * <p>When a\n * process is created for your application, its main thread is dedicated to\n * running a message queue that takes care of managing the top-level\n * application objects (activities, broadcast receivers, etc) and any windows\n * they create.  You can create your own threads, and communicate back with\n * the main application thread through a Handler.  This is done by calling\n * the same <em>post</em> or <em>sendMessage</em> methods as before, but from\n * your new thread.  The given Runnable or Message will then be scheduled\n * in the Handler's message queue and processed when appropriate.\n */\n```\n\n大概翻译一下，这段注释基本也介绍清楚了 Handler 的工作流程：\n\n  - （1）Handler 允许你发送和处理和线程的 MessageQueue 相关联的 Message 和 Runnable 对象。每个 Handler 实例对象都只和一个线程以及该线程的消息队列。当创建一个 Handler 实例时，这个 Handler 会与线程以及这个线程创建的消息队列绑定，这之后，这个 Handler 会负责给 MessageQueue 传送 Message 和 Runnable，或者负责处理从 MessageQueue 中取出的 Message 和 Runnable。\n  - （2）Handler 有 2 个主要的用途：① 给 Message 和 Runnable 安排一个未来执行的时间（可以是相差 0，表示立即执行）；② 将一个事务提交到另一个不同的线程处理。\n  - （3）Handler 通过 ``post``，``postAtTime(Runnable, long)``，``postDelayed``，``sendEmptyMessage``，``sendMessage``，``sendMessageAtTime``，``sendMessageDelayed`` 方法（具体在：《[Android——Message](/post/android/android-message/ \"TOLINKS\")》有详细介绍）调度 Message。``post`` 方式允许发送一个 Runnable 对象并在被 MessageQueue 接收后调用。``shendMessage`` 方式允许发送一个包括了一个 Bundle 形式的数据的 Message，并且在 ``Handler.handleMessage()`` 方法中处理（要求实现一个 Handler 的子类）。\n  - （4）不论使用 ``post`` 还是 ``send`` 方式发送消息，都可以让这些消息在 MessageQueue 可用时立即处理，或者指定一个延时间隔来延迟处理，或者指定一个具体的处理事件。后面二者可以通过：延迟、具体时间、或其他基于时间的行为来实现。\n  - （5）当 App 的进程被创建时，它的主线程则专门用来运行一个管理顶层应用对象的 MessageQueue，这些顶层应用对象可以是例如：Activity，BroadcastReceiver 等等，或是他们创建的其他 Windows。你可以创建自己的子线程，并通过 Handler 与主线程通信，只需要在子线程中调用上述的 ``send`` 类型或 ``post`` 类型的方法即可，发送的 Message 或 Runnable 将在 Handler 的 MessageQueue 合适的时候被调度和处理。\n\n需要注意的几个重点：① Handler 可以用来发送消息也可以用来处理消息；② 发送消息有两种类型的方式，处理消息可以跨进程；③ Handler 的实例是和当前线程以及当前线程的 MessageQueue 绑定的；④ MessageQueue 中维护的单链表只支持 Message 对象，因此 Runnable 是通过封装进 Message 来实现的。\n\n<br/>\n\n## 1.2 Handler构造方法\n\nHandler 内部有多个不同参数的构造方法，依次看看：\n\n  - ① 无参默认构造方法\n\n```java\n/**\n  * Default constructor associates this handler with the {@link Looper} for the\n  * current thread.\n  *\n  * If this thread does not have a looper, this handler won't be able to receive messages\n  * so an exception is thrown.\n  */\npublic Handler() {\n    this(null, false);\n}\n```\n\n该构造方法会使得 Handler 与当前线程的 Looper 关联，如果当前线程没有 Looper，则 Handler 将无法接收消息，从而抛出异常。\n\n  - ② 1 个参数（``Callback``）的构造方法\n\n```java\n/**\n  * Constructor associates this handler with the {@link Looper} for the\n  * current thread and takes a callback interface in which you can handle\n  * messages.\n  *\n  * If this thread does not have a looper, this handler won't be able to receive messages\n  * so an exception is thrown.\n  *\n  * @param callback The callback interface in which to handle messages, or null.\n  */\npublic Handler(@Nullable Callback callback) {\n    this(callback, false);\n}\n```\n\n和默认无参构造方法类似，只不过重写了接收消息后处理的回调方法 ``handleMessage``。\n\n  - ③ 1 个参数（``async``）的构造方法\n\n```java\n/**\n  * Use the {@link Looper} for the current thread\n  * and set whether the handler should be asynchronous.\n  *\n  * Handlers are synchronous by default unless this constructor is used to make\n  * one that is strictly asynchronous.\n  *\n  * Asynchronous messages represent interrupts or events that do not require global ordering\n  * with respect to synchronous messages.  Asynchronous messages are not subject to\n  * the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}.\n  *\n  * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for\n  * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.\n  *\n  * @hide\n  */\n@UnsupportedAppUsage\npublic Handler(boolean async) {\n    this(null, async);\n}\n```\n\n和默认无参构造方法类似，只不过指定了通过这个 Handler 发送的消息为异步消息（Async）。\n\n  - ④ 以上 ①、②、③ 最终均调用了 2 个参数（``Callback, async``）的构造方法：\n\n```java\n/**\n  * Use the {@link Looper} for the current thread with the specified callback interface\n  * and set whether the handler should be asynchronous.\n  *\n  * Handlers are synchronous by default unless this constructor is used to make\n  * one that is strictly asynchronous.\n  *\n  * Asynchronous messages represent interrupts or events that do not require global ordering\n  * with respect to synchronous messages.  Asynchronous messages are not subject to\n  * the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}.\n  *\n  * @param callback The callback interface in which to handle messages, or null.\n  * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for\n  * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.\n  *\n  * @hide\n  */\npublic Handler(@Nullable Callback callback, boolean async) {\n    if (FIND_POTENTIAL_LEAKS) {\n        final Class<? extends Handler> klass = getClass();\n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                klass.getCanonicalName());\n        }\n    }\n\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()\n                    + \" that has not called Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n通过 《[Android——Looper](/post/android/android-looper/ \"TOLINKS\")》 一文可以知道，``Looper.myLooper()`` 就是返回了当前线程中的 Looper 实例对象，如果当前线程不具备处理消息的功能，也即没有 Looper 实例，则返回 ``null``，接下来也就是当存在 Looper 实例对象时，获取并绑定其消息队列 MessageQueue，处理事件的回调 Callback，以及设置是否异步 async。\n\n  - ⑤ 1 个参数（``Looper``）的构造方法\n\n```java\n/**\n  * Use the provided {@link Looper} instead of the default one.\n  *\n  * @param looper The looper, must not be null.\n  */\npublic Handler(@NonNull Looper looper) {\n    this(looper, null, false);\n}\n```\n\n手动指定这个 Handler 需要绑定的线程，当我们需要从子线程更新 UI 时，通常会使用如下方法来实例化一个 Handler：\n\n```java\nHandler handler = new Handler(Looper.getMainLooper());\n```\n\n这其实就是调用的这个构造方法，而 ``Looper.getMainLooper()`` 返回的就是主线程的 Looper 实例对象。\n\n  - ⑥ 2 个参数（``Looper, Callback``）的构造方法\n\n```java\n/**\n  * Use the provided {@link Looper} instead of the default one and take a callback\n  * interface in which to handle messages.\n  *\n  * @param looper The looper, must not be null.\n  * @param callback The callback interface in which to handle messages, or null.\n  */\npublic Handler(@NonNull Looper looper, @Nullable Callback callback) {\n    this(looper, callback, false);\n}\n```\n\n同时指定 Looper 和 Callback。\n\n  - ⑦ 以上 ⑤、⑥ 最终均调用了 3 个参数的构造方法：\n\n```java\n/**\n  * Use the provided {@link Looper} instead of the default one and take a callback\n  * interface in which to handle messages.  Also set whether the handler\n  * should be asynchronous.\n  *\n  * Handlers are synchronous by default unless this constructor is used to make\n  * one that is strictly asynchronous.\n  *\n  * Asynchronous messages represent interrupts or events that do not require global ordering\n  * with respect to synchronous messages.  Asynchronous messages are not subject to\n  * the synchronization barriers introduced by conditions such as display vsync.\n  *\n  * @param looper The looper, must not be null.\n  * @param callback The callback interface in which to handle messages, or null.\n  * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for\n  * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.\n  *\n  * @hide\n  */\n@UnsupportedAppUsage\npublic Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {\n    mLooper = looper;\n    mQueue = looper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n这个构造方法则是最详细的，可以同时指定 Looper，Callback，以及是否异步 async。\n\n通过查看以上 7 种构造方法，可以总结出 Handler 的实例化过程：如果没有显式传入任何参数，则默认绑定当前线程的 Looper，使用默认 Callback，发送同步消息，否则按照对应显式传入的参数手动指定。\n\n***\n\n# 2. Handler发送Message\n\n<br/>\n\n## 2.1 源码分析\n\n在平时开发中 Handler 最主要的用途就是在子线程中更新 UI，两种方式：\n\n  - ``send`` 方式，包括：\n    - 1. ``sendMessage`` 或 ``sendEmptyMessage``\n    - 2. ``sendMessageDelayed`` 或 ``sendEmptyMessageDelayed``\n    - 3. ``sendMessageAtTime`` 或 ``sendEmptyMessageAtTime``\n    - 4. ``sendMessageAtFrontOfQueue``（比较特殊，会在后面详细讲解）\n\n  - ``post`` 方式，包括：\n    - 1. ``post``\n    - 2. ``postDelayed``\n    - 3. ``postAtTime``\n    - 4. ``postAtFrontOfQueue``\n\n其中，通过查看 ``post`` 方式的源码可以发现：\n\n```java\n// 默认\npublic final boolean post(@NonNull Runnable r) {\n    return  sendMessageDelayed(getPostMessage(r), 0);\n}\n\n// Delayed\npublic final boolean postDelayed(@NonNull Runnable r, long delayMillis) {\n    return sendMessageDelayed(getPostMessage(r), delayMillis);\n}\n/** @hide */\npublic final boolean postDelayed(Runnable r, int what, long delayMillis) {\n    return sendMessageDelayed(getPostMessage(r).setWhat(what), delayMillis);\n}\npublic final boolean postDelayed(@NonNull Runnable r, @Nullable Object token, long delayMillis) {\n    return sendMessageDelayed(getPostMessage(r, token), delayMillis);\n}\n\n// AtTime\npublic final boolean postAtTime(@NonNull Runnable r, long uptimeMillis) {\n    return sendMessageAtTime(getPostMessage(r), uptimeMillis);\n}\npublic final boolean postAtTime(@NonNull Runnable r, @Nullable Object token, long uptimeMillis) {\n    return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);\n}\n\n// AtFrontOfQueue\npublic final boolean postAtFrontOfQueue(@NonNull Runnable r) {\n    return sendMessageAtFrontOfQueue(getPostMessage(r));\n}\n```\n\n实际上 ``post`` 方式最终都是通过 ``send`` 方式实现的。再看一下各个 ``send`` 方式的源码：\n\n```java\npublic final boolean sendMessage(@NonNull Message msg) {\n    return sendMessageDelayed(msg, 0);\n}\n\npublic final boolean sendEmptyMessage(int what) {\n    return sendEmptyMessageDelayed(what, 0);\n}\n\npublic final boolean sendEmptyMessageDelayed(int what, long delayMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageDelayed(msg, delayMillis);\n}\n\npublic final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {\n    Message msg = Message.obtain();\n    msg.what = what;\n    return sendMessageAtTime(msg, uptimeMillis);\n}\n\npublic final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) {\n    if (delayMillis < 0) {\n        delayMillis = 0;\n    }\n    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);\n}\n\npublic boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n                this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, uptimeMillis);\n}\n\npublic final boolean sendMessageAtFrontOfQueue(@NonNull Message msg) {\n    MessageQueue queue = mQueue;\n    if (queue == null) {\n        RuntimeException e = new RuntimeException(\n            this + \" sendMessageAtTime() called with no mQueue\");\n        Log.w(\"Looper\", e.getMessage(), e);\n        return false;\n    }\n    return enqueueMessage(queue, msg, 0);\n}\n```\n\n在以上源码中可以看到一个参数：``uptimeMillis``，这个参数是从开机到当前时刻的时间间隔（毫秒，当设备处于睡眠时不计算），表示消息需要被处理时的时间，任意不同时刻获取到的该值都是不同的，``uptimeMillis`` 越小表示消息越早处理。**消息在添加到消息队列中时，是按照实际处理的时间从先到后按顺序排列的**，详细的处理机制可参考：[Android——MessageQueue](/post/android/android-messagequeue/ \"TOLINKS\")。并且除了 ``sendMessageAtFrontOfQueue`` 方法之外，其他 ``send`` 方式本质都是通过这一个方法发送的：``sendMessageAtTime``，而这两个方法最终都调用了 ``enqueueMessage``，看看这个方法内部：\n\n```java\nprivate boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) {\n    msg.target = this;\n    msg.workSourceUid = ThreadLocalWorkSource.getUid();\n\n    if (mAsynchronous) {\n        msg.setAsynchronous(true);\n    }\n    return queue.enqueueMessage(msg, uptimeMillis);\n}\n```\n\n这个方法每一句都说明了 Message 的一个性质：\n\n  - ``msg.target = this;`` 这句把 Message 和 Handler 绑定在了一起。\n  - ``msg.workSourceUid = ThreadLocalWorkSource.getUid();`` 这句是获取到了当前线程的 Uid，也就是和当前线程绑定在了一起。\n  - ``msg.setAsynchronous(true);`` 这句是设置为异步，``if`` 也表示默认情况下的 Message 是同步的。\n\n最后调用了 ``MessageQueue.enqueueMessage`` 方法把 Message 插入到消息队列中。\n\n<br/>\n\n## 2.2 流程总结\n\n通过以上源码分析，Handler 在发送一个消息后的流程也就清楚了：\n\n<font color=#EB6D39>\n\n  - ① 接收一个 Message，并根据设置的延时，设置 Message 的 ``when``\n  - ② 根据情况设置 Message 的类型，默认情况下为同步消息\n  - ③ 将 Message 的 ``target`` 设置为自己\n  - ④ 调用 MessageQueue 的 ``enqueueMessage`` 方法\n  - ⑤ ``MessageQueue.enqueueMessage`` 方法中，根据 ``when`` 从小到大的顺序将 Message 插入到单链表对应位置\n  - ⑥ 根据条件唤醒 Native 层的消息队列\n\n</font>\n\n***\n\n# 3. Handler机制总结\n\n通过分析 Handler 的实例化和初始化，以及 Handler 发送消息的流程，可以总结出 Handler 的工作机制：\n\n  - ① Handler 默认和当前线程以及当前线程的 MessageQueue 绑定，默认发送同步消息。\n  - ② 可以手动指定 Handler 的线程、重写接收消息后的回调方法 ``Callback.handleMessage()``。\n  - ③ 可以手动指定发送的消息类型，但一个 Handler 只能发送一种消息，不能交替发送。\n  - ④ Handler 所在线程由实例化时的 Looper 有关，且只能接收到与之绑定的线程中的消息，如果线程不具备处理消息的功能，则 Handler 无法接收消息且会抛出异常。\n  - ⑤ Handler 有两种发送消息的方式，但本质上都是 ``send`` 方式。\n  - ⑥ Handler 可以发送 Message，也可以发送 Runnable，但由于 MessageQueue 维护的单链表元素是 Message，因此 Runnable 实际上是封装在 message 中的。","tags":["Android","源码","Handler"],"categories":["Android"]},{"title":"Android——MessageQueue","url":"/post/android/android-messagequeue/","content":"<!-- more -->\n\n前言：本文是针对 MessageQueue 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：\n\n  - [Java——ThreadLocal](/post/java/java-threadlocal/ \"TOLINKS\")\n  - [Android——Message](/post/android/android-message/ \"TOLINKS\")\n  - [Android——MessageQueue](/post/android/android-messagequeue/ \"TOLINKS\")\n  - [Android——Looper](/post/android/android-looper/ \"TOLINKS\")\n  - [Android——Handler](/post/android/android-handler/ \"TOLINKS\")\n\n***\n\n# 1. 认识MessageQueue\n\n在分析 MessageQueue 之前，首先要了解到一个消息队列的误区：MessageQueue 从名字上看来是一个“队列”，主要是其处理消息的方式比较像一个队列。实际上，因为会频繁地出现 Message 的插入和删除等操作，如果是用传统的“队列”来存放 Message，插入、删除的效率会很低，因此 MessageQueue 采用单链表的形式（单链表插入、删除只需要变动两个节点对象的连接目标即可）来管理 Message。\n\nMessageQueue 源码里的注释对其一些性质进行了说明：\n\n```java\n/**\n  * Low-level class holding the list of messages to be dispatched by a\n  * {@link Looper}.  Messages are not added directly to a MessageQueue,\n  * but rather through {@link Handler} objects associated with the Looper.\n  *\n  * <p>You can retrieve the MessageQueue for the current thread with\n  * {@link Looper#myQueue() Looper.myQueue()}.\n  */\n```\n\n大概意思是：\n\n  > MessageQueue 是一个持有 Message 的低等级类，它所持有的 Message 由 Looper 分发。Message 并不是直接被添加到 MessageQueue 中的，而是通过 Handler 的对象与 Looper 绑定起来。\n  > \n  > 你可以通过 ``Looper.myQueue()`` 方法取回当前线程的 MessageQueue。\n\n这段注释特别关键，以至于我觉得已经足以说明整个 MessageQueue 的工作方式了，上半段概括了 MessageQueue 如何管理 Message，下半段概括了 MessageQueue、Looper 以及线程的关系。\n\n***\n\n# 2. MessageQueue管理Message\n\n<br/>\n\n## 2.1 添加Message\n\n（1）当一个 Message 产生并且被发送时，通过 Handler 的对象将这个 Message 和当前线程绑定，再插入到 MessageQueue 单链表中。\n\n通过 Handler 源码可知，一个消息被发送后，Handler 最终会调用 ``MessageQueue.enqueueMessage(Message msg, long when)``：\n\n```java\nboolean enqueueMessage(Message msg, long when) {\n    if (msg.target == null) {\n        throw new IllegalArgumentException(\"Message must have a target.\");\n    }\n    if (msg.isInUse()) {\n        throw new IllegalStateException(msg + \" This message is already in use.\");\n    }\n\n    synchronized (this) {\n        if (mQuitting) {\n            IllegalStateException e = new IllegalStateException(\n                    msg.target + \" sending message to a Handler on a dead thread\");\n            Log.w(TAG, e.getMessage(), e);\n            msg.recycle();\n            return false;\n        }\n\n        msg.markInUse();\n        msg.when = when;\n        Message p = mMessages;\n        boolean needWake;\n        if (p == null || when == 0 || when < p.when) {\n            // New head, wake up the event queue if blocked.\n            msg.next = p;\n            mMessages = msg;\n            needWake = mBlocked;\n        } else {\n            // Inserted within the middle of the queue.  Usually we don't have to wake\n            // up the event queue unless there is a barrier at the head of the queue\n            // and the message is the earliest asynchronous message in the queue.\n            needWake = mBlocked && p.target == null && msg.isAsynchronous();\n            Message prev;\n            for (;;) {\n                prev = p;\n                p = p.next;\n                if (p == null || when < p.when) {\n                    break;\n                }\n                if (needWake && p.isAsynchronous()) {\n                    needWake = false;\n                }\n            }\n            msg.next = p; // invariant: p == prev.next\n            prev.next = msg;\n        }\n\n        // We can assume mPtr != 0 because mQuitting is false.\n        if (needWake) {\n            nativeWake(mPtr);\n        }\n    }\n    return true;\n}\n```\n\n关键点：\n\n```java\nif (msg.target == null) {\n    throw new IllegalArgumentException(\"Message must have a target.\");\n}\n```\n\n这句也就是在 《[Android——Message](/post/android/android-message/ \"TOLINKS\")》 一文的“障栅消息”中，手动将 ``Message.target`` 设置为 ``null`` 会报异常的原因。其余部分也就是根据 Message 的 ``when`` 来将 Message 插入到 MessageQueue 的指定位置，并且根据情况唤醒 Native 层的消息队列。\n\n<br/>\n\n## 2.2 移除Message\n\n移除消息有两个不同参数的方法：\n\n```java\n// 使用默认回调初始化 Handler 时移除消息\nvoid removeMessages(Handler h, int what, Object object) {\n    if (h == null) {\n        return;\n    }\n\n    synchronized (this) {\n        Message p = mMessages;\n\n        // Remove all messages at front.\n        while (p != null && p.target == h && p.what == what\n                && (object == null || p.obj == object)) {\n            Message n = p.next;\n            mMessages = n;\n            p.recycleUnchecked();\n            p = n;\n        }\n\n        // Remove all messages after front.\n        while (p != null) {\n            Message n = p.next;\n            if (n != null) {\n                if (n.target == h && n.what == what\n                    && (object == null || n.obj == object)) {\n                    Message nn = n.next;\n                    n.recycleUnchecked();\n                    p.next = nn;\n                    continue;\n                }\n            }\n            p = n;\n        }\n    }\n}\n\n// 使用自定义回调初始化 Handler 时移除消息\nvoid removeMessages(Handler h, Runnable r, Object object) {\n    if (h == null || r == null) {\n        return;\n    }\n\n    synchronized (this) {\n        Message p = mMessages;\n\n        // Remove all messages at front.\n        while (p != null && p.target == h && p.callback == r\n                && (object == null || p.obj == object)) {\n            Message n = p.next;\n            mMessages = n;\n            p.recycleUnchecked();\n            p = n;\n        }\n\n        // Remove all messages after front.\n        while (p != null) {\n            Message n = p.next;\n            if (n != null) {\n                if (n.target == h && n.callback == r\n                    && (object == null || n.obj == object)) {\n                    Message nn = n.next;\n                    n.recycleUnchecked();\n                    p.next = nn;\n                    continue;\n                }\n            }\n            p = n;\n        }\n    }\n}\n```\n\n其实对应的是初始化 Handler 时，一个是使用默认回调，一个是使用自定义回调的情况，具体移除消息的过程几乎是一样的，都是单链表从中移除一个节点的逻辑。\n\n<br/>\n\n## 2.3 移除BarrierMessage\n\n源码是：\n\n```java\n/**\n  * Removes a synchronization barrier.\n  *\n  * @param token The synchronization barrier token that was returned by\n  * {@link #postSyncBarrier}.\n  *\n  * @throws IllegalStateException if the barrier was not found.\n  *\n  * @hide\n  */\n@TestApi\npublic void removeSyncBarrier(int token) {\n    // Remove a sync barrier token from the queue.\n    // If the queue is no longer stalled by a barrier then wake it.\n    synchronized (this) {\n        Message prev = null;\n        Message p = mMessages;\n        while (p != null && (p.target != null || p.arg1 != token)) {\n            prev = p;\n            p = p.next;\n        }\n        if (p == null) {\n            throw new IllegalStateException(\"The specified message queue synchronization \"\n                    + \" barrier token has not been posted or has already been removed.\");\n        }\n        final boolean needWake;\n        if (prev != null) {\n            prev.next = p.next;\n            needWake = false;\n        } else {\n            mMessages = p.next;\n            needWake = mMessages == null || mMessages.target != null;\n        }\n        p.recycleUnchecked();\n\n        // If the loop is quitting then it is already awake.\n        // We can assume mPtr != 0 when mQuitting is false.\n        if (needWake && !mQuitting) {\n            nativeWake(mPtr);\n        }\n    }\n}\n```\n\n和发送一个障栅消息一样，这个方法也加了 ``@hide`` 注解，移除的过程和移除普通消息比较类似，也是单链表移除节点的逻辑。\n\n***\n\n# 3. MessageQueue和线程的交互\n\nMessageQueue 中有一个接口：\n\n```java\n/**\n  * Callback interface for discovering when a thread is going to block\n  * waiting for more messages.\n  */\npublic static interface IdleHandler {\n    /**\n      * Called when the message queue has run out of messages and will now\n      * wait for more.  Return true to keep your idle handler active, false\n      * to have it removed.  This may be called if there are still messages\n      * pending in the queue, but they are all scheduled to be dispatched\n      * after the current time.\n      */\n    boolean queueIdle();\n}\n```\n\n通过注释可以知道：\n\n  - 这个接口的作用是：找出一个线程什么时候阻塞并等待更多（新的）消息。\n\n  - ``queueIdle()`` 的作用是：当一个消息队列处理完全部消息，并且将进入等待的状态时调用。返回 ``true`` 则激活 Idle Handler，返回 ``false`` 则在执行完后将其移除。如果一个消息队列中还存在消息，但在当前时间之后的所有消息，均已经被计划好了分发的时间（也即这些消息都属于 Delay 型的消息，因此在执行到这些消息之前，线程也处在没有消息需要处理的状态），则该方法仍然可能被调用。\n\n具体的意义如下：\n\nHandler 本身除了可以用来发送消息之外，另一个很重要的功能就是去处理接收到的消息，也就是 ``handleMessage`` 方法，普通的 Handler 只会处理人为指定的消息，这些消息对应的事务优先级比较高，因此当消息队列中存在 Message 时，线程会优先处理。但是不论是 Dalvik 还是 JVM，都有一些自己的管理事务，这些事务的优先级不是特别高，或者是不可预期的，但依然需要占用线程才能处理（毕竟线程是 CPU 调度的基本单位），比如 GC，内存碎片整理等，这些事务在非紧急情况下，只会在线程中没有消息时处理，此时处理这些事务的就是 Idle Handler。Idle Handler 并不是一个独立的类型，只需要实现 ``IdleHandler`` 接口即可。\n\n<br/>\n\n## 3.1 添加IdleHandler\n\n既然 ``IdleHandler`` 只是一个接口，那如何让 MessageQueue 在空闲时可以唤起呢？以下方法即可添加一个 IdleHandler 到 IdleHandler 的 ArrayList 中：\n\n```java\n/**\n  * Add a new {@link IdleHandler} to this message queue.  This may be\n  * removed automatically for you by returning false from\n  * {@link IdleHandler#queueIdle IdleHandler.queueIdle()} when it is\n  * invoked, or explicitly removing it with {@link #removeIdleHandler}.\n  *\n  * <p>This method is safe to call from any thread.\n  *\n  * @param handler The IdleHandler to be added.\n  */\npublic void addIdleHandler(@NonNull IdleHandler handler) {\n    if (handler == null) {\n        throw new NullPointerException(\"Can't add a null IdleHandler\");\n    }\n    synchronized (this) {\n        mIdleHandlers.add(handler);\n    }\n}\n```\n\n注释的大致意思是：将一个 IdleHandler 添加到 MessageQueue 中，如果 ``IdleHandler.queueIdle()`` 返回 ``false``，或者直接调用 ``removeIdleHandler()`` 方法，则会移除这个 IdleHandler。\n\n<br/>\n\n## 3.2 移除IdleHandler\n\n移除 IdleHandler 的方法也很简单：\n\n```java\n/**\n  * Remove an {@link IdleHandler} from the queue that was previously added\n  * with {@link #addIdleHandler}.  If the given object is not currently\n  * in the idle list, nothing is done.\n  *\n  * <p>This method is safe to call from any thread.\n  *\n  * @param handler The IdleHandler to be removed.\n  */\npublic void removeIdleHandler(@NonNull IdleHandler handler) {\n    synchronized (this) {\n        mIdleHandlers.remove(handler);\n    }\n}\n```\n\n<br/>\n\n## 3.3 调用IdleHandler\n\n添加和移除 Idle Handler 都已经清楚了，Idle Handler 具体使用的地方，在 MessageQueue 实际处理消息的方法 ``next()`` 里，在默认情况下，每一次调用 ``next`` 就会返回一个 Message，这个 Message 就是下一个需要分发的消息：\n\n```java\n@UnsupportedAppUsage\nMessage next() {\n    // Return here if the message loop has already quit and been disposed.\n    // This can happen if the application tries to restart a looper after quit\n    // which is not supported.\n\n\n    // mPtr 是通过调用 nativeInit() 获取的返回值\n    // 可以认为这个是 Native 层 MessageQueue 初始化后的指针地址\n    final long ptr = mPtr;\n    if (ptr == 0) {\n        return null;\n    }\n\n    int pendingIdleHandlerCount = -1; // -1 only during first iteration\n    int nextPollTimeoutMillis = 0;\n    for (;;) {\n        if (nextPollTimeoutMillis != 0) {\n            Binder.flushPendingCommands();\n        }\n\n        nativePollOnce(ptr, nextPollTimeoutMillis);\n\n        synchronized (this) {\n            // Try to retrieve the next message.  Return if found.\n            final long now = SystemClock.uptimeMillis();\n            Message prevMsg = null;\n            Message msg = mMessages;\n\n\n            // 重点是 msg.target == null，如果满足说明这个 msg 是一个障栅消息\n            // 那么就要阻塞这条消息之后的所有同步消息，而放行异步消息\n            if (msg != null && msg.target == null) {\n                // Stalled by a barrier.  Find the next asynchronous message in the queue.\n\n\n                // 循环结束后有两种情况：\n                // ① 整个消息队列中都没有异步消息，则终止条件为：msg == null\n                // ② 找到了异步消息，则终止条件为：msg.isAsynchronous() == true\n                do {\n                    prevMsg = msg;\n                    msg = msg.next;\n                } while (msg != null && !msg.isAsynchronous());\n            }\n            if (msg != null) {\n                // msg != null 有两种可能：\n                // ① 消息队列没阻塞，msg 是一条同步消息\n                // ② 消息队列被障栅消息阻塞了，但是找到了异步消息\n\n\n                if (now < msg.when) {\n                    // 说明还没到需要分发消息的时候，\n                    // 则计算到需要分发消息中间的间隔，\n                    // 在间隔时间后再唤醒消息队里进行分发\n\n\n                    // Next message is not ready.  Set a timeout to wake up when it is ready.\n                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                } else {\n                    // 说明到了需要分发消息的时候\n\n\n                    // Got a message.\n\n\n                    // 开始分发消息了，不是阻塞状态\n                    mBlocked = false;\n\n\n                    // 由于将这条消息分发出去了，相当于要从链表里去掉这个消息\n                    // 需要判断当前消息是不是第一个消息\n                    // prevMsg 表示该 msg 的前一个消息\n                    if (prevMsg != null) {\n                        prevMsg.next = msg.next;\n                    } else {\n                        mMessages = msg.next;\n                    }\n\n\n                    // 由于该消息即将被分发出去，因此该消息的下一条就没用了\n                    // 置为空，去掉无用引用，防止内存溢出\n                    msg.next = null;\n                    if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n\n\n                    // 把该 msg 标识为“使用中”\n                    msg.markInUse();\n\n\n                    // 返回这条 msg 作为需要处理的消息\n                    return msg;\n                }\n            } else {\n                // 说明 msg == null，此时有两种可能：\n                // ① 已经没有消息需要分发\n                // ② 当前队列被障栅消息阻塞了，却又没有异步消息（不论是否有同步消息）\n\n\n                // No more messages.\n                nextPollTimeoutMillis = -1;\n            }\n\n            // Process the quit message now that all pending messages have been handled.\n            if (mQuitting) {\n                // 如果当前消息队列是正在退出的状态\n                // 则调用 dispose() 销毁 Native 层的消息队列\n                dispose();\n                return null;\n            }\n\n\n            // ======================\n            // 以下为 IdleHandler 部分\n            // ======================\n\n\n            // If first time idle, then get the number of idlers to run.\n            // Idle handles only run if the queue is empty or if the first message\n            // in the queue (possibly a barrier) is due to be handled in the future.\n            if (pendingIdleHandlerCount < 0\n                    && (mMessages == null || now < mMessages.when)) {\n                pendingIdleHandlerCount = mIdleHandlers.size();\n            }\n            if (pendingIdleHandlerCount <= 0) {\n                // No idle handlers to run.  Loop and wait some more.\n                mBlocked = true;\n                continue;\n            }\n\n            if (mPendingIdleHandlers == null) {\n                mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n            }\n            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n        }\n\n        // Run the idle handlers.\n        // We only ever reach this code block during the first iteration.\n        for (int i = 0; i < pendingIdleHandlerCount; i++) {\n            final IdleHandler idler = mPendingIdleHandlers[i];\n            mPendingIdleHandlers[i] = null; // release the reference to the handler\n\n            boolean keep = false;\n            try {\n                keep = idler.queueIdle();\n            } catch (Throwable t) {\n                Log.wtf(TAG, \"IdleHandler threw exception\", t);\n            }\n\n            if (!keep) {\n                synchronized (this) {\n                    mIdleHandlers.remove(idler);\n                }\n            }\n        }\n\n        // Reset the idle handler count to 0 so we do not run them again.\n        pendingIdleHandlerCount = 0;\n\n        // While calling an idle handler, a new message could have been delivered\n        // so go back and look again for a pending message without waiting.\n        nextPollTimeoutMillis = 0;\n    }\n}\n```\n\n基本的解读都在代码注释中了，还是比较通俗易懂的。重点注意专门加的这句注释：``// 以下为 IdleHandler 部分``，可以看看这句注释以上的部分，首先是判断了下一条消息，然后判断了当前消息队列是否正在退出，这个 ``next()`` 方法基本上要么返回了下一条需要分发的 Message，要么返回了 ``null``，只有以下几种情况时才能执行到这句注释的地方：\n\n  - （1）当前消息队列没有任何消息了，且不在退出状态。\n  - （2）当前消息队列没有被障栅消息阻塞，且没有同步消息，也没有异步消息，且不在退出状态。\n  - （3）当前消息队列没有被障栅消息阻塞，没有同步消息，虽然有异步消息，但还没有到需要分发的时间，且不在退出状态。\n  - （4）当前消息队列被障栅消息阻塞了，但没有异步消息（不论是否有同步消息），且不在退出状态。\n  - （5）当前消息队列被障栅消息阻塞了，虽然有异步消息（不论是否有同步消息），但还没有到需要分发的时间，且不在退出状态。\n\n以上几种情况中，（2）和（3）其实可以归到一起，（3）和（4）也可以归到一起，再进一步合并逻辑，其实就代表了这么一种状态：消息队列当前没有任务，而且也不在退出状态。只有这个状态下，才会调用 ``IdleHandler.queueIdle``，具体的任务则由 ``IdleHandler`` 接口的具体实现决定了。消息队列中对 IdleHandler 的处理比较简单，注释也已经讲得比较详细，就不另行分析了。\n\n***\n\n# 4. MessageQueue总结\n\n通过以上的源码分析，MessageQueue 的工作流程也就清楚了：\n\n<font color=#EB6D39>\n\n  - ① 初始化 MessageQueue，同时初始化 Native 层的 MessageQueue。\n  - ② 通过 Handler 添加或移除 Message。\n  - ③ 线程执行的过程中，不断调用 ``next()`` 方法来获取需要分发处理的消息。\n  - ④ 如果线程中有需要分发处理的消息，则正常分发。\n  - ⑤ 如果线程中已经没有或暂时没有需要分发处理的普通消息，则去处理 Idle 事务。\n  - ⑥ 如果既没有普通消息需要分发处理，也没有 Idle 事务，则阻塞消息队列，使其进入等待新消息的状态。\n  - ⑦ 如果需要退出消息队列，则调用 ``dispose()`` 方法同步销毁 Native 层的 MessageQueue。\n\n</font>","tags":["Android","源码","MessageQueue","消息队列"],"categories":["Android"]},{"title":"Android——Message","url":"/post/android/android-message/","content":"<!-- more -->\n\n前言：本文是针对 Message 内部的一些分析，但涉及到的知识还可能出现在以下文章中，建议都参考一遍：\n\n  - [Java——ThreadLocal](/post/java/java-threadlocal/ \"TOLINKS\")\n  - [Android——Message](/post/android/android-message/ \"TOLINKS\")\n  - [Android——MessageQueue](/post/android/android-messagequeue/ \"TOLINKS\")\n  - [Android——Looper](/post/android/android-looper/ \"TOLINKS\")\n  - [Android——Handler](/post/android/android-handler/ \"TOLINKS\")\n\n***\n\n# 1. Message的种类\n\n在 Android 中，Message 是使用 Handler 时不可避免的一个类，通常都会使用 Message 来发送一些“消息”，这个“消息”有自己的标识 ``what``，有自己的两个通用参数 ``arg1`` 和 ``arg2``，有自己的具体消息内容 ``obj``，似乎消息就是一个通过标识传递数据的功能，但其实里面大有门道。\n\n在使用 Message 时，默认情况下越早发送的消息越早被处理，这是因为默认的消息即为同步消息，而实际上消息有三种：同步消息、异步消息、障栅消息：\n\n  - 1. 在默认情况下均为 **同步消息**，同步消息的意义即：除非指定 Message 的执行时间，否咋 Message 会以队列（FIFO，先进先出）的机制顺序处理消息。\n  - 2. 异步消息则不受顺序的限制，即使在同步消息阻塞的情况下，依然可以处理异步消息。\n  - 3. 障栅消息本身并不携带额外的数据，可以看成是一个阻塞器，它用于阻塞同步消息而对异步消息没有影响，可以看成是让异步消息优先执行的一个调节器。\n\n而消息是否同步，并不是由 Message 本身决定的，而是由处理消息的 Handler 决定的（详细可参考：[Android——Handler](/post/android/android-handler/ \"TOLINKS\")），下文将详细介绍这 3 种消息。\n\n***\n\n# 2. 同步消息\n\n在默认初始化 Handler 时，不论是调用无参构造方法，还是传递 Looper 的构造方法，或者重写回调的构造方法，其实源码里都有这么一个内部调用：\n\n```java\npublic Handler() {\n    this(null, false);\n}\npublic Handler(@NonNull Looper looper) {\n    this(looper, null, false);\n}\npublic Handler(@Nullable Callback callback) {\n    this(callback, false);\n}\n```\n\n内部调用了有布尔值的构造方法：\n\n```java\n// 省略了其他几个带布尔值的构造方法，详细可查源码\n@UnsupportedAppUsage\npublic Handler(boolean async) {\n    this(null, async);\n}\n......\n```\n\n这些带布尔值的内部构造方法，其布尔值含义都是一样的：``async``，是否异步。可以看到，当我们实例化 Handler 没有显式传入一个 ``true`` 作为参数时，默认调用的内部构造方法均使用了 ``false`` 作为参数，也即：**默认情况下不使用异步**。\n\n***\n\n# 3. 异步消息\n\n如果需要使用异步消息，则需要实例化 Handler 时手动指定 ``async`` 参数。从源码可以看到：\n\n```java\n@hide\n@UnsupportedAppUsage\npublic Handler(boolean async) {\n    this(null, async);\n}\n\n@hide\npublic Handler(@Nullable Callback callback, boolean async) {\n    ......\n}\n\n@hide\n@UnsupportedAppUsage\npublic Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) {\n    ......\n}\n```\n\n源码处，这 3 个可以指定 ``async`` 的构造方法，均添加了 ``@hide`` 注解，也即虽然其定义为 ``public`` 方法，但在外部无法直接调用，需要使用反射的方式，而除了两个参数的构造方法外，另外两个还有 ``@UnsupportedAppUsage`` 注解，该注解的含义是限制了最大可以调用该方法的 API 等级，不过我本人还没有试过其限制的最大 API 到底是多少。\n\n查看第二个方法的源码：\n\n```java\n/**\n  * Use the {@link Looper} for the current thread with the specified callback interface\n  * and set whether the handler should be asynchronous.\n  *\n  * Handlers are synchronous by default unless this constructor is used to make\n  * one that is strictly asynchronous.\n  *\n  * Asynchronous messages represent interrupts or events that do not require global ordering\n  * with respect to synchronous messages.  Asynchronous messages are not subject to\n  * the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}.\n  *\n  * @param callback The callback interface in which to handle messages, or null.\n  * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for\n  * each {@link Message} that is sent to it or {@link Runnable} that is posted to it.\n  *\n  * @hide\n  */\npublic Handler(@Nullable Callback callback, boolean async) {\n    if (FIND_POTENTIAL_LEAKS) {\n        final Class<? extends Handler> klass = getClass();\n        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &&\n                (klass.getModifiers() & Modifier.STATIC) == 0) {\n            Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" +\n                klass.getCanonicalName());\n        }\n    }\n\n    mLooper = Looper.myLooper();\n    if (mLooper == null) {\n        throw new RuntimeException(\n            \"Can't create handler inside thread \" + Thread.currentThread()\n                    + \" that has not called Looper.prepare()\");\n    }\n    mQueue = mLooper.mQueue;\n    mCallback = callback;\n    mAsynchronous = async;\n}\n```\n\n注释里面很清楚地写到，该方法使用当前线程的 Looper 来实例化 Handler。手动指定该方法的参数 ``async = true``，即可使得该 Handler 所发送的消息均为 **异步消息**。\n\n***\n\n# 4. 障栅消息\n\n障栅消息的本质也只是一个 Message，但是其 ``target`` 为 ``null``（其他消息不能设置为 ``null``，否则会报异常），且 ``arg1`` 设置为一个从 0 开始每次自增 1 的 token，用于标识不同的障栅消息。前面已经介绍到，障栅消息的作用是阻塞添加到消息队列的时间比它晚的同步消息，因此障栅消息添加到队列时，会根据添加的时间 ``when`` 来插入到对应的消息位置。为了便于理解，这里把 ``when`` 比障栅消息小的最后一个消息（即障栅消息前一个）称为 LAST，把这个消息的下一个（即障栅消息后一个）称为 ONEMORE。\n\n（1）在 MessageQueue 中发送障栅消息的源码：\n\n```java\npublic int postSyncBarrier() {\n    return postSyncBarrier(SystemClock.uptimeMillis());\n}\n```\n\n其调用了另一个私有同名方法：\n\n```java\nprivate int postSyncBarrier(long when) {\n    // Enqueue a new sync barrier token.\n    // We don't need to wake the queue because the purpose of a barrier is to stall it.\n    synchronized (this) {\n        // mNextBarrierToken 从 0 开始\n        final int token = mNextBarrierToken++;\n        // 障栅消息\n        final Message msg = Message.obtain();\n        msg.markInUse();\n        msg.when = when;\n        msg.arg1 = token;\n\n        // 中间变量，用于记录比障栅消息早的最后一个消息（障栅消息的前一个）\n        Message prev = null;\n        // 当前第一条消息\n        Message p = mMessages;\n        if (when != 0) {\n            // 如果当前消息比障栅消息更早，则不阻塞\n            while (p != null && p.when <= when) {\n                // 用 prev 记录当前消息 p\n                prev = p;\n                // p 指向下一条消息\n                p = p.next;\n            }\n            // 循环完成后，会找出所有 when 比障栅消息更小的 Message\n            // 且按照原顺序连接在单链表中，这些消息不会阻塞。\n            // 此时 LAST 即是 prev，而 p 则指向了 ONEMORE。\n        }\n        if (prev != null) { // invariant: p == prev.next\n            // 说明循环进到了内部，也即障栅消息将位于 LAST 和 ONEMORE 的中间\n            // 则障栅消息的下一条为 ONEMORE，即 p\n            msg.next = p;\n            // LAST 的下一条为障栅消息\n            prev.next = msg;\n        } else {\n            // 说明循环没有进入，也即障栅消息将位于消息队列的首位\n            // 则障栅消息的下一条为原先消息队列的第一条消息\n            msg.next = p;\n            // 消息队列的第一条消息变为障栅消息\n            mMessages = msg;\n        }\n        return token;\n    }\n}\n```\n\n并返回了一个 token，当一个障栅消息被加入到 MessageQueue 后，比障栅消息被添加的时间 ``when`` 更晚的同步消息将被阻塞，而异步消息不受影响，直到使用和返回值相同的 token 作为参数调用 ``removeSyncBarrier(int token)`` 将该障栅消息移除后，同步消息才恢复处理。\n\n从源码中可以得知，这一步其实只是把一个障栅消息插入到 MessageQueue 中，插入的位置是由障栅消息的 ``when`` 决定的，而障栅消息的 ``when`` 则是在公有无参 ``postSyncBarrier()`` 中，传入了一个 ``SystemClock.uptimeMillis()``，因此障栅消息的添加无法自定义插入点，只能在代码中手动在想要阻塞的同步消息的前面执行 ``postSyncBarrier()``。\n\n（2）接下来是移除障栅消息 ``removeSyncBarrier(int token)`` 的源码：\n\n```java\n/**\n  * Removes a synchronization barrier.\n  *\n  * @param token The synchronization barrier token that was returned by\n  * {@link #postSyncBarrier}.\n  *\n  * @throws IllegalStateException if the barrier was not found.\n  *\n  * @hide\n  */\npublic void removeSyncBarrier(int token) {\n    // Remove a sync barrier token from the queue.\n    // If the queue is no longer stalled by a barrier then wake it.\n    synchronized (this) {\n        Message prev = null;\n        // 从消息队列的第一个元素开始\n        Message p = mMessages;\n        //遍历消息队列的所有元素\n        // 只有 p.targe == null 且 p.arg1 == token 的才是对应的障栅消息\n        while (p != null && (p.target != null || p.arg1 != token)) {\n            prev = p;\n            p = p.next;\n        }\n        if (p == null) {\n            throw new IllegalStateException(\"The specified message queue synchronization \"\n                    + \" barrier token has not been posted or has already been removed.\");\n        }\n        // 是否需要唤醒\n        final boolean needWake;\n        \n        if (prev != null) {\n            // 说明目标障栅消息不是第一个消息\n            // 则将障栅消息的前一条消息的 next 指向障栅消息的下一条\n            prev.next = p.next;\n            // 因为障栅消息之前有消息，还没有阻塞，所以不需要唤醒\n            needWake = false;\n        } else {\n            // 如果障栅消息是第一条消息\n            // 则消息队列的第一条消息直接设置为障栅消息的下一条\n            mMessages = p.next;\n            // 如果当前消息（原先障栅消息的下一条）为 null，说明消息队列中没有消息\n            // 如果当前消息的 target != null，说明\n            needWake = mMessages == null || mMessages.target != null;\n        }\n        p.recycleUnchecked();\n\n        // If the loop is quitting then it is already awake.\n        // We can assume mPtr != 0 when mQuitting is false.\n        if (needWake && !mQuitting) {\n            nativeWake(mPtr);\n        }\n    }\n}\n```\n\n移除障栅消息就比较简单了，就是遍历消息队列找到 ``target == null`` 且 token 对应的消息并移除即可，满足某些条件时还需要唤醒 native 层的消息队列。","tags":["Android","源码","Message","消息"],"categories":["Android"]},{"title":"Java——ThreadLocal","url":"/post/java/java-threadlocal/","content":"<!-- more -->\n\n***\n\n# 1. 认识ThreadLocal\n\nThreadLocal 是 Java 中一种很重要的机制 / 数据处理方式，尤其在并发中，数据是否共有、唯一，会直接影响项目的运行逻辑。一般情况下，防止并发冲突或数据不安全的做法是给对象、方法加同步锁 ``synchronized``。但同步锁并不是万能的，例如同步锁会降低批量处理的效率，或者当业务需要保证数据的隔离性，使用同步锁则需要在方法内频繁销毁、重建对象，如果数据使用独立的处理模块，还会破坏模块化，提高耦合。为此，JDK 1.2 增加了一个工具类：即 **``ThreadLocal``**。\n\n***\n\n# 2. 不使用ThreadLocal的问题\n\n为了更好地理解 ThreadLocal 的设计理念，首先考虑以下两个更普遍一些的场景：\n\n  - 1. 一个客户端，需要并发地和服务器交互，并且每个连接都需要持久化（需要保存 Cookie）。\n  - 2. 一个客户端，需要并发地存取数据库，并且每个连接都可能会提交超过一个操作。\n\n（1）如果按最简单的方式来做，每个线程都维护一套自己的网络请求框架，确实不会导致什么异常，但是第一：实际项目中不可能采用这个方案，第二：这么做简直就是“高耦合低内聚”的代表，第三：重新参考以上两条。项目中，绝大部分情况下，一个连接会话会在一个独立的线程内执行，这个线程需要维护一个仅对自己可见的 Cookie，不仅对其他会话不可见，同时也要确保只能获取到自己的 Cookie。\n\n（2）同样，每个线程都独立维护一套数据库会话管理是不现实的，通常会封装到一个工具类中，从工具类中获取、开启、关闭会话以及提交事务等。假如有一个业务：当修改用户信息时，把这个操作记录保存下来。假如每一次的操作都从连接池获取 Connection，就有可能一个操作执行了另一个可能因为某些原因没有执行，所以一般通过以下方式来获取管理 Connection：\n\n```java\npublic class DBUtil {\n    // 省略一些成员变量\n    private static Connection connection;\n\n    // 获取连接实例\n    public static Connection getConnection() {\n        try {\n            Class.forName(driver);\n            connnection = DriverManager.getConnection(url, username, password);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return connnection;\n    }\n\n    // 关闭连接\n    public static void closeConnection() {\n        try {\n            if (connnection != null) {\n                connnection.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n然后用 Transaction 统一提交事务。到目前为止，如果是单线程做这个操作，那是没问题的，但是如果出现并发的情况呢？如果并发很低并且操作轻量，给这个业务方法上同步锁，也是没有问题的，但是如果并发稍微高一些，就不可能放个同步锁了，这时如果还使用这个方案，很有可能会出现 ``No operations allowed after connection closed`` 错误，这是因为连接是共享的，如果后启动的线程 2 先执行完并且关闭了连接，先启动的线程 1 再执行相关操作时连接已经被关闭了。\n\n***\n\n# 3. ThreadLocal如何解决问题\n\nThreadLocal 为每个线程分配了一个独立的资源副本，并在内部通过一个 Table 表来维护每个线程和其拥有的独立资源副本的映射关系，所有的线程共享这个 Table。简单点说，ThreadLocal 中通过 ``set()`` 方法存入对象，通过 ``get()`` 方法取出对象，且线程存入的对象只有该线程自己可以获取到，，每个线程也只能获取到自己之前存入的对象，如果没有存入则调用 ``get()`` 返回的是 ``null``。\n\n因此针对以上两个场景，用 ThreadLocal 就可以很好地解决痛点。\n\n（1）首先是会话连接的持久化，每个线程在建立连接后，调用 ``set()``将自己的 Cookie 存入，并在需要的时候调用 ``get()`` 获取即可，对于每个会话线程，``get()`` 到的都只是自己的 Cookie。\n\n（2）第二个数据库连接管理，也可以把共用的 Connection 放进 ThreadLocal 中管理，改成如下：\n\n```java\npublic class DBUtil {\n    // 省略一些成员变量\n    private static ThreadLocal<Connection> localConnection = new ThreadLocal<>();\n\n    // 获取连接实例\n    public static Connection getConnection() {\n        Connection connnection = localConnection.get();\n        try {\n            if(connection == null) {\n                Class.forName(driver);\n                connnection = DriverManager.getConnection(url, username, password);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            localConnection.set(connection);\n        }\n        return connnection;\n    }\n\n    // 关闭连接\n    public static void closeConnection() {\n        Connection connnection = localConnection.get();\n        try {\n            if (connnection != null) {\n                connnection.close();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            localConnection.remove();\n        }\n    }\n}\n```\n\n当一个新线程调用 ``DBUtil.getConnection()`` 时，会先判断当前线程是否已经存入了一个连接，如果已经存入则直接获取并返回，否则创建一个新的连接，关闭连接时同理。这样，线程之间的连接都是自己的独立对象，不会互相影响。\n\n***\n\n# 4. ThreadLocal和同步锁的比较\n\n当然，ThreadLocal 并不是万能的，相比较同步锁方式，由于每个线程都拥有自己的资源副本，因此消耗的内存也更多，需要根据具体的业务确定方案。详细分析将在之后重新整理一份独立文章。\n\n***\n\n# 5. ThreadLocal源码分析\n\n暂未完成\n","tags":["Java","ThreadLocal","源码"],"categories":["Java"]},{"title":"HashingEncoder的改进——多进程支持","url":"/post/python/python-mphashingencoder/","content":"<!-- more -->\n\n前言：HashingEncoder 对大数据量编码时速度很慢且 CPU 利用率并不高，瞎研究半天写了一个多 __进程__ 版的 HashingEncoder，记录一下踩坑历史。本文代码均为伪代码，改进和源码已收录于 Github 上 scikit-learn 工具包，详情参考 [scikit-learn-contrib](https://github.com/scikit-learn-contrib/categorical-encoding \"TOLINKS\")，建议先阅读：[使用文档](https://github.com/SLLiu96/MPHashingEncoder \"TOLINKS\")。\n\n***\n\n# 1. 源码\n\n有一次在做哈希编码的时候，因为数据量比较大，试了好几种方案，最快都要十二个小时才仅能编码完一个特征，还有 8 个嗷嗷待哺的小特征在后面排队等着我 *~~鞭挞~~* 编码，电脑已经能烤猪蹄了，这可如何是好。\n正愁着莫非要升级一波配置，转头监视器一看，CPU 利用率才 16% 上下，这我可就。。。服务器搞起！阿里云太贵，亚马逊麻烦，TinyMind *~~辣鸡~~* 真辣鸡！华为云好像还不错（我的配置才 3+ 元每小时，不要求最低账内金额），8x3.1GHz + 32G 走你！但是第二个特征依然耗费了 10 个小时才编码完。\n\n受困于编码时间过长。迫于无奈找了找 sklearn 中 HashingEncoder 的 api，没有类似于 n_thread 之类的参数，又看了看源码，从 Pycharm 中一级级往上点，找到了 HashingEncoder 的核心源码部分如下：\n\n```python\n@staticmethod\ndef hashing_trick(X_in, hashing_method='md5', N=2, cols=None, make_copy=False):\n    \"\"\"A basic hashing implementation with configurable dimensionality/precision\n\n    Performs the hashing trick on a pandas dataframe, `X`, using the hashing method from hashlib\n    identified by `hashing_method`.  The number of output dimensions (`N`), and columns to hash (`cols`) are\n    also configurable.\n\n    Parameters\n    ----------\n\n    X_in: pandas dataframe\n        description text\n    hashing_method: string, optional\n        description text\n    N: int, optional\n        description text\n    cols: list, optional\n        description text\n    make_copy: bool, optional\n        description text\n\n    Returns\n    -------\n\n    out : dataframe\n        A hashing encoded dataframe.\n\n    References\n    ----------\n    Cite the relevant literature, e.g. [1]_.  You may also cite these\n    references in the notes section above.\n    .. [1] Kilian Weinberger; Anirban Dasgupta; John Langford; Alex Smola; Josh Attenberg (2009). Feature Hashing\n    for Large Scale Multitask Learning. Proc. ICML.\n\n    \"\"\"\n\n    try:\n        if hashing_method not in hashlib.algorithms_available:\n            raise ValueError('Hashing Method: %s Not Available. Please use one from: [%s]' % (\n                hashing_method,\n                ', '.join([str(x) for x in hashlib.algorithms_available])\n            ))\n    except Exception as e:\n        try:\n            _ = hashlib.new(hashing_method)\n        except Exception as e:\n            raise ValueError('Hashing Method: %s Not Found.')\n\n    if make_copy:\n        X = X_in.copy(deep=True)\n    else:\n        X = X_in\n\n    if cols is None:\n        cols = X.columns.values\n\n    def hash_fn(x):\n        tmp = [0 for _ in range(N)]\n        for val in x.values:\n            if val is not None:\n                hasher = hashlib.new(hashing_method)\n                if sys.version_info[0] == 2:\n                    hasher.update(str(val))\n                else:\n                    hasher.update(bytes(str(val), 'utf-8'))\n                tmp[int(hasher.hexdigest(), 16) % N] += 1\n        return pd.Series(tmp, index=new_cols)\n\n    new_cols = ['col_%d' % d for d in range(N)]\n\n    X_cat = X.loc[:, cols]\n    X_num = X.loc[:, [x for x in X.columns.values if x not in cols]]\n\n    X_cat = X_cat.apply(hash_fn, axis=1)\n    X_cat.columns = new_cols\n\n    X = pd.concat([X_cat, X_num], axis=1)\n\n    return X\n```\n\n好吧，还真是一个 for 循环往下读啊。这十个小时才跑一个特征，服务器的成本有点担不起啊！看来只好曲线救国了。虽然 Python 本身在执行的时候对 CPU 就有个动态调度，但因为 GIL全局锁 的原因，大多数情况下 Python 都是在单核模式运行的。我对 GIL 有一点点自己的理解，从我的角度出发，个人认为 GIL 还是利大于弊的，何况在 Python3 中已经对对线程/多进程提供了挺不错的额外支持，不过本文不深入探讨 GIL 的内容。\n\n***\n\n# 2. 改进思路\n\n<br/>\n\n## 2.1 理论支持\n\n关于什么是哈希编码的内容网上有很多了，在一开始做这个之前，我考虑过一个问题：按顺序依次编码，和多进程分别编码再按原序拼接，最后的结果是一样的吗？如果多进程编码会导致结果变化，那一切都是白费功夫。之所以对此担心，有一个原因是 ``我曾经把哈希编码当成了“集合操作”，如果一开始输入的集合不一致就会导致最后的编码结果不一致``。当然，事后证明我的想法是错误的，为此我找了一些哈希编码的文章来看，幸运的是，只要规定好输入特征和输出维度，最后的结果和编码的顺序并没有关系。许多篇文章都对哈希编码做了很详尽的说明，我选出来五篇自己看完最有心得的放在附录【12】~【16】中。\n\n再经过他人文章的点拨后，我认为多进程实现是可能且符合要求的。把其核心思想总结一下大致可以这么理解：\n\n> 1. 哈希表把输入散列到指定的输出范围内\n> 2. 对于不在训练数据的散列表中的输入，依然可以通过同样的哈希算法计算出散列值\n> 3. 只要指定了相同的散列范围，新的输入也会具有相同的输出特征维度\n> 4. 新输入可以直接进行哈希编码，而不需要再对整体数据重新处理，因此支持在线学习\n> 5. 只有原始值非零，哈希编码才有效，因此可以保持编码前后的稀疏性\n\n也就是说，每一次送去编码的进程，其数据都是独立的，并且完全可以分开编码而不需要考虑别的数据，只要给每个进程设置相同的编码算法和输出维度，最后再将每个独立的数据块按照原数据的顺序重新排列即可。\n\n<br/>\n\n## 2.2 代码思想\n\n既然是多核性能没发挥出来，那就从并行的角度出发，大致的实现逻辑如下：\n\n```python\nimport multithreading\n\nclass HashingEncoder:\n    self.multi_data = []\n    ...\n\n    # 每个线程调用的方法\n    def work():\n        get_data() # 每个线程都从整体数据中获取一部分数据\n        hashing_data = hashing() # 每个线程都单独进行哈希编码\n        self.multi_data.append(hashing_data)\n\n    def transform():\n        for thread in multi_num\n            multithreading.Thread.Thread(target=work).start\n\n        data = pandas.concat(multi_data, ignore_index=True)\n```\n\n省略了大量代码，单从逻辑来看，我的需求就是：\n\n1. 允许用户自定义并行线程数以及每个线程每次编码的样本数\n2. 根据参数创建 n 个进程\n3. 每个线程都依次从所有数据中不重复地顺序取出参数定义数量的数据\n4. 每个线程都独立对自己取到的数据进行哈希编码\n5. 每个线程哈希编码完后将返回数据存储进一个列表内\n6. 将列表内的数据拼接成回一个整体。\n\n***\n\n# 3. 过程中的坑\n\n以下每个小节都是一个记录的坑，为了文章更有逻辑，有些坑我合并成了一节来写。\n\n<br/>\n\n## 3.1 多线程和多进程问题\n最早第一次改进时，我仅仅只是用多线程式：multithreading 模块，在一个小型计算 Demo 上尝试过，表面上来看似乎确实是并行处理，所以我想当然地认为多线程可以解决多核 CPU 利用率的问题，因此我写出了第一个版本的改进代码后，欣喜若狂，然而上数据一测编码时间几乎没有什么缩减，后来再看监视器，发现 CPU 利用率依然还处在单核上，这个结果一度让我差点放弃，好在研究了一下 multiprocessing 的内容，由此进而了解到了 multiprocessing 模块，这两者非常类似，调用方式也几乎一样，最大的区别就是：①multithreading 本质是 threading 线程、②multiprocessing 本质是 processing 进程。  \n进程和线程的关系想必大家都知道，一个进程可以包括多个线程，而[进程](https://baike.baidu.com/item/进程/382503?fr=aladdin \"TOLINKS\")是 CPU 资源分配和调度的基本单位，因此从通俗的话来讲，是进程向 CPU 申请资源，然后再提供给线程使用，对于常见的 CPU 而言，通常一个物理核心就对应了一个（支持超线程的 CPU 则对应多个，但 CPU 的线程和应用的线程不是一回事） __可并行处理的__ 进程，因此想要发挥出 __多核__ 的优势，就要调用 __多进程__。还好，正如上文所说，multiprocessing 和 multithreading 的 API 还是基本类似的，因此下文的坑将直接按照多进程的实现模式举例。\n\n<br/>\n\n## 3.2 并行顺序读取数据问题\n\n首先，Python 中多进程有两种常用方式，第一个是生成多个进程并分别执行，第二个是利用进程池的方式，在很多时候进程池其实是更好的方案，因为进程池可以不必手动管理每个进程的周期，也不用手动安排进程的工作流程，只需要指定最大进程数即可，而且还支持异步获取每个进程执行完后的返回值，<font color=#EB6D39>但是！</font>进程池方式比手动方式稍慢一些，由于追求速度，因此最终采取手动管理方式。  \n现在假设我们开启 4 个进程同时执行一个任务，代码应该大致如下\n\n```python\ndef work():\n    get_data() # 每个线程都从整体数据中获取第 index 部分的数据\n\nprocess_list = []\nfor i in range(4):\n    process.append(multiprocessing.Process(target=work, args=()))\n\nfor p in process_list:\n    p.start()\n    p.join()\n```\n\n由于多进程是并行的，因此尽管循环是依次添加并开启进程，实际上仍然会发生后创建的进程先取数据的情况。有两个思路可以避免这个情况：（1）在创建进程前就先计算好该进程需要选择的数据范围、（2）在进程执行任务时自行选择需要选择的数据范围。  \n方式（1）其实也就是提前限定，因此不需要判断进程获取数据的先后顺序。但由于使用的多进程方案为手动管理方式，而限定数据范围对“需求 1：用户调用时自定义参数”并不友好。例如：当 100 条样本设置了 3 个进程，且每个进程单次编码 13 条数据时，编码的过程则应该是：0 ~ 13; 13 ~ 26; ...; 91 ~ 100 共 8 轮。但因为采用了手动管理方式，意味着在开启新进程时，要么①使用多个循环：每个循环开启三个进程，直到所有样本均被遍历，且还需要在循环内判断当前样本是否已经全部遍历完（在本例中，第三个循环只需要循环两次即遍历完所有样本）而跳过，要么②创建进程时给每个进程传递参数，用来告知每个进程分别需要取几次值，每次又分别取什么范围的数据...不论哪种方式，我想都非常不优雅，所以最终我选择了使用方式（2）实现。\n\n而为了确保每个进程能自己判断所需的数据范围，就需要一个变量用于存放已被读取的范围，则每个进程只需要从还未被读取的数据内选择指定量的数据即可。为此，还需要一个进程锁来确保每个进程在计算数据范围的时候不会因为进程的先后顺序导致重复选择、漏选等情况。这里有一个要注意的点：加锁操作应当只锁住获取起始下标和计算读取范围的部分，其他不会引起冲突的耗时操作例如取出数据和进行编码，则应当在锁释放后执行，否则会导致锁住非冲突耗时操作引起效率降低甚至变成单线程模式。\n\n```python\n\ndef __init__(self):\n    self.lock = multiprocessing.Lock()\n\ndef work(self, done_index):\n    if self.lock.acquire():\n        start = done_index\n        end = done_index + max_samples  # max_samples 是用户定义的每个进程单次读取数据量\n        done_index = end  # 更新已完成的下标\n        self.lock.release()\n        get_data(start, end)\n        hashing()\n    else:\n        self.lock.release()\n\ndone_index = 0  # 初始化下标为从 0 开始\nfor i in range(max_process):  # max_process 是用户定义的最大并行进程数\n    process.append(multiprocessing.Process(target=work, args=(done_index)))\n  ...\n  ...\n```\n\n省略了一些判断、具体实现，下同。事实上这里的 ``done_index`` 一点作用都没有，每一个进程执行到 ``start = done_index`` 时获取到的值都是 0。因为进程被创建时，直接传进去的值属于每个子进程自己的独立空间，如果加上一条 ``print(id(done_index))`` 就会发现所有子进程的 done_index 都不一样，同理，无论是用成员变量的方式 ``self.done_index`` 也好，还是全局变量的方式 ``global done_index`` 也好，结果都是一样的。为了在进程间共享一个数据，可以使用 ``multiprocessing.Value()`` 来实现，搭配进程锁起到共享数据且不冲突的作用。另外，当子进程编码完了当前分配的任务数据后，还有未处理的数据，那么就自己再调用一次分配任务，由于锁和共享数据的存在，也不用担心会出现重复读取的问题：\n\n```python\ndef __init__(self):\n    self.lock = multiprocessing.Lock()\n    self.done_index = multiprocessing.Value('d', 0)\n    self.data_lines = len(data)  # 样本总数目\n\ndef work(self):\n    if self.lock.acquire():  # 加锁，已确保自己获取到的 done_index 是最新的\n        start = self.done_index.value\n        end = start + max_samples  # max_samples 是用户定义的每个进程单次读取数据量\n        self.done_index.value = end  # 更新已完成的下标\n        self.lock.release() # 释放锁，允许其他进程操作更新 done_index\n        get_data(start, end)\n        hashing()\n        if end < self.data_lines:  # 尚有未完成的数据，再次调用分配\n            self.work()\n    else:\n        self.lock.release()\n```\n\n<br/>\n\n## 3.3 编码后数据的保存问题\n\n现在，并行也跑起来了，子进程也能正确获取到数据了，编码也顺利完成后，主进程怎么收集这个数据呢？毕竟手动管理模式并没有返回值，借鉴上面的方法，想使用一个共享变量来存放，但查了一下 Api，发现 Value() 只支持几种基本类型，但需要收集的数据类型复杂（图片来源：附录【1】）：\n\n<center>\n\n![multiprocessing_value_type](/post_files/python/python-mphashingencoder/multiprocessing_value_type.png \"TOPICS\")\n\n</center>\n\n实际上，multiprocessing 提供了一个非常好的内置方案：队列 Queue。Queue 允许进程按先进先出的顺序使用 ``put()`` 存、使用 ``get()`` 取对象，且允许设置读、写超时，一旦读、写超过超时时间，则中断锁并放弃操作。Queue 在读取完当前对象后会将其从队列中删除，既能保证数据读取的不重复，还能缩减内存：\n\n```python\ndef __init__(self):\n    self.hashing_parts = multiprocessing.Queue()\n\ndef work(self):\n    ...\n    data = hashing()\n    self.hashing_parts.put(data)\n\n...\n...\n\n# 主线程等待所有子线程执行完毕\nlist_data = []\nwhile not hashing_parts.empty():\n    list_data.append(hashing_parts.get())\n```\n\n<br/>\n\n## 3.4 结果数据顺序问题\n\n到这一步，已经可以顺利获取到所有编码完成后的返回值了，都存在 ``list_data`` 列表里面，只需要使用 ``pandas.concat(list_data, ignore_index = 0)`` 就能把所有数据拼起来成为完整的编码后数据，<font color=#EB6D39>但是！</font>并行编码进程完成的顺序并不能预先确定，很可能后开始的进程先编码完并存进 list_data 内，直接拼接会导致与源数据样本顺序不一致，导致的后果是在一开始提交 PR 时管理员告诉我的：\n\n> With return_df=False, a different ordering of the samples could lead into nasty surprises, because numpy.ndarray doesn't preserve index -> the training data would not be aligned with the labels anymore.\n\n意思就是，如果 HashingEncoder 设置参数 ``return_df=False``, 其返回值是一个 numpy 的 ndarray 类型数据，和 DataFrame 不同，ndarray 是不保留索引的，因此特征哈希后顺序与源数据不一致会导致和标签 y 的对应关系被打乱。\n\n确实一开始我没有想到这个问题，Queue 本身其实是顺序存储，但在这里，它保障的是编码完成的顺序，而不是编码的数据的顺序，如果对数据顺序有要求，使用字典是一个很好的办法，用 key 来存放当前数据的索引位置，用 value 存放每一组数据，最后主进程获取所有的字典数据，并按照键值顺序排序后再拼接：\n\n```python\ndef __init__(self):\n    self.hashing_parts = multiprocessing.Queue()\n\ndef work(self):\n    ...\n    start = ...  # 当前数据块起始下标\n    end = ...  # 当前数据块结束下标\n    data = hashing()\n    part_index = int(math.ceil(end_index / self.max_sample))\n    self.return_data.put({part_index: data}})\n\nlist_data = {}\nwhile not hashing_parts.empty():\n    list_data.update(hashing_parts.get())  # 取出所有的代码块（无序状态）\nsort_data = []\nfor part_index in sorted(list_data):  # 将所有字典型数据块按照 key 排序后把 value 取出\n    sort_data.append(list_data[part_index])\ndata = pandas.concat(sort_data, ignore_index=True)  # 拼接数据\n```\n\n其中 ``part_index`` 的算法是用当前已完成的下标除以每个进程单次处理的下标，并向上取整（为了让结果更直观地从 1 开始），来作为当前数据块的定位。\n\n<br/>\n\n## 3.5 子进程调用问题\n\n到了这一步，整体逻辑已经和最终版本差异不大了，从 Demo 测试的结果来看也没有什么问题，不过毕竟这是一个面向公众的平台，不能只是写个 Demo 编译通过就了事，还得通过一定的测试验证。sklearn-category_encoders 采用的是 CI 测试部署方案，在本地可以用 nose 进行单元测试。但是在单元测试中报了这么一个错：\n\n```python\nRuntime Error: Lock objects should only be shared between processes through inheritance.\n```\n\n单从报错信息来看，是提醒我们：`进程锁只能通过继承的方式在进程间共享`，好吧，helpful hah?\n\n后来我在附录【2】文中找到了有用的答案：\n\n> 进程锁作为一个不可直接打包的资源是没有办法作为一个参数直接给Pool的map方法里的函数传参的\n\n虽然问题并不完全一样，而且就目前来说，直接在代码中引用是可以运行的，不过我认为这是一个启发点。根据作者提供的解决方案，由于没有采用 Pool 的多进程方式，因此选择了使用 Manager 来管理共享变量：\n\n```python\ndef __init__(self):\n    self.lock = multiprocessing.Manager.Lock()\n    self.hashing_parts = multiprocessing.Manager.Queue()\n    self.done_index = multiprocessing.Manager.Value('d', 0)\n```\n\n<br/>\n\n## 3.6 深拷贝问题\n\nOK！完成了上面这些步骤，可以说，最本质的代码层和逻辑层已经完成，CI 测试也已经通过，不过命运就是这么反复无常——category_encoders 的管理员告诉我，使用这套 HashingEncoder 运行一个大数据量的基准测试时，multiprocessing 的 Manager 报错了（省略部分信息）：\n\n```python\nTraceback (most recent call last):\n    ...\n    ...\n    File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py\", line 180, in deepcopy\n        y = _reconstruct(x, memo, *rv)\n    File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py\", line 280, in _reconstruct\n        state = deepcopy(state, memo)\n    File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py\", line 150, in deepcopy\n        y = copier(x, memo)\n    File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/copy.py\", line 240, in _deepcopy_dict\n        y[deepcopy(key, memo)] = deepcopy(value, memo)\n    ...\n    ...\nmultiprocessing.managers.RemoteError:\n---------------------------------------------------------------------------\nUnserializable message: Traceback (most recent call last):\n    File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/managers.py\", line 289, in serve_client\n        send(msg)\n    File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/connection.py\", line 206, in send\n        self._send_bytes(_ForkingPickler.dumps(obj))\n    File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/multiprocessing/reduction.py\", line 51, in dumps\n        cls(buf, protocol).dump(obj)\nTypeError: can't pickle _thread.lock objects\n```\n\n下栏中的 Traceback 真是让我一头雾水！点进源码里面看了半天也不知所以然，不过我注意到了上面一栏中，有一个非常关键的错误信息：<font color=#EB6D39>deepcopy！</font>为了验证是不是深拷贝带来的问题写个小测试：\n\n```python\nfrom copy import deepcopy\n\nhe = HashingEncoder()\nhe_cp = deepcopy(he)\n```\n\n报错复现！看来主要问题就出在深拷贝上了！从网上找了找，发现这个报错的内容比较少，不过参考的附录【3】和【4】中都指出了一个关键因素：\n\n> - 进程池内部处理使用了 pickle 模块(用于 python 特有的类型和 python 的数据类型间进行转换)中的 dump(obj, file, protocol=None,) 方法对参数进行了封装处理\n> - 在实现多进程的参数中，初始化了自定义类对象\n\n有共性就好找原因，虽然从这两篇文章来看和我本身的情况又是如此不一致，不过我似乎联想到了什么：\n\n既然造成这个错误的原因是开启子进程时，参数带有自定义类对象（通常是不可被 pickle 的），那我就从子进程的参数开始入手：\n\n```python\ndef __init__(self):\n    self.lock = multiprocessing.Manager.Lock()\n    self.hashing_parts = multiprocessing.Manager.Queue()\n    self.done_index = multiprocessing.Manager.Value('d', 0)\n\ndef work(self):\n    self.lock ...\n    self.hashing_parts ...\n    self.done_index ...\n    ...\n    ...\n\nfor i in range(max_process):  # max_process 是用户定义的最大并行进程数\n    process.append(multiprocessing.Process(target=work, args=()))\n...\n...\n```\n\n我好像发现了什么：进程锁 ``lock``，数据队列 ``hashing_parts``，完成下标 ``done_index``，都是在 HashingEncoder 初始化时定义的，虽然这些都不是我的自定义类对象，但回顾参考一下报错信息的最后一行：\n\n> TypeError: can't pickle \\_thread.lock objects\n\n明确指出：进程锁 Lock 是不能被 pickle 转化的，事实上，另外两种 Value 和 Queue 都不可以，只不过因为执行到 pickle Lock 的时候就报错中断了而已。因此，把这些 Manager() 下的对象都放到创建子进程之前，并通过参数传递进去即可：\n\n```python\ndef work(self, _lock, _hashing_parts, _done_index):\n    _lock ...\n    _hashing_parts ...\n    _done_index ...\n\nlock = multiprocessing.Manager.Lock()  # 创建为局部变量\nhashing_parts = multiprocessing.Manager.Queue()  # 创建为局部变量\ndone_index = multiprocessing.Manager.Value('d', 0)  # 创建为局部变量\nfor i in range(max_process):  # max_process 是用户定义的最大并行进程数\n    process.append(\n        # 通过参数传递\n        multiprocessing.Process(target=work,\n                                args=(lock, hashing_parts, done_index)))\n```\n\n大功告成！至此，目前所踩的坑都已解决，提交 PR，回家睡觉！\n\n另外，在查找 multiprocessing 相关内容的时候，无意间看到一个因为 ``logging`` 导致多进程死锁的问题，出现概率较低，记录在附录【10】。作者自己的解答为：\n\n> 由于主进程中使用了thread+mutiprocessing(fork)，导致logging出现死锁，现象就是遇到子进程里第一句logging就hang住。问题只会发生在Linux下。\n\n以及在本地进行单元测试时通常使用 nose 模块测试，但在提交 PR 时测试是部署在 CI 上进行的，这里面也遇到了一些问题，例如代码文件内的 example 的输入和输出必须是真实运行结果，CI 检测时会真实运行 example 的输入，并且所写的输出也要和 CI 运行结果一致。又或者由于最终提交的工具包需要面向各种环境的使用者，所以 CI 上还部署了 Python2 环境下的测试，这就使得代码必须要做兼容，例如 ``print(Str, flush=boolean)`` 这个简单常见的方法是基于 Python3 的，在提交的 CI 检测中就会报错，因此在本地也需要添加对应的环境自行检测，等等。对于单元测试这一部分，通过[基于travis-ci的单元自测（作者：lewzylu）](https://www.jianshu.com/p/8978aceac3b6 \"TOLINKS\")这篇文章亦获得了不少帮助，记录在附录【11】中供参考。\n\n***\n\n# 4. 附录[参考指导]\n\n> - [【1】python多进程共享变量Value使用tips（作者：chenyulancn）<sup>【注】</sup>](https://blog.csdn.net/chenyulancn/article/details/77836593 \"TOLINKS\")\n> - [【2】python中的multiprocessing在map函数中的加锁lock处理方式（作者：qq_27292549）<sup>【注】</sup>](https://blog.csdn.net/qq_27292549/article/details/78929296 \"TOLINKS\")\n> - [【3】使用进程池时遇到的坑...（作者：Kepner）<sup>【注】</sup>](https://blog.csdn.net/weixin_41935140/article/details/81153611 \"TOLINKS\")\n> - [【4】TypeError: can't pickle _thread.lock objects（作者：voyagerlll）<sup>【注】</sup>](https://blog.csdn.net/qq_38765321/article/details/88376031 \"TOLINKS\")\n> - [【5】python中的GIL详解（作者：背着吉他的王小可）<sup>【注】</sup>](https://www.cnblogs.com/SuKiWX/p/8804974.html \"TOLINKS\")\n> - [【6】Python多进程编程（作者：jihite）<sup>【注】</sup>](https://www.cnblogs.com/kaituorensheng/p/4445418.html \"TOLINKS\")\n> - [【7】python学习笔记——multiprocessing 多进程组件-队列Queue（作者：耕毅）<sup>【注】</sup>](https://www.cnblogs.com/gengyi/p/8647950.html \"TOLINKS\")\n> - [【8】python多进程（multiprocessing）中的Queue，Pipe（作者：mjiansun）<sup>【注】</sup>](https://blog.csdn.net/u013066730/article/details/82763115 \"TOLINKS\")\n> - [【9】Python多进程-进程间数据的传递（作者：Sch01aR#）<sup>【注】</sup>](https://www.cnblogs.com/sch01ar/p/8215042.html \"TOLINKS\")\n> - [【10】使用multiprocessing.Process调用start方法后，有较小的几率子进程中run方法未执行（作者：从星空仰望地球）<sup>【注】</sup>](https://segmentfault.com/q/1010000005919174 \"TOLINKS\")\n> - [【11】基于travis-ci的单元自测（作者：lewzylu）<sup>【注】</sup>](https://www.jianshu.com/p/8978aceac3b6 \"TOLINKS\")\n> - [【12】数据特征处理之特征哈希（Feature Hashing）（作者：weixin_33762321）<sup>【注】</sup>](https://blog.csdn.net/weixin_33762321/article/details/88275111 \"TOLINKS\")\n> - [【13】人工智能之机器学习篇——哈希学习learning to hash（作者：人工智能产业研究院）<sup>【注】</sup>](https://baijiahao.baidu.com/s?id=1593454269874725931&wfr=spider&for=pc&isFailFlag=1 \"TOLINKS\")\n> - [【14】特征哈希（Feature Hashing）（作者：Breezedeus）<sup>【注】</sup>](http://breezedeus.github.io/2014/11/20/breezedeus-feature-hashing.html \"TOLINKS\")\n> - [【15】数据特征处理之特征哈希（Feature Hashing）（作者：小木）<sup>【注】</sup>](https://www.datalearner.com/blog/1051537932880901 \"TOLINKS\")\n> - [【16】Feature hashing(特征哈希)（作者：大师鲁）<sup>【注】</sup>](https://blog.csdn.net/laolu1573/article/details/79410187 \"TOLINKS\")\n> - [【17】github----向开源框架提交pr的过程（作者：vim_wj）<sup>【注】</sup>](https://blog.csdn.net/vim_wj/article/details/78300239 \"TOLINKS\")\n","tags":["AI","SKLearn","HashingEncoder","哈希编码","多线程"],"categories":["Python"]},{"title":"Linux云服务器远程任务的那些事儿","url":"/post/note/note-cloud-server/","content":"<!-- more -->\n\n前言：由于本地设备的性能限制，通常一些大型科学计算都会用到云服务器来解决算力问题。不过在使用过程中遇到了不少问题比如内存不够、断连、jupyter notebook 启动失败等，都将记录在本文。\n\n***\n\n# 1. 云服务器的选择\n\n国内比较知名的几个云服务器大概有：腾讯云、阿里云、百度云、华为云，还有比较知名的亚马逊和谷歌，但总觉得有点水土不服。其他的一些云服务器我也没有每个都探索一遍，如果发现有更实惠的选择再更新进来吧。\n\n先说说这四个国内云服务器给我的第一感吧。总体来说，BAT 三家云服务器还是让我感觉到了作为国内互联网三巨头的一股气势，单从我个人感受而言，似乎给我一种“你爱用就用”的态度，当然，文档详尽、自定义性高等各方面条件都是相当优秀的，不过在用户引导这个方面仍然感觉略有不足，其中腾讯云要稍微好一些，阿里次之，当然我不是有意黑百度。最开始我已经准备入坑阿里云，资料、认证都已经完成，但是在选配置的时候遇到一个很尴尬的问题：阿里云的按需计费模式，需要预充 50 元以上，但是对于首次使用的我来说，我其实只是想花个几块钱，就用一个小时尝试一下预期配置的效果，尽管四大云都提供了免费试用，但免费提供的服务器配置并达不到我的要求，所以基于这一点，我 Pass 了阿里云（当然我认为就服务器整体实力而言，阿里云应是最强的）。如果要长期使用并且对维护要求比较高的，我个人还是更推荐阿里云一些，可能质量上而言这几个服务器差别都不会太大，但是阿里云的应用量是远超其他几个云的，从服务案例、维护参考等角度出发，使用阿里云，至少出了问题你能在网上搜到最多的答案。\n\n第二次我搜索云服务器的时候，度娘给我推荐的第一条搜索结果居然是 **华为云**，抱着试试看的心态点进去看了看，惊喜的发现：华为云按需计费是不需要预充金额（其他两家没有尝试）的！这直接导致了我后续选择华为云作为服务器的结果。\n\n说完第一感，再来浅略谈谈这几个云服务器的选择。首先，腾讯云和百度云是没有 **ECS 弹性云服务器** 这么个独立选项的，最后在腾讯找到了 *云服务器 CVM*，在百度找到了 *云服务器 BCC*，看起来跟配置 ECS 差不多，也就权当是不同叫法了。此外，还有一点需要提一下，只有阿里云里面选择配置的时候，是有详细配置参数的，包括 CPU 主频等：\n\n<center>\n\n![阿里云详细配置参数](/post_files/note/note-cloud-server/ali_ecs_detail.png \"TOPICS\")\n\n</center>\n\n而且整体配置选择界面一目了然，各种搭配方案覆盖面也很广，用起来给我个人感觉是最好的。其次是华为云，虽然没有标出主频参数，但至少还能看出 CPU 的规格信息，还能直接搜出来具体的参数：\n\n<center>\n\n![华为云详细配置参数](/post_files/note/note-cloud-server/huawei_ecs_detail.png \"TOPICS\")\n\n</center>\n\n其他两家就差了一些，只告诉我这是几核的，配多大内存，虽然也对 CPU 根据用途做了分类，但终归不直观：\n\n<center>\n\n![其他云详细配置参数](/post_files/note/note-cloud-server/other_ecs_detail.png \"TOPICS\")\n\n</center>\n\n此外，在价格上各家也有差异，由于我自己的需求是约 8 核以上 CPU + 约 32G 以上内存，再加上只是临时跑一下数据，所以选择按需计费，并且都转换成以下标准配置再进行价格对比：\n\n - 地区：广州（华南地区）\n - CPU：8核 2xlarge.4（3.1GHz 高性能计算型）\n - 内存：32G\n - 硬盘：50G 普通硬盘\n - 带宽：5Mbps\n - 系统：Ubuntu\n - 公网：无\n - 时长：1小时\n\n各个云的价格计算器链接：[腾讯云](https://buy.cloud.tencent.com/price/cvm/calculator  \"TOLINKS\")、[百度云](https://cloud.baidu.com/calculator.html#/bcc/price \"TOLINKS\")、[阿里云](https://tco.aliyun.com/tco/ecs/calculator \"TOLINKS\")、[华为云](https://www.huaweicloud.com/pricing.html#/ecs \"TOLINKS\")。\n\n根据这个选择，得到费用表如下（单位：元 / 小时）：\n\n| | 腾讯云 | 百度云 | 阿里云 | 华为云 |\n| :---: | :---: | :---: | :---: | :---: |\n| 无公网 | 6.58 | 3.6721 | 4.7874 | 2.73 |\n| 有公网 | 6.58 | 3.6721 | 4.7874 | 3.05 |\n\n当看到腾讯云价格的时候，我有一点吃惊，但是仔细看了一下，我确定我选择的是 SkyLake 架构 3.2GHz 规格的 CPU，应该是 Xeon E5-2667v4，这款在阿里云的价格平均下来要 7.11 元 / 小时，所以这个价格也还差不多，不过相比标准配置，相同架构，提高 0.1 主频就要贵这么多，还是略不值得。另外，阿里云原本是支持按小时计费，但是这次没找到，因此按照月费用除以 31 天计算。\n\n从价格表也基本可以看出来，华为云的价格优势还是很大的，综合不需要预充值、引导友好等特点，最终入了华为云的坑。\n\n***\n\n# 2. 连接远程服务器\n\n云服务器给的 Linux 系统通常是命令行形式的，也就是所有的操作都使用 Linux 命令完成，当然有些云也提供支持视图模式的选项，但通常伴随着较高的价格。\n\n连接远程服务器有两种方式：（1）用远程连接工具、（2）用系统自带工具\n\n  1. 远程连接工具有很多\n    - Mac 下有 [CyberDuck](https://www.ssh.com/ssh/cyberduck \"TOLINKS\")、[OpenSSH](http://www.openssh.com/portable.html \"TOLINKS\") 等\n    - Win 下有 [XShell](https://www.netsarang.com/zh/xshell/ \"TOLINKS\")、[WinSCP](https://www.ssh.com/ssh/winscp/ \"TOLINKS\") 等\n    - 跨平台的有 [SecureCRT](https://www.vandyke.com/products/securecrt/ \"TOLINKS\")、[PuTTY](https://www.chiark.greenend.org.uk/~sgtatham/putty/ \"TOLINKS\")、[Tectia](https://www.ssh.com/products/tectia-ssh/ \"TOLINKS\") 等\n  2. 系统自带工具不依赖额外的软件，因此更适合仅需要建立连接而不需要集群管理等高级功能的情况\n    - Mac 下的“终端”\n    - Win 下的 CMD 和 PowerShell\n\n由于我只是为了利用云 ECS 的算力和持续运行，因此不需要什么高级功能，选择系统自带工具就足够了。命令格式为：``ssh [用户名]@[服务器地址]``，例如：\n\n```shell\nssh root@127.0.0.1\n```\n\n对于新建的云 ECS，通常都有一个内网 ip 地址，但仅有这个地址的时候是无法远程访问的，还需要购买一个 弹性公网ip，华为云在默认情况下会选择购买，阿里云默认情况下不购买，需要自己区分。以下是华为云在购买 ECS 时弹性公网 IP （红圈所标）的设置部分：\n\n<center>\n\n![购买弹性公网 IP](/post_files/note/note-cloud-server/buy_ip.png \"TOPICS\")\n\n</center>\n\n关于 ECS 的内网 IP 和公网 IP，可以这么粗略理解：公网 IP 是通过远程连接等利用公网访问云、或从云访问公网时必须用到的，内网 IP 通常是集群服务器间，某些云没有联网需求，但需要和其他同属一个网段的云（例如都是华为云，或都是阿里云等）交互数据，那么这些云就可以不购买公网 IP 而仅通过内网 IP 通信。\n\n有了公网 IP 后，就能同过命令行进行远程连接了。如果设置了连接密码，则会在下一条命令中提示输入，注意输入该密码时屏幕上不会显示输入过程，输完回车即可，密码也即在购买服务器时设置登录账户时输入的密码：\n\n<center>\n\n![远程连接密码](/post_files/note/note-cloud-server/set_login_user.png \"TOPICS\")\n\n</center>\n\n在 Mac 下，如果不想每次都手输这个命令，可以右键“终端”，选择“新建远程连接”：\n\n<center>\n\n![新建远程连接](/post_files/note/note-cloud-server/new_ssh_connection.jpg \"TOPICS\")\n\n</center>\n\n然后在弹出窗口内左侧选择服务为 __SSH__，在下面输入连接用户，并输入服务器的地址：\n\n<center>\n\n![添加 SSH 服务](/post_files/note/note-cloud-server/add_ssh.png \"TOPICS\")\n\n</center>\n\n通常连接用户是 root，如果想减少权限以防意外操作，要先以 root 用户登录一次，再在 Linux 系统内新建一个普通用户，下一次即可选择新用户登录。\n\n***\n\n# 3. 配置服务器环境\n\n到这一步，云服务器已是可用状态，通过 SSH 登录后，会新开一个 SSH 终端用于操作云上的 Linux 系统，就和自己手动操作时时一样的。不过需要注意的是，SSH 云服务器的终端只有一个，当然还有一些别的技巧可以达到类似多开终端的效果，会在后面介绍。\n\n既然是要在云上跑训练集，当然 Python 环境、各种科学计算工具包是必不可少的，我个人更推荐直接使用 Anaconda 一次性集成开发环境。\n\n<br/>\n\n## 3.1 下载安装Anaconda\n\n首先在任何一个可以联网的设备上进入 [Anaconda 安装包归档](https://repo.continuum.io/archive/index.html \"TOLINKS\")，并找到自己想要安装的版本，以 Linux 下 64 位集成 Python3 环境的最新版本为例，其安装包名称为：``Anaconda3-2019.03-Linux-x86_64.sh``，在 SSH 终端中输入以下指令：\n\n```shell\n# 下载安装包（默认在用户目录下，通过切换当前目录更改下载路径）：\nwget https://repo.continuum.io/archive/Anaconda3-2019.03-Linux-x86_64.sh\n\n# 安装 Anaconda（默认在用户目录内，通过切换当前目录更改下载路径）：\nbash Anaconda3-5.0.1-Linux-x86_64.sh\n\n# 配置环境变量：\nsource .bashrc\n```\n\n完成后，在 SSH 终端内输入 ``python``，正确进入 Python 编辑环境则表示安装成功。某些情况下，可能需要手动配置环境变量：\n\n```shell\n# 编辑环境变量（所有用户有效）：\nvim /etc/profile\n# 编辑环境变量（仅当前用户有效）：\n# vim .bash_profile\n\n\n# 在文件末尾添加一行（用户名和安装目录请按实际路径填写）：\nexport PATH=/home/root/anaconda3/bin:$PATH\n\n# 保存并使其生效（所有用户有效）：\nsource /etc/profile\n# 保存并使其生效（仅当前用户有效）：\n# source .bash_profile\n```\n\n<br/>\n\n## 3.2 配置Jupyter Notebook\n\n使用命令 ``pip install jupyter`` 安装 Jupyter 到当前环境中，如果需要切换环境，可以先在 Anaconda 中新建环境并切换至新环境后执行命令。\n\n安装好 Jupyter 后，像往常一样输入 ``jupyter notebook`` 启动，结果却发现连不上 Jupyter 服务，这是因为服务器上的 Jupyter 还没有配置外网访问。配置方式如下：\n\n  1. 生成 Jupyter 配置文件：\n\n  ```shell\n  # 非 root 用户：\n  jupyter notebook --generate-config\n  # root 用户：\n  jupyter notebook --generate-config --allow-root\n  ```\n\n  2. 打开ipython，创建一个登录jupyter的密码:\n\n  ```python\n  # 进入 ipython 环境\n  ipython\n\n  # 导入 password 模块\n  from notebook.auth import passwd\n\n  # 修改密码\n  passwd()\n  ```\n\n  然后会要求输入一次密码和一次确认密码，同样，输入过程屏幕上不会有任何显示。正确输入密码后，会输出一个哈希值（省略后半部分），请复制或记录这个值：\n\n  ```shell\n  'sha1:5311cd8b9da9:70dd3321..............'\n  ```\n\n  3. 修改 Jupyter 配置：\n\n  ```shell\n  # 非 root 用户：\n  vi ~/.jupyter/jupyter_notebook_config.py\n  # root 用户：\n  # vi /root/.jupyter/jupyter_notebook_config.py\n  ```\n\n  在打开的配置中添加以下参数：\n\n  ```shell\n  c.NotebookApp.ip='*'\n  c.NotebookApp.password = u'sha1:5311cd8b9da9:70dd3321..............'\n  c.NotebookApp.open_browser = False\n  c.NotebookApp.port = 8888\n  ```\n\n  其中 ``password`` 项输入上一步复制的哈希值，``port`` 项推荐使用默认的 8888 端口，也可以自己定义。\n\n<br/>\n\n## 3.3 配置服务器端口\n\n至此服务器上的环境均已配置就绪，但如果这时候在 SSH 终端使用命令打开 Jupyter Notebook：\n\n```shell\n# 非 root 用户：\njupyter notebook\n# root 用户：\n# jupyter notebook --allow-root\n```\n\n或是在浏览器通过：\n\n```shell\nhttp://公网ip:端口\n# 例：http://127.0.0.1:8888\n```\n\n仍然会出现无法连接的情况，这是因为 ECS 的安全组还没有配置，8888 端口（或自己设置的端口号）还没有开放给公网。设置安全组的过程如下：\n\n  1. 进入云服务器控制台\n  2. 进入安全组设置\n  3. 添加安全组规则\n  4. 选择协议类型为 __自定义 TCP__，输入端口号为 8888（或自定义端口号），授权 IP 设置为 0.0.0.0（即不限访问 IP，不论哪里的网络都可以连接访问云服务器的 Jupyter）\n\n配置完成后，即可通过 SSH 终端或浏览器输入地址的方式进入服务器的 Jupyter Notebook 了！如果仍旧提示无法访问，且云服务器所选的 Linux 系统为 Ubuntu（其他系统没试过），或许是因为防火墙的缘故，通过以下方式关闭：\n\n```shell\nufw disable\n```\n\n接下来尽情享受云服务器带来的快感吧！\n\n<br/>\n\n## 3.4 保持SSH会话\n\n在使用云服务器的过程中，有时去做别的事了过了一段时间后再看 SSH 终端，发现先是没反应，无法输入，再过一会儿就提示连接已断开，这是因为默认情况下 SSH 会话有一个连接时间，一段时间后就会断开会话。如果需要处理一个耗时很长的事件，这可不是什么好事。为此，可以通过以下方式修改时间，以达到 SSH  会话保活的目的：\n\n  1. 登陆远程服务器后在 SSH 终端输入：\n\n  ```shell\n  TMOUT=0\n  ```\n\n  该方式方便、快捷，但缺点是仅对本次登陆有效，退出 SSH 后重新登录则需要再次设置。\n\n  2. 修改ssh配置文件：\n\n  ```shell\n  # 打开配置文件\n  vi /etc/ssh/sshd_config\n\n  # 找到 ClientAliveInterval，该参数指定了服务器端向客户端请求消息的时间间隔。默认是0，不发送\n  # 修改 ClientAliveInterval 的值，单位为秒。如设置 600，即每 10 分钟发送一次请求保持会话。\n  ClientAliveInterval = 600\n\n  # 找到 ClientAliveCountMax，该参数表示允许超时的次数。\n  # 如果发现客户端没有响应，则判断一次超时，请根据实际需要进行设置。比如设置为10，表示允许超时6000 秒 = 100 分钟。\n  ClientAliveCountMax = 10\n  ```\n\n<br/>\n\n## 3.5 本地与云的文件传输\n\n为了使用云服务器跑数据，还需要在云服务器上准备一份数据文件。由于提高网络带宽的价格并不便宜，而且使用云跑数据本身对带宽并没有什么要求，因此我比较推荐在将数据上传至云或从云上下载时，临时提高 ECS 的带宽，并在完成之后重新恢复较低带宽以节省成本。数据文件比较大时，临时提高带宽更划算一些。文件总量比较大时，临时购买流量更划算一些。本地与服务器的文件拷贝指令为：\n\n```shell\n# 本地文件复制到服务器：\nscp [本地文件路径] [服务器登录用户名]@[服务器地址]:[服务器文件存储路径]\n# 例如将本地用户目录下的 test.txt 复制到服务器 root 用户目录下并重命名为 db.txt：\nscp /Users/user/test.txt root@127.0.0.1:/root/db.txt\n# 若需要复制的是文件夹，则将命令 scp 改为 scp -r：\nscp -r /Users/user/test root@127.0.0.1:/root/db\n\n# 服务器复制到本地：\nscp [服务器登录用户名]@[服务器地址]:[服务器文件存储路径] [本地文件路径]\n# 例如将服务器 root 用户目录下的 db.txt复制到本地用户目录下并重命名为 test.txt ：\nscp root@127.0.0.1:/root/db.txt /Users/user/test.txt\n# 若需要复制的是文件夹，则将命令 scp 改为 scp -r：\nscp -r root@127.0.0.1:/root/db /Users/user/test\n```\n\n<br/>\n\n## 3.6 服务器后台运行Jupyter\n\n在选择云服务器训练数据时，除了考虑到算力的问题，当然也有持续运行的问题。尽管通过设置 SSH 的会花时间已经可以使得服务器的 Jupyter 一直在激活状态，但如果是自己的工作电脑，甚至办公本，平时还有大量的工作需要使用电脑，，一直在本地挂着一个 SSH 会话不能关机不能断开，总还是不妥，更何况如果遇到突然断网、突然死机等问题时，会话一关就中断运行，想想就让人抓狂。为此，给服务器的当前任务配置一个后台运行就显得尤为必要了。\n\n通常，在 Linux 中，可以用 ``nohup [command]`` 来保持一项任务不被挂起，使用 ``nohup [command] &`` 来将任务转至后台并保持不被挂起。指令执行后，Linux 会立即将任务转至后台运行，且返回输出一个进程号：PID，当我们需要手动停止该进程时，可以通过 ``kill -TRM [PID]`` 来终止该进程。同时，该进程的所有输出均会默认存储至当前目录下的 ``nohup.out`` 文件中，使用命令 ``tail -f nohup.out`` 来实时查看动态输出，或者也可以使用：``nohup [command] > out.log &`` 命令将输出重定向至自定义的文件（本例为out.log）并查看。\n\n这对于 Jupyter 任务来说也是一样的，我们可以通过将 Jupyter 任务转至后台持续运行来释放本地电脑的工作压力：\n\n```shell\n# 非 root 用户：\nnohup jupyter notebook &\n# root 用户：\n# nohup jupyter notebook --allow-root &\n```\n\n这样，当我们在 Jupyter 开始一项耗时任务后，即可直接断开 SSH 会话。<font color=#EB6D39>注意：在本地需要离线时，不能终止 Jupyter 的进程，而应该直接断开 SSH 连接。</font>\n\n另外还有一点，由于 Jupyter 本身的局限性，当一个正在运行任务的 Jupyter 页面被关闭（而没有关闭服务）后，再次打开，只能保留前一次的结果，而不能恢复任务运行过程，因此，使用 nohup 命令转至后台的 Jupyter 任务应当是具有完整结果的，而不能再带有需要交互的部分，例如：\n\n  1. 将某个数据集预先确定好的特征进行哈希编码，并将编码完的数据重新输出存储。\n  2. 将某个数据集预先确定好的特征进行哈希编码，并询问我是否存储，根据选择完成相应任务。\n\n假设在任务开始后，本地立即断开 SSH 连接，并等待任务完成后再重新连接。那么：  \n任务 1 是合理的，因为任务过程不需要交互，重新连接后，可以在服务器的本地找到输出的已完成哈希编码的数据集。  \n任务 2 是不合理的，因为任务执行完编码后，不能完成交互因此任务将直接运行结束，重新连接后相当于白费力气。\n\n另外，除了基本的后台防挂起 nohup 外，还有一些工具也可以用来保持任务现场并恢复，例如：screen 和 tmux，可参考附录【7】、【8】，但终究因为 Jupyter 本身的原因，还是不太适合这种长时间可恢复的后台运行模式，我的建议是通过 Python 脚本进行长时间的后台操作，并尽量减少交互部分，及时将后续可能要用的数据保存成文件，而在 Jupyter 上仅作为一些可视化或测试、调整等的工具使用。\n\n<br/>\n\n## 3.7 调整服务器的虚拟内存\n\n终于可以随心所欲折腾服务器的算力了，但在运行大量数据集的时候，很有可能报这个错：``Memory Error``，这个错在 Python 里面也不算罕见了，一般表示瞬间内存占用超过了可用内存总和导致代码崩了，但同样的代码，在本地运行成功，在配置更高的服务器却反而失败？后来通过 ``free -m`` 命令查看内存时发现原因其实很简单，就是因为 ECS 给我们的系统太纯净、太初始化了，以至于连交换内存都没有，所以即便是选购了 32G 的服务器，当进行一些编码、训练等大数据量任务时，瞬时内存占用会一下飙升，导致内存不足。好在现在的 ECS 大多都使用了固态硬盘，即便默认非固态硬盘的，升级成本也比较低，因此可以拿出一部分硬盘作为交换内存使用（参考附录【9】）。\n\n  1. 创建swap文件：\n\n  ```shell\n  # 在 /usr 目录下创建交换内存文件\n  cd /usr\n  mkdir swap\n  cd swap\n\n  # 查看目前总用量\n  ll\n\n  # 创建一个循环，每次复制 1024 字节，共复制 1024000 次（10G）并输出为 swapfile1 文件\n  dd if=/dev/zero of=/usr/swap/swapfile1 bs=1024 count=1024000\n  ```\n\n  最后的 ``dd`` 命令中，if 表示 infile，of 表示 outfile，bs=1024 表示写入的每个块的大小为 1024B，即 1KB。\n  2. 查看刚才创建的 swap 文件大小即路径：\n\n  ```shell\n  du -sh /usr/swap/swapfile1\n  ```\n\n  3. 将目标文件设置为 swap 分区文件：\n\n  ```shell\n  mkswap /usr/swap/swapfile1\n  ```\n\n  4. 激活 swap，立即启用交换分区文件：\n\n  ```shell\n  swapon /usr/swap/swapfile1\n  ```\n\n  至此交换内存已经设置好了，并已激活可用，但仅限本次开机可用，想要每次开机都自动加载这个交换内存，则需要修改 ``/etc/fstab`` 文件\n\n  5. 编辑文件 ``/etc/fstab`` 中的 ``swap`` 行：\n\n  ```shell\n  vi /etc/fstab\n  ```\n\n  在 ``/etc/fstab`` 编辑状态下（UUID 省略后半部分），添加下面这段的最后一行：\n\n  ```shell\n  /dev/mapper/vg_localhost-lv_root   /         ext4    defaults        1 1\n  UUID=cef520a0-df77-4........       /boot     ext4    defaults        1 2\n  # /dev/mapper/vg_localhost-lv_swap   swap      swap    defaults        0 0\n  # 下面这行是关键：\n  /usr/swap/swapfile1                swap      swap    defaults        0 0\n  ```\n\n保存并重启系统生效。\n\n<br/>\n\n## 3.8 验证服务器\n\n重启系统后，再次输入 ``free -m`` 命令，发现多了一个 ``swap`` 内存，大小为 10G，设置成功，服务器的基本配置已全部完成！\n\n***\n\n# 4. 附录[参考指导]\n\n> - [【1】linux下安装Anaconda（作者：猪啊美）<sup>【注】</sup>](https://www.cnblogs.com/mypath/articles/7877493.html \"TOLINKS\")\n> - [【2】阿里云连接jupyter notebook的步骤（作者：半监督）<sup>【注】</sup>](https://blog.csdn.net/m0_37748303/article/details/78764625 \"TOLINKS\")\n> - [【3】安全组应用案例六：允许公网远程连接实例（作者：阿里云）<sup>【注】</sup>](https://help.aliyun.com/document_detail/25475.html?spm=a2c4e.11153940.blogcont98527.62.4d126b80ucvIpF#h2-url-6 \"TOLINKS\")\n> - [【4】怎样长时间保持SSH会话连接不断开？（作者：华为云）<sup>【注】</sup>](https://support.huaweicloud.com/trouble-ecs/zh-cn_topic_0138293301.html \"TOLINKS\")\n> - [【5】mac 本地文件与服务器Linux文件之间的相互传输（作者：binary101010）<sup>【注】</sup>](https://blog.csdn.net/ludongdong/article/details/78524653 \"TOLINKS\")\n> - [【6】如何不挂起后台，继续运行jupyter（作者：aoaocool）<sup>【注】</sup>](https://www.jianshu.com/p/6d1a48cc6ce2 \"TOLINKS\")\n> - [【7】云服务器 ECS Linux SSH 客户端断开后保持进程继续运行配置方法（作者：阿里云）<sup>【注】</sup>](https://help.aliyun.com/knowledge_detail/42523.html \"TOLINKS\")\n> - [【8】使用tmux保持远程ssh连接（作者：步晓德）<sup>【注】</sup>](https://www.jianshu.com/p/300333a3f2ba \"TOLINKS\")\n> - [【9】Linux 修改swap虚拟内存大小（作者：L.L.K）<sup>【注】</sup>](https://www.cnblogs.com/llkmst/p/4684097.html \"TOLINKS\")\n","tags":["Server","Linux","Cloud","云服务器","远程连接"],"categories":["Note"]},{"title":"Python中的下划线与函数的花式调用","url":"/post/python/python-underline/","content":"<!-- more -->\n\n前言：今天在看一个 TF 程序的时候，发现很多例程都喜欢把 main 函数定义为：main(\\_)，而不是 main(argv=None)，当然对于一个 Python 程序而言，一切皆为对象，用下划线当做参数变量并没什么好奇怪的（毕竟连 ``...`` 都是一个 Ellipsis 对象，甚至可以修改其默认值），但如此广泛应用，应当是有一定原因的，找了找论坛和 SOF，简略看了一下 TF 中 run() 函数的源码（主要是复杂的看不懂），算是初步了解了 Python 中下划线的应用，而且还无意间看到了一篇关于 Python 函数“花式”调用的文章，受益匪浅。\n\n***\n\n# 1. 来源\n\n最开始有这个疑问是因为今天 ~~突发奇想心血来潮自我膨胀差点上天的~~ 看了看 TinyMind 里面的云平台，进去还送了 2 点平台点数，本着不用白不用的心态，想想亚马逊和阿里比较昂贵的价格，准备试试看这里效果怎么样，然后点开官方文档就看到了一个巨经典的例程：mnist 手写识别，虽然写是写过，不过自己是基于 C++ 写的，Python 的代码还是可以好好看看，这一看就发现了简介中的现象，作为一个码（fei）农（zhai），遇到问题当然是问。。哦对了，千万不要再汤很凉上搜索“\\_”这个关键词。\n\n***\n\n# 2. Python基础语法中的下划线\n\n如果写过 Python，其他下划线不多说，至少 \\__name__ 和 \\__init__ 是见过的，以前只想过这是语法规定以及一点都不优雅，这回是好好整理了一把，先列出 Python 中可能存在的 5 种下划线的情况：\n\n 1. 单前下划线：\\_sample\n 2. 单后下划线：sample_\n 3. 双前下划线：\\__sample\n 4. 前后双下划线：\\__sample__\n 5. 单独下划线：_\n\n<br/>\n\n## 2.1 单前下划线：\\_sample\n\n单前下划线的写法非常“约定俗成”——纯粹只是一种习惯和写法的延续，用于表示该变量是个 函数/类 的内部变量，写不写完全看个人习惯。但在一种特殊情况下，单前下划线是有特殊作用的，下面用代码说明。\n首先定义一个类 ClassA，重写构造方法并定义两个变量：\n\n```python\nclass ClassA:\n    def __init__(self):\n        self.normal = \"Normal\"\n        self._pre = \"PreUnderline\"\n\na = ClassA()\nprint(a.normal + \" | \" + a._pre)\n\n\n[Out]:\nNormal | PreUnderline\n```\n\n运行输出也很正常，这说明单前下划线并不影响一个变量被访问，这时我们考虑一种情况，假设在一个 module：im_module.py 中有两个函数：\n\n```python\n# im_module.py\n\ndef normal_func():\n    return \"Normal\"\n\ndef _pre_func():\n    return \"PreUnderline\"\n```\n\n接着在别的地方把这个 module 导入并调用其函数：\n\n```python\nfrom im_module import *\n\nprint(normal_func())\nprint(_pre_func())\n\n\n[Out]:\nNormal\nNameError: \"name '_pre_func' is not defined\"\n```\n\n这是一种虽然不好但很常见的导入方式，但结果呢？是的，在使用通配符 * 导入的时候，解释器会过滤掉单前下划线的成员。 **但！** 前文也说了，通配符导入并不是良好的编码习惯，这种导入方式非常容易导入 无关/冲突/未知/... 的部分，因此通常还是应该手动选择需要导入的部分，如果需要导入全体，则应该使用如下方式：\n\n```python\nimport im_module\n\nprint(normal_func())\nprint(_pre_func())\n\n\n[Out]:\nNormal\nPreUnderline\n```\n\n这次的输出结果一切正常。<font color=#EB6D39>也就是说，除非使用通配符 * 的方式进行导入，会导致单前下划线修饰的成员被忽略，否则与不带下划线的成员没有区别。</font>除了这种特殊情况之外，就像 Java 中喜欢用 m 前缀来表示成员变量一样，这仅仅只是一种提醒功能，具体好不好、对不对、有没有用呢，那就仁者见仁了，一般是根据团队项目最初定的标准来决定，个人项目就纯粹看习惯了。顺便提一句，在 Google 官方的 [Java Style Guide](https://google.github.io/styleguide/javaguide.html \"TOLINKS\") 中并不推荐这种写法，当然这也跟如今 IDE 的智能有关，如果使用的编辑器没有代码高亮或者提示功能，还是建议加上吧，这篇文档的中译版可参考附录【2】。\n\n<br/>\n\n## 2.2 单后下划线：sample_\n\n单后下划线相对而言可能使用场景还比较多，它的主要功能是“规避”关键字冲突。Python 中有许多关键字，例如 ``class``，``sum``，``len``，``type`` 等，但在许多时候，我们自己定义的变量、方法等，很难找到更适合的表示单词，或是改变写法又太麻烦/不直观，例如学校、师生类中的“班级属性 class”，商品的“种类 type”，这时候如果我们不想费时间写出像 class_num 或者 type_name 这样的标识符，或许可以直接用 class_ 和 type_ 代替，<font color=#ED6B39>这样既避免了和关键字的冲突，又能很直观地表示其含义。</font>\n\n<br/>\n\n## 2.3 双前下划线：\\__sample\n\n这个就有点意思了，用双前下划线标识的属性，解释器会重写名称，以避免子类中的命名冲突，其效果对属性和函数是一样的，以下代码仅用属性举例：\n\n```python\nclass ClassA:\n    def __init__(self):\n        self.normal = \"Normal\"\n        self._pre = \"PreUnderline\"\n        self.__double_pre = \"DoublePreUnderline\"\n\n# 用 dir() 函数查看 ClassA 对象的属性\na = ClassA()\ndir(a)\n\n\n[Out]:\n['_ClassA__double_pre', '__class__', '__delattr__',\n'__dict__', '__dir__', '__doc__', '__eq__', '__format__',\n'__ge__', '__getattribute__', '__gt__', '__hash__',\n'__init__', '__init_subclass__', '__le__', '__lt__',\n'__module__', '__ne__', '__new__', '__reduce__',\n'__reduce_ex__', '__repr__', '__setattr__', '__sizeof__',\n'__str__', '__subclasshook__', '__weakref__', '_pre', 'normal']\n```\n\n在输出的结尾，\\_pre 和 normal 都在，唯独不见了 \\__double_pre？其实并不是没有，而是解释器自动改变了其内部形式，就在输出的第一个：\\_ClassA__double_pre，解释器自动为这个属性增加了一个当前所属类的类名标识 \\_ClassA，<font color=#EB6D39>这也意味着，即使在 ClassA 所在的当前 module 内，如果需要调用这个属性，用 ``ClassA().__double_pre`` 也会报错 ``AttributeError: \"'ClassA' object has no attribute '__double_pre'\"`` ，而应该使用 ``ClassA()._ClassA__double_pre`` 的方式调用。</font>为什么要这样，又有什么用呢，用下面的代码就可以说明：\n\n```python\nclass ClassB(ClassA):\n    def __init__(self):\n        # 继承自 ClassA\n        super(ClassB, self).__init__()\n        # 也可以直接覆写\n        # super().__init__()\n        self.normal = \"Override\"\n        self._pre = \"Override\"\n        self.__double_pre = \"Override\"\n\n\n[Out]:\n['_ClassA__double_pre', '_ClassB__double_pre',\n'__class__', '__delattr__', '__dict__', '__dir__',\n'__doc__', '__eq__', '__format__', '__ge__',\n'__getattribute__', '__gt__', '__hash__', '__init__',\n'__init_subclass__', '__le__', '__lt__', '__module__',\n'__ne__', '__new__', '__reduce__', '__reduce_ex__',\n'__repr__', '__setattr__', '__sizeof__', '__str__',\n'__subclasshook__', '__weakref__', '_pre', 'normal']\n```\n\n不论是继承自 ClassA 也好，还是直接覆写也好，其最终的输出中都既有 \\_ClassA__double_pre，也有 \\_ClassB__double_pre，同样，也是因为解释器自动给 \\__double_pre 增加了一个当前所属类的类名标识 \\_ClassB，因此父类 ClassA 中的 \\__double_pre 并不会被重写：\n\n```python\nprint(b.normal)\nprint(b._pre)\nprint(b._ClassA__double_pre)\nprint(b._ClassB__double_pre)\n\n\n[Out]:\nOverride\nOverride\nDoublePreUnderline\nOverride\n```\n\n可以看到，被前双下划线标识的属性是不会被重写的\n\n此外，还有一个特别有意思的应用：\n\n```python\n_ClassC__double_pre = \"DoublePreinClassC\"\n\nclass ClassC:\n    def call():\n        return __double_pre\n\nClassC.call()\n\n\n[Out]:\nDoublePreinClassC\n```\n\n乍一看在 ClassC 的 call() 方法中返回的 \\__double_pre 根本没有定义啊，应该报 NameError 错误才对，实际上，因为在上面手动定义的 \\_ClassC__double_pre 具有 \\_ClassC 前缀，因此程序调用 call 方法的时候，解释器会自动给 \\__double_pre 加上 \\_ClassC 前缀，而又恰好存在这么个变量，因此可以正常输出。<font color= EB6D39>这也说明，如果某个类内有属性/方法是以双前下划线修饰，则解释器会自动给双前下划线的成员添加其所属类的前缀，这种转换适用于整个类内所有以双前下划线开头的任何名称，而不论它是一个变量还是方法还是其他。</font>\n\n<br/>\n\n## 2.4 前后双下划线：\\__sample__\n\n这个就好解释多了，也常见的多了，Python 保留了许多用前后双下划线修饰的属性/方法，像 \\__name__ 或是 \\__init__()，当然只要我们愿意，并且命名不冲突，我们也可以自行定义前后双下划线修饰的成员，这本身是没有错的：\n\n```python\n__test__ = \"Test\"\n__test__\n\n\n[Out]:\nTest\n```\n\n但不太推荐这么做，主要原因是 Python 官方保留了这么命名的做法，因此可能现在没有发生冲突的一些命名，在未来 Python 经过更新后由于官方加入了对应的保留成员而导致冲突，<font color=#ED6B39>因此，干脆就不要使用自定的前后双下划线成员，并且记住这样修饰的都是 Python 保留命名就好了。</font>不过我觉得一般也没什么人愿意如此麻烦的加上四个下划线吧，说不定 Python 当年就是考虑到这个才这么设计呢（逃）。\n\n<br/>\n\n## 2.5 单下划线：_\n\n说实话我第一次见到这个写法的时候还以为是源码写错了，不过其实通俗的讲，既然 Python 一切皆为对象，当然也就可以把 _ 当做很普通的成员使用，事实也确实如此：\n\n```python\n_ = \"Underline\"\nprint(_)\n_ = 1 + 2\nprint(_)\n\ndef _(a, b):\n    print(a + b)\n\nprint(_(5, 6))\nprint(_(\"a\", \"b\"))\n\n[Out]:\nUnderline\n3\n11\nab\n```\n\n玩上瘾了，我相信如果你在团队项目里面大量使用 _ 作为变量/方法名，明年就该有坟头草了。\n正经的解释：如果某个变量、方法、参数没有实际用途，可以使用 _ 来代替，以表明这是个可以忽略的部分。说起来好像没什么用，其实在真正的源码中，这个用法可以大幅提高阅读感，例如：\n\n```python\nuser = ('ZhangSan', '20岁', 'Male', '80分', '野鸡大学', '计算机专业', '物联网工程')\nname, _, _, _, college, _, _ = user\n\nprint(name)\nprint(college)\nprint(_)\n\n\n[Out]:\nZhangSan\n野鸡大学\n物联网工程\n```\n\n这么写出来的代码，阅读时可以非常直观地看出来，这些消息里面我关注的只有 name 和 college，其中 _ 被多次赋值，因此输出的值是最后一次赋值“物联网工程”。\n另外，_ 还是大多数 Python REPL 中的一个特殊变量，它不仅可以当做普通的变量、方法正常调用，还会自动保存你最后一次计算的结果，例如：\n\n```python\nprint(_)\n[Out]:\n''\n\n\n1 + 2\n[Out]:\n3\n\n\nprint(_)\n[Out]:\n3\n\n\n\"ABCD\"\n[Out]:\nABCD\n\n\nprint(_)\n[Out]:\nABCD\n\n\nlist()\n[Out]:\n[]\n\n\n_.append(1)\n_.append(2)\n_.append(3)\nprint(_)\n[Out]:\n[1, 2, 3]\n```\n\n但是 **注意：如果你已经手动给 _ 赋值，则它在当前上下文范围内不会再自动保存你的计算结果**\n\n```python\na = 1 + 2\na\n[Out]:\n3\n\n\nprint(_)\n[Out]:\n3\n\n_ = \"A\"\na += 5\nprint(a)\nprint(_)\n[Out]:\n8\nA\n```\n\n<font color=#ED6B39>也就是说，_ 在未被手动赋值前，当前上下文内每次计算的记过都会赋值给 _，直到你手动给 _ 赋值使其称为一个常规成员。</font>\n\n<br/>\n\n## 2.6 \\__name__的应用\n\n\\__name__ 可以说是 Python 中的一大常客了，最常见的形式就是：\n\n```python\nif __name__ == '__main__':\n    ...\n```\n\n通常这个语句会作为一个程序的入口，但为什么会有这么奇怪的一个条件语句呢？用代码一下就能解释明白。首先创建一个 module：rate.py，内容如下：\n\n```python\nLEARNING_RATE = 1.005\n\ndef call_rate():\n    print(\"Rate is :\", LEARN_RATE)\n\nprint(\"Value of __name__ :\", __name__)\nif __name__ == '__main__':\n    call_rate()\n\n\n# 运行结果：\n[Out]:\nValue of __name__ : __main__\nRate is : 1.005\n```\n\n可以看到此时 \\__name__ 的值就是 “\\__main__”，如果再新建一个 module：test.py，内容如下：\n\n```python\nimport rate\n\nprint(rate.LEARNING_RATE * 2)\n\n\n# 运行结果\n[Out]:\nValue of __name__ : rate\n2.01\n```\n\n可以看到，rate.py 中的 \\__name__ 变成了 “rate”，因此条件语句没有执行，<font color=#ED6B39>因此，\\__name__ 可以用来判断该 module 是直接执行的还是被其他 module 引入后执行的。</font>\n\n<br/>\n\n## 2.7 TensorFlow中的run()方法\n\n先来看看 TF 中 run() 方法的源码：\n\n<center>\n\n![TF 中 run() 方法源码](/post_files/python/python-underline/code_of_run_in_tf.png \"TOPICS\")\n\n</center>\n\n从图中可以看出来，当传的参数 main 为空时，跳过执行，如果不为空，则调用 main 函数，因此想要调用 tf.app.run() 方法，则需要在模型程序中定义 main(argv) 函数，并且接收参数 args，如果模型不需要使用这些参数，就可以用 main(\\_) 来表示，也就回答了最开始的问题。\n\n***\n\n# 3. Python中方法的花式调用\n\n首先，几乎在所有的程序中，调用函数/方法的步骤无非就两个：①定义，②调用，在 Python 中也是如此，使用关键字 def 来声明一个方法：\n\n```python\ndef func():\n    ...\n\nfunc()\n```\n\n似乎我们所熟知的函数/方法调用也就只有这一种，但 Python 还有一种很好玩的调用方式：根据名称调用：\n\n```python\ndef func_a():\n    print(\"Method function A\")\n\n\ndef func_b():\n    print(\"Method function B\")\n\n\ndef func_c():\n    print(\"Method function C\")\n\n\neval(\"func_a\")()\nlocals()[\"func_b\"]()\nglobals()[\"func_c\"]()\n\n\n\n[Out]:\nMethod function A\nMethod function B\nMethod function C\n```\n\neval() 函数可以直接转换成函数调用，而 locals() 和 globals() 可以通过字典的方式访问局部、全局变量。之所以 Python 支持这种形式的调用，是因为 Python 使用 **<font color=#ED6B39>名字空间</font>** 来记录变量的变化。每个函数都有自已的名字空间，称为局部名字空间，其记录了函数的变量，包括函数的参数和局部定义的变量；每个 module 也都有自已的名字空间，称为全局名字空间，其记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量；还有一个内置名字空间，任何 module 均可访问，其存放了内置的函数和异常。名字空间是一个字典，键 key 就是变量名，值 value 就是变量的值，名字空间就像 Python 的普通字典一样可以进行访问。当某行代码要使用变量 x 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序：\n\n 1. 局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 x，Python 将使用这个变量，然后停止搜索。\n 2. 全局名字空间 - 特指当前的模块。如果模块定义了一个名为 x 的变量，函数或类，Python 将使用这个变量然后停止搜索。\n 3. 内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python 将假设 x 是内置函数或变量。\n\n如果Python在这些名字空间找不到 x，就会放弃查找并引发一个 NameError 的异常，同时传递 “There is no variable named 'x'” 错误信息。\n\n在 Java 或 C/C++ 等编译语言中，编译器会将代码编译为二进制文件执行，在程序内部，是没有“变量名”这个概念的，所以我们的代码只能通过变量名取值，而不能通过具体的变量获得变量名（当然可以用 Map 的方式手动保存，但这本身脱离了原意），但在 Java 中，有一种很类似的样例就是 [ObjectAnimator](/post/android-objectanimator-basic \"TOLINKS\") 中的属性名 Attr，调用该方法会通过设置的属性名去获取对应控件下的 setAttr() 方法，和此处的命名空间有着异曲同工之妙。\n\n***\n\n# 4. 附录[参考指导]\n\n> - [【1】Google Java Style Guild（作者：Google）<sup>【注】</sup>](https://google.github.io/styleguide/javaguide.html \"TOLINKS\")\n> - [【2】Google Java Style Guide中文版（作者：Harrytsz）<sup>【注】</sup>](https://blog.csdn.net/harrytsz/article/details/63328086 \"TOLINKS\")\n> - [【3】18式优雅你的Python（作者：梁云）<sup>【注】</sup>](https://www.cnblogs.com/amou/p/9530932.html \"TOLINKS\")\n","tags":["Python","Underline","下划线","同名函数"],"categories":["Python"]},{"title":"Android动画——属性动画：ObjectAnimator","url":"/post/android/android-objectanimator-basic/","content":"<!-- more -->\n\n前言：之前的项目有一个功能需要对“画布”进行动画变换而不改变 View 本身，在上一篇[Android属性——Matrix矩阵](/post/Android/android-matrix-basic/ \"TOLINKS\")中，已经用 **Matrix** 实现了对画布的变换，但只能实现跳跃式变换，还需要加上平缓的动画过渡效果，因此搭配使用 **ObjectAnimator** 实现功能并记录于本文。\n\n***\n\n# 1. 构思\n在项目中，有一个功能是希望能在介绍页对 App 的功能做一些引导指示，一开始构思这个效果的时候，最简单的也是最容易想到的方式就是预设固定的图片，在需要时设置显示，不需要提示时隐藏：\n\n```javascript\n//需要提示时\nimageView.setVisibility(View.VISIBLE);\n...\n//不需要提示时\nimageView.setVisibility(View.INVISIBLE);\n```\n\n但是这种方式太过简单和死板界面也相当不优雅，并且也只能完成一些非常非常简单的视图展示效果，在需要动态展示一些过程的时候就很难实现预期效果了。于是想到了 **ValueAnimator** ——数值属性动画这个神奇的东西，ValueAnimator 是一个非常强大的类。但是为什么最后还是没有用 ValueAnimator 呢？接下来本篇就会对 ValueAnimator 做一个简单的介绍，并解释其与 ObjectAnimator 的联系和异同。\n\n***\n\n# 2. ValueAnimator与ObjectAnimator\n\n提到这两个东西，就必须首先说明：**ValueAnimator** 是 **ObjectAnimator** 它爹（ObjectAnimator：？？？），ObjectAnimator 是继承自 ValueAnimator 的，因此 ObjectAnimator 具有 ValueAnimator 的全部特性，并重写了 ValueAnimator 中的部分方法，定性地总结一句，<font color=#EB6D39>ObjectAnimator 具有更高的灵活性和便捷性</font>。\n（这两个类名字可还真长啊）\n\n<br/>\n\n## 2.1 ValueAnimator的基本介绍\n\n虎父无犬子，ObjectAnimator 既然能被广泛使用，其父类 ValueAnimator 作为一个强大的属性动画类当然要放在前面先说说了。ValueAnimator 提供了一系列改变属性的方式，在提供属性动画时，可以选择不同的数值增长方式控制属性值，线性增长、曲线增长等等，例如在缩放显示图像的过程中，如果选择线性增长，图片将匀速缩放，如果选择曲线增长，图片可以以加速或减速的方式缩放，并且还支持在动画执行过程中获取其值的分布和执行的过程监控等，**但是！** ValueAnimator 本身并不会改变控件的属性，也不会直接与动画本身进行联系和控制，常用的创建一个 ValueAnimator 对象的方法是：``ValueAnimator valueAnimator = ValueAnimator.ofXXX(xxx...);``，其中 ``XXX`` 表示不同类型的数据（int、float、args等），``xxx...`` 表示变化范围，是一个可变长参数，例如给定 ``ofInt(1, 0);``，表示从1变为0，给定 ``ofInt(1, 0, 1);`` 表示从1变为0再变为1。\n\nValueAnimator 实现动画的原理在于使用了：<font color=#EB6D39>Interpolator（插值器）</font> 和  <font color=#EB6D39>TypeEvaluator（数值计算器）</font>，通俗的说，Interpolator 可以根据给出的值来设定数值的变化方式，例如上文中提到的线性和曲线方式。其他 Interpolator 可以参考下面引用博文内的配图（特别简单明了，大赞！）。\n\n在缩放执行的过程中，动画效果主要就是靠这两个工具来实现的。当我们给出需要缩放的目标大小是从原大小（缩放率为1）放大到2倍（缩放率为2），缩放时间为1秒，并选择线性增长的 Interpolator，那么 TypeEvaluator 就会生成一个时间长度为1秒，且缩放值从1到2的一系列数值，我们无法列举出每一个产生的数值，但是可以知道，当动画刚刚开始第0秒时，TypeEvaluator 计算的缩放率是1；当动画结束的第1秒时，缩放率是2；而在中间第0.5秒时，缩放率是1.5……也就是说，TypeEvaluator 会根据选定的 Interpolator 替我们计算好了某个时刻应该变化的具体值是多少，然后通过快速、连续地设定这个值来产生动画的效果。下面是改变一个 ImageView 的透明度的 Demo，布局很简单，一个 ImageView 一个 Button：\n\n<center>\n\n![初始状态](/post_files/android/android-objectanimator-basic/image_initial.png \"TOPICS\")\n\n</center>\n\n点击 Button 改变透明度：\n\n```java\n//初始化控件\nImageView ivImage = findViewById(R.id.ivImage);\n\n\n//创建ValueAnimator对象，并给定透明度变化为从完全显示到完全消失\nValueAnimator valueAnimator = ValueAnimator.ofInt(1, 0);\n//动画时间为1秒\nvalueAnimator.setDuration(1000);\n//设置插值方式为线性插值，即透明度匀速变化\nvalueAnimator.setInterpolator(new LinearInterpolator() );\n//开始动画\nvalueAnimator.start();\n\n\n//监听属性数值的改变并手动做事件处理\nvalueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {\n    @Override\n    public void onAnimationUpdate(ValueAnimator animation) {\n        //获取到改变的值\n        int updateValue = animation.getAnimatedValue();\n        //改变TextView的透明度\n        ivImage.setAlpha(updateValue);\n    }\n});\n```\n\n看一下效果：\n\n<center>\n\n![点击改变透明度](/post_files/android/android-objectanimator-basic/click_change_alpha.gif \"TOPICS\")\n\n</center>\n\n当然这里还要提到一个工具： <font color=#EB6D39>AnimatorUpdateListener</font> ，上文已经提到，ValueAnimator 会自动替我们计算好需要改变的数值，但是对于 Android 系统而言，它怎么知道数值到达几了呢？又该如何做对应的事件反馈呢？这就用到了 AnimatorUpdateListener 了，顾名思义这是一个 Listener，监听的就是 ValueAnimator 中 TypeEvaluator 产生的值，在 ValueAnimator 中，所有产生的值会根据给定的范围划分成比例的形式，例如由原大小缩放到2倍的动画中，缩放率为1.5时的比例就是0.5，AnimatorUpdateListener 可以监听这个数 TypeValue 的变化，我们可以自行给 TypeValue 变化的值做一些事件处理，例如放大到一半的时候顺便改变一下透明度，等等，然而从上面的步骤来看，其实它本身完全没有接触任何一个控件，而是产生一系列的数值，再由我们人为地给控件指定对应的值来实现动画效果。以上就是关于 ValueAnimator 的一些简单介绍了，其实逻辑非常简单，通俗地理解，就是把我们人为 ``while(true)`` 的步骤交给Android提供的自带工具来处理。\n\n总结一下 ValueAnimator 实现动画的步骤：\n\n 1. **指定需要动画变换的值的范围**\n 2. **指定动画变换的时间**\n 3. **通过 ValueAnimator 对象指定动画的插值器变换方式 Interpolator**\n 4. **通过 ValueAnimator 对象的 TypeEvaluator 产生值**\n 5. **在监听器 AnimatorUpdateListener 中监听数值的变化并指定事件处理**\n\n<br/>\n\n# 2.2 ObjectAnimator的基本介绍\n\n上面介绍完了 ValueAnimator，接下来就要说说其子类 ObjectAnimator 了。既然是子类，当然 ValueAnimator 具有的一切特性 ObjectAnimator 也具有，并且通过重写父类的部分方法，从而提供了更高的易用性。举个例子，在 ValueAnimator 中，由于本身并不接触控件，因此对动画的实现始终需要我们手动去做一些处理，但是 ObjectAnimator 就大大提高了普遍情况下的简易性——它可以直接控制控件的常规属性，例如透明度、 缩放、旋转等等，对于不同的控件，都可以直接指定控件拥有的属性，用同样的方式创建一个 ObjectAnimator 对象：\n``ObjectAnimator objectAnimator = ObjectAnimator.ofXXX(Object target, String propertyName, xxx...);``\n 1. **target**：需要应用变化的控件\n 2. **propertyName**：需要改变的控件具体要改变的属性名。\n 3. **xxx...**：需要改变的范围，是一个可变长参数，与上文中 ValueAnimator 的一样，就不重述了。\n\n这里主要讲一下 **propertyName** 的一个注意事项。在源码中，propertyName 最后会被``setPropertyName(String propertyName);``方法调用，对于这个方法源码的解释有这么一段：\n\n<center>\n\n![setPropertyName 方法源码](/post_files/android/android-objectanimator-basic/code_of_setpropertyname.png \"TOPICS\")\n\n</center>\n\n意思就是，根据传入的 String 属性名，通过把首字母强制大写，并在前面加上 \"set\"，然后反射寻找对应的设置方法。例如要改变 ImageView 的透明度，我们可以直接用 ``tvText.setAlpha(alpha);`` 来实现，但在 ObjectAnimator 的参数中，属性名要写 ``\"alpha\"`` 或 ``\"Alpha\"``，如果我们写成 ``\"setAlpha\"``，最后查找的方法就变成了 ``setSetAlpha();``，这显然是不对的。\n\n用 ObjectAnimator 同样实现一下设置 ImageView 的透明度1秒内逐渐消失的动画：\n\n```java\nObjectAnimator objectAnimator = ObjectAnimator.ofInt(ivImage, \"alpha\", 1, 0).setDuration(1000)；\nobjectAnimator.start();\n```\n\n可以很明显地看到，这个方法指定了控件—— ``ivImage``，以及变化数值作用的属性的 setter 方法—— ``setAlpha();``，只需要一步，就能实现与上文 ValueAnimator 一样的效果，是不是方便的多了？\n\n> 关于属性动画 ValueAnimator 与 ObjectAnimator 及其他更全面的介绍可以参考附录【2】\n\n***\n\n# 3. ObjectAnimator配合Matrix\n\n了解完 ObjectAnimator 的基本内容后，思考一个问题：**怎么用 ObjectAnimator 实现复杂的变换？**\n在上文讨论的几个属性：透明度 Alpha、缩放 Scale、旋转 Rotate 等，几乎所有的 View 控件都具有直接设置的 setter 方法，可以很方便的直接套用 ObjectAnimator 来实现，但是如果是比较复杂的变化呢？比如，想要做一个由方形变为平行四边形的 **“错切”过程动画** 又或者是想要 **以某个特定的点作为圆心进行缩放**，这些在基本控件的内部并没有这么详细的 setter 方法，那要如何实现呢？\n\n想要实现上述需求的方法，那就是利用 Matrix 啦！在前一篇博客中介绍了关于 Matrix 的一些基本内容，可以知道 Matrix 是控制控件变换的一个很强大的工具，并且控制的是控件内部的画面而不是控件本身，那么如果能用 ObjectAnimator 不直接控制控件，而是控制一个 Matrix，再由 Matrix 去控制控件，就能达到需求了。这么听起来，其实跟 ValueAnimator 非常像都是通过控制数值间接控制控件，因为毕竟 ValueAnimator 才是爹呀！（ObjectAnimator：？？？？？）\n\n其实前面讲了过程，小伙伴肯定也已经想到了一个非常简单的实现方式：重写 View！在 View 中写一个接收 Matrix 的方法，通过这个方法把 Matrix 应用到图像中去实现变化效果。在 Demo 中，只是用了简单的 Scale 缩放，其实 ImageView 本身也提供了 ``setScaleX();`` 和 ``setScaleY();`` 方法，可以通过 PropertyValuesHolder 来一次改变两个属性（下文会讲到），但是我就想一次性同比例缩放，并且这个 Demo 仅仅是提供一种解决思路，例如在使用 Matrix 进行 Skew 错切变换时，重写 View 实现就是一个好方法了，读者可以举一反三多多尝试其他需要间接改变的属性。\n还是这个 Demo，上代码！\n\n首先因为我们需要自己的 View 中可以接收到 Matrix，所以先写一个接口，定义接收 Matrix 的方法，然后在自定义的View中实现这个接口并重写接口方法：\n\n```java\n//定义 接收Matrix方法的接口\npublic interface IView {\n    void setScaleToMatrix(float scaleValue);\n}\n```\n\n也可以不用接口直接在自定义View中添加方法，但养成良好的编程习惯总没有坏处。接下来自定义 View 继承自 ImageView（根据需求选择继承）并实现接口方法：\n\n```java\n//这是我自定义的 ScaleImageView，继承自 ImageView\npublic class ScaleImageView extends ImageView implements IView {\n\n    //重用的Matrix\n    Matrix matrix = new Matrix();\n\n    //直接默认重写所有四个构造方法即可\n    public ScaleImageView(Context context) {\n        super(context);\n    }\n    public ScaleImageView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n    }\n    public ScaleImageView(Context context, AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n    }\n    public ScaleImageView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n    }\n    //实现并重写接口方法\n    //我将该方法命名为 setScaleMatrix\n    //则 ObjectAnimator 中属性名 String 为 “scaleMatrix”或“ScaleMatrix”\n    @Override\n    public void setScaleToMatrix(float scaleValue) {\n        //布局中为了初始时视觉美观设置 ScaleType 为 fit_center，需改成 matrix 否则 Matrix 变换不起作用\n        this.setScaleType(ScaleType.MATRIX);\n        //X、Y轴同比例缩放\n        matrix.setScale(scaleValue, scaleValue);\n        //调用 ImageView 自带的方法应用 Matrix\n        setImageMatrix(matrix);\n    }\n}\n```\n\n```java\n//MainActivity 中就简单了，在需要执行动画的地方创建 ObjectAnimator 再指定变化范围即可\n//初始化控件，略了\nScaleImageView sivImage;\n......\n//设置按键监听，略了\nButton btButton；\n......\n//设置对应的属性和 setter 方法名，缩放范围：1～2，动画时间1秒\nObjectAnimator objectAnimator = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 1f, 2f).setDuration(1000);\nobjectAnimator.start();\n```\n\n再看一下效果：\n\n<center>\n\n![点击放大](/post_files/android/android-objectanimator-basic/click_scale_up.gif \"TOPICS\")\n\n</center>\n\n可以看到，动画还是很好的，相比我们手动写成循环的方式，ObjectAnimator 流畅多了，这里给一个小提示，因为 Matrix 如果采用 set 的方式时都会先重置为单位矩阵，因此不需要每次传值缩放时都重新 ``new Matrix();``，直接在自定义的 View 中声明并初始化一个 Matrix，可以减少对象的创建，节约内存。\n\n> 更多关于 ObjectAnimator 的详细资料可以参考附录【3】【4】\n\n***\n\n# 4. ObjectAnimator多动画并行\n\n现在我们的动画效果出来了，但是假如我又有一个需求，希望在放大的动画结束后再来个缩小的动画，怎么办呢？最直观的方法就是：在放大的动画下面在加一个缩小的动画不就行了吗？实践是检验真理的唯一标准，试一试就知道！在 MainActivity 调用动画的下面再加上缩小的动画：\n\n```java\n//放大动画\nObjectAnimator objectAnimator = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 1f, 2f).setDuration(1000);\nobjectAnimator.start();\n//缩小动画\nobjectAnimator = ObjectAnimator.ofFloat(sivImage, \"scaleMatrix\", 2f, 1f).setDuration(1000);\nobjectAnimator.start();\n```\n\n结果发现最后的效果是：\n\n<center>\n\n![放大接缩小动画](/post_files/android/android-objectanimator-basic/scale_up_and_down.gif \"TOPICS\")\n\n</center>\n\n视觉上来看，仿佛放大的动画并没有执行，直接跳过到了缩小的动画，但其实放大动画是执行了的，之所以会突然放大一下，并不是因为放大动画执行完的原因，而是我们设置的缩小动画的起始大小就是2f——两倍，所以动画会先从两倍大小开始缩小，造成这样的原因是因为：ObjectAnimator 在执行一个动画时，是非线程阻塞的 *（这也是比我们自己用``while()``写更好的原因之一）* ，在执行一个动画的时候，可以理解为 ``objectAnimator.start();`` 开始执行后，具体这个动画怎么变化，变多久，都交给后台处理 *（其实这个说法是不严谨的，因为要更新UI只有主线程才能做到，后面整理清楚了会专门再发一个从源码角度的解释）* ，然后主线程继续向下执行代码，而下一句代码就是缩小动画，于是放大动画刚刚开始，还没来得及展示，就已经开始执行缩小动画了，于是就变成了图中的效果。我们把第二个缩小的动画用改变透明度来替换一下，就直观多了！\n\n```java\n//放大动画\nObjectAnimator objectAnimator = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 1f, 2f).setDuration(1000);\nobjectAnimator.start();\n//改变透明度\nobjectAnimator = ObjectAnimator.ofFloat(sivImage, \"alpha\", 1f, 0f).setDuration(1000);\nobjectAnimator.start();\n```\n\n<center>\n\n![放大接改变透明度](/post_files/android/android-objectanimator-basic/scale_up_and_alpha.gif \"TOPICS\")\n\n</center>\n\n这个效果就很明显了，放大也是执行了的，改变透明度也是执行了的，因为每一次动画开始执行后就会继续向下执行，因此视觉上看起来很就是一起执行了。这也提供给了我们一个同时执行多个动画效果的思路：**硬生生的把多个动画效果顺序提交执行**。但是这也是非常非常不友好的实现方式，在每个动画效果比较简单、设备性能较好等情况下也许没有很严重的问题，但是如果动画复杂、处理量大，就会导致动画严重卡顿。于是这里就引出了 <font color=#EB6D39>PropertyValuesHolder</font> 这个工具，它和数据库中的 Transaction 事务管理非常像——要么不做、要么全做。\n\n<br/>\n\n## 4.1 PropertyValuesHolder属性值保存器\n\nPropertyValuesHolder 一次性记录多个要执行的动画，然后把自己传给 ObjectAnimator，来实现多个动画同时并行 *（事实上从底层上来看，CPU的处理在微观上依然单线程的，并且 PropertyValuesHolder 也有导致卡顿的风险）* ，下面是 PropertyValuesHolder 的使用样例：\n\n```java\n//通过 PropertyValuesHolder 存入需要改变的属性和值\nPropertyValuesHolder pvhScale = PropertyValuesHolder.ofFloat(\"scaleToMatrix\", 4.2f, 8.4f);\nPropertyValuesHolder pvhAlpha = PropertyValuesHolder.ofFloat(\"alpha\", 1f, 0f);\n\n//通过 ObjectAnimator 应用到控件中\nobjectAnimator = ObjectAnimator.ofPropertyValuesHolder(sivImage, pvhScale, pvhAlpha);\nobjectAnimator.setDuration(1000);\nobjectAnimator.start();\n```\n\n从 PropertyValuesHolder（太长了，简称 PVH）的字面上就可以理解，PVH 是一个属性取值的保持器，也就是说，一个 PVH 对象就存入了一个你需要改变值的属性以及这个属性需要变化的取值，但是 PVH 本身是不接触控件的，从这方面来看，PVH 像极了 ValueAnimator，不同点在于 PVH 依然需要针对具体的属性。动画效果与上面的“放大接改变透明度”一样，就不再重复贴图了。\n\n<br/>\n\n## 4.2 AnimatorSet动画集合\n\n<font color=#EB6D39>AnimatorSet</font> 是一个动画集合，与之类似的还有一个叫 <font color=#EB6D39>AnimationSet</font> 的东西，从功能性来说，AnimatorSet 更为强大，AnimationSet 实现的效果与 PropertyValuesHolder 相似，都是把动画组合在一起执行，而 AnimatorSet 强大的地方在于，不仅能让动画组合执行，还能通过指定顺序让多个动画依次执行，因此本文中仅对 AnimatorSet 进行简单的讲解，篇幅有限，此处就只列出基本的应用方法，细节原理和复杂应用考虑在日后补充。\n\n先说说其中两个方法：\n\n 1. ``AnimatorSet.playTogether(property1)``\n 2. ``playSequentially(property2)``\n\n这两个方法从字面上就很好理解了，``playTogether()`` 是同时进行，``playSequentially()`` 是逐一进行。这里 property1 和 property2 不是具体的参数，因为这两种方法都分别各有两种类型的参数。\n\n``playTogether()`` 方法的参数可以是： *Collection\\<Animator\\>* 和 *Animator...* （注意后者是可变长参数），先看后者很明显可以知道，毕竟这个方法是要实现“同时进行”，所以肯定支持多个动画一起作为可变长参数传入，第一个 Collection<> 就是集合，泛型是 Animator 类，也就是说 Collection 集合内的每一个元素都要是 Animator 的对象，这和可变长的 Animator... 是一样的。之所以是集合还是因为这个方法要同时执行所有动画，所以所有的动画在逻辑上是“一层”的，没有顺序、前后之分，在 Java 中就用集合来表示。\n\n``playSequentially()`` 的方法参数可以是：List<Animator> 和 Animator...（注意后者依然是可变长参数），与上面的大同小异，传进去的都是一个或多个 Animator 的对象，但是这里是 List 列表而不是集合，就是因为这个方法是逐一进行，是有执行的前后顺序之分的，在 Java 中就用 List 来表示。\n\n从参数来看，无论是哪一种，目的都是传 Animator 对象过去，也就是我们要先定义一个个 Animator 的对象，然后制定出每一个 Animator 需要做的动画效果，再把这些（或一个）Animator 交给 AnimatorSet 替我们完成。在 Demo 中，我们可以这样运用：\n\n```java\n//放大动画\nObjectAnimator zoomInAnim = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 1f, 2f);\n//缩小动画\nObjectAnimator zoomOutAnim = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 2f, 1f);\n\n//ObjectAnimator 继承自 ValueAnimator，而后者又继承自 Animator\nAnimatorSet animatorSet = new AnimatorSet();\n//以下四种都是对的\n\n//同时进行方式一\nanimatorSet.playTogether(zoomInAnim, zoomOutAnim);\n//同时进行方式二\nArrayList<Animator> arrayList = new ArrayList<>();\narrayList.add(zoomInAnim);\narrayList.add(zoomOutAnim);\n//关于 Collection 的详情可以参考网上，这里不细展开\nCollection<Animator> collection = arrayList;\nanimatorSet.playTogether(collection);\nanimatorSet.setDuration(1000);\nanimatorSet.start();\n\n//逐一进行方式一\nanimatorSet.playSequentially(zoomInAnim, zoomOutAnim);\n//逐一进行方式二\nList<Animator> list = new ArrayList<>();\nlist.add(zoomInAnim);\nlist.add(zoomOutAnim);\nanimatorSet.playSequentially(list);\nanimatorSet.setDuration(1000);\nanimatorSet.start();\n```\n\n除了上面两个方法外，还有以下这几个方法：\n\n 1. ``play(Animator)``\n 2. ``with(Animator)``\n 3. ``before(Animator)``\n 4. ``after(delayTime)``\n 5. ``after(Animator)``\n\n依然从字面上看就很好理解，play() 就是当前需要进行的动画，with(Animator) 就是同时执行的动画，before(Animator) 和 after(Animator) 就是需要在参数中的 Animator 前／后执行，而 after(delayTime) 方法是用来设置动画延迟执行的时间。具体的使用方式直接通过代码解释：\n\n```java\n//Animator 集合\nAnimatorSet animatorSet = new AnimatorSet();\n//定义四种动画：透明度减半，放大，缩小，旋转90°\nObjectAnimator animAlpha, animZoomIn, animZoomOut, animRotation;\n\nanimAlpha = ObjectAnimator.ofFloat(sivImage, \"alpha\", 1f, 0.5f);\nanimZoomIn = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 1f, 2f);\nanimZoomOut = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 2f, 1f);\nanimRotation = ObjectAnimator.ofFloat(sivImage, \"rotation\", 0f, 90f);\n\n//设置动画的播放顺序\nanimatorSet.play(animAlpha).with(animZoomIn);\nanimatorSet.play(animZoomIn).before(animRotation);\nanimatorSet.play(animZoomOut).after(animRotation);\nanimatorSet.play(animRotation);\n\nanimatorSet.setDuration(1000);\nanimatorSet.start();\n```\n\n看一下我们预期的播放顺序，四个play操作从上到下的预期结果是：\n\n 1. 执行透明度减半，同时执行放大\n 2. 执行放大，并且放大在旋转前执行\n 3. 执行缩小，并且在旋转之后执行（也就是先旋转再缩小）\n 4. 执行旋转\n\n整理一下播放顺序应该是：1（透明度减半，同时放大）→2（旋转）→3（缩小）。\n可以看到，我们在 play(Anim_1) 动画后定义了 with(anim_2)／before(anim_2)／after(anim_2) 后，还需要在下面正式调用 play(anim_2) 才能完成播放，这是因为 with、before、after 只是制定了播放的顺序，并没有表示开始播放。并且，这三个方法是可以链式调用的，也即：``play().before().after().with()...`` 但是我们应当避免这种写法，以避免出现 ``play(anim1).before(anim2).after(anim2)`` 这种矛盾的情况。看一下实际的动画结果：\n\n<center>\n\n![连续动画](/post_files/android/android-objectanimator-basic/animator_continually.gif \"TOPICS\")\n\n</center>\n\n确实和预期是相符的！AnimatorSet 也确实是一个对动画进行控制非常非常强大的工具。\n\n> AnimatorSet的详解可以参考附录【5】\n> AnimatorSet以及AnimationSet的区别可以参考附录【6】\n\n<br/>\n\n## 4.3 AnimatorListener动画监听\n\n在做动画效果的时候，往往我们不会仅仅只是为了展示，而会接一些逻辑上的事情，比如 Splash 页面的动画在执行完后要进入主页、更改信息的动画执行完后要退回上一个界面、Tips 引导动画执行完后要打开对应的操作窗口等等，但是上文我们也提到过，不论是 ValueAnimator 也好，ObjectAnimator 也好，或者 Animation 视图动画也好，其动画的运行过程可以 **理解为** 是在后台执行的，而主线程依然会继续向下执行代码，因此如果我们只是简单地把需要操作的事务代码放在动画执行的后面，会导致事务和动画一起执行，那么我们到底要如何才能做到 *“动画执行完之后操作事务”* 呢？方法就是：利用 AnimatorListener 监听器。\n\n同理，既然 AnimatorListener 是一个监听器，那它就需要被绑定到想要监听的动画上，动画监听有四个需要重写的方法：\n\n 1. ``onAnimationStart(Animator animation){...}`` ：动画开始时要做的\n 2. ``onAnimationCancel(Animator animation){...}`` ：动画被取消时要做的\n 3. ``onAnimationRepeat(Animator animation){...}`` ：动画重复执行时要做的\n 4. ``onAnimationEnd(Animator animation){...}`` ：动画结束时要做的\n\n命名都很直观，第1个方法就是动画一开始要做的事，很简单就不多说了。这里再提一下第2、3个方法。\n``onAnimationCancel()`` 是动画被取消时要做的，和 end 不同的是，cancel 中的事务是我们人为地调用 ``animator.cancel();`` 方法时才会触发，而 end 是动画自己执行完后就会执行的。\n\n至于 ``onAnimationRepeat();`` 方法，我们在设置一个动画不论是属性动画也好还是视图动画也好，都可以设置动画重复的次数：\n\n```java\nobjectAnimator.setRepeatCount(5);\n```\n\n``onAnimationRepeat();`` 方法就会在动画每次重复执行时调用，并且第一次执行也算在内，也就是说我们设置的 repeatCount 是几，这个方法就会调用几次。\n\n这么一看马上就知道了，要在动画结束时执行某些事务，直接重写 ``onAnimationEnd()`` 方法即可。如果我们想要 Demo 中的图片无限重复放大再缩小再放大再缩小……最直观的的解决方案当然是利用死循环来做，但是前面也说了，``while`` 会导致主线程阻塞，对于比较简单的动画效果（例如本文的 Demo，或者旋转等等规律步骤比较少的）可以进行如下设置：\n\n```java\nobjectAnimater.setRepeatCount(ValueAnimator.INFINITE);  // ValueAnimator.INFINITE是int型，值为-1\n```\n\n这是 Android 官方给我们的方法，但是如果我们有一个非常非常复杂的动画（虽然基本上是没有这种需求的，Android 的动画大都能通过分解转换成简单动画）比如我非要把：放大，旋转、对称、缩小、错切、平移、旋转……作为单次动画流程然后再无限循环这个流程的话，显然我们很难把这么多操作写在一个方法里完成，这时就可以用一个脑洞大开的方式曲线救国啦—— <font color=#EB6D39>AnimatorListener 的迭代</font>！\n\n### 4.3.1 AnimatorListener的迭代\n\n仔细想一下 ``AnimatorListener``，里面有 ``onAnimationEnd()`` 方法，再仔细想一下，只要我们设置的不是无限动画，那就都会在结束时调用监听。利用这个思路，我们可以定义一个动画执行步骤的变量，用来引导动画进行的顺序。在 Demo 中，仅用缩放作为示例，复杂的动画变换可以参考思路进行拓展。\n\n先写出成员变量和动画监听部分，在按钮的点击事件中有一些处理放在下面讲。\n\n```java\n/*\n先让类实现 OnclickListener 和 AnimatorListener 接口，并在类中重写四个方法\n具有大量操作时，尽量避免使用下述匿名内部类的形式：\nobjectAnimator.addListener(new AnimatorListener() {\n    ......\n});\n*/\n\n//定义一个动画步骤成员变量，用来指导动画执行的顺序\nprivate int animStep = 0;\n\nprivate ObjectAnimator objectAnimator;\nprivate ScaleImageView sivImage;\nprivate Button btButton;\n\n//仅写出 onAnimationEnd() 部分\n@Override\npublic void onAnimationEnd(Animatior animation) {\n    //判断一下非空的情况，避免在重复点击时出现空指针异常\n    if(animation != null) {\n        switch(animStep) {\n            case 0 : {\n                //在点击按钮时进行放大，因此在放大动画结束后应该先缩小\n                objectAnimator = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 2f, 1f).setDuration(1000);\n                //自增，指导第二个步骤\n                animStep++;\n                break;\n            }\n            case 1 : {\n                //第二步为缩小，在 Demo 中只有两步，因此最后一步应把 animStep 重置\n                objectAnimator = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 1f, 2f).setDuration(1000);\n                //有多个步骤时，前面的步骤执行完 animStep 都自增，最后一步执行完后重置\n                animStep = 0;\n                break;\n            }\n            defalut : break;\n        }\n\n        objectAnimator.start();\n        //再把自己重新注册进监听器内继续监听 onAnimationEnd() 方法\n        objectAnimator.addListener(this);\n    }\n}\n```\n\n接下来就是点击按钮开始动画的部分了。在具体的应用中，并不一定非要用 Button 来触发动画，这里只是专门做一个提醒来指出在使用手动触发动画时一个容易出错的地方。在 Demo 中，按钮主要用来启动动画的第一次执行，那么我们常常只会想到要这么写：\n\n```java\n@Override\npublic void onClick(View v) {\n    objectAnimator = ObjectAnimator.ofFloat(sivImage, \"scaleToMatrix\", 1f, 2f).setDuration(1000);\n    objectAnimator.start();\n    objectAnimator.addListener(this);\n}\n```\n\n执行一下\n\n<center>\n\n![初始点击事件](/post_files/android/android-objectanimator-basic/init_click_event.gif \"TOPICS\")\n\n</center>\n\n乍一看确实没什么问题，确实达到预期的效果了，但是如果我们这时多次点击按钮就会“翻车”\n\n<center>\n\n![动画并行问题](/post_files/android/android-objectanimator-basic/multi_animator_issue.gif \"TOPICS\")\n\n</center>\n\n原因也很简单，因为我们每次点击时都会触发一次重新执行动画，并且也会加入动画监听，也就相当于每次点击都会增加一个动画效果的运行线，每个动画效果又自行监听运行过程，所以就会造成这样的混乱场面，如果是上文中的一系列复杂动画，翻车现场只会更加惨烈～解决的办法也很简单，就是每次点击都让动画步骤初始化从第一步开始，然后取消原先的所有动画，并且取消原先绑定的监听器，然后再重新绑定和设定动画的效果。改进的点击事件代码如下：\n\n```java\n@Override\npublic void onClick(View v) {\n    //依然要进行一个非空判断，否则第一次运行时会报空指针异常\n    //非空从逻辑上也表明了是“已经在执行动画的过程中再次点击”\n    if(objectAnimator != null) {\n        //取消当前的动画\n        objectAnimator.cancel();\n        //移除所有监听器，也可以单独仅移除 AnimatorListener\n        //仅移除某个监听器时，需要实例化具体的监听器并绑定动画\n        objectAnimator.removeAllListeners();\n    }\n    //初始化动画步骤\n    animStep = 0;\n    //重新设置动画和监听\n    objectAnimator = ObjectAnimator.ofFloat(ivImage, \"scaleToMatrix\", 1.05f, 2.1f).setDuration(1000);\n    objectAnimator.start();\n    objectAnimator.addListener(this);\n}\n```\n\n改进完后再看，也就不会出现翻车现场啦！\n\n<center>\n\n![改进的并行动画](/post_files/android/android-objectanimator-basic/fixed_multi_animator.gif \"TOPICS\")\n\n</center>\n\n这下这个 “*~~脑洞大开然鹅好像并没有什么卵用也不知道为什么要写这么多的需求~~*” 总算是解决了，代码而言是真的很简单也很少，但是思路和解决方案希望可以给同是初学的读者们一些灵感，用以运用在大型、复杂的项目中去。\n本篇结合前一篇写的 [关于Matrix](/2018/09/06/Android/android-matrix-basic/) 的文章，应该可以解决大部分情况下简单的动画场景了，但是这两篇博客的讲解可以说是非常皮毛的，甚至对于我自己的实际应用都远远不够，但还是那句话，本文主要目的是提供一种思维方式，再灵活运用进实际的项目中去。对于深入的 ObjectAnimator、 ValueAnimator、 Matrix内容，还是应该细读官方的文档和源码为好。\n\n***\n\n# 5. 附录[参考指导]\n\n> - [【1】Android属性动画之ValueAnimator的介绍（作者：火龙裸先生）<sup>【注】</sup>](https://www.cnblogs.com/huolongluo/p/6792362.html \"TOLINKS\")\n> - [【2】自定义控件三部曲之动画篇(四)——ValueAnimator基本使用（作者：启舰）<sup>【注】</sup>](https://blog.csdn.net/harvic880925/article/details/50525521 \"TOLINKS\")\n> - [【3】ObjectAnimator详解（作者：钉某人）<sup>【注】</sup>](https://blog.csdn.net/Leslie_LN/article/details/67639753 \"TOLINKS\")\n> - [【4】属性动画之—ObjectAnimator基本使用（作者：Linleslie）<sup>【注】</sup>](https://blog.csdn.net/Leslie_LN/article/details/67639753 \"TOLINKS\")\n> - [【5】Android 动画之AnimatorSet（作者：行云间）<sup>【注】</sup>](https://blog.csdn.net/io_field/article/details/53101295 \"TOLINKS\")\n> - [【6】动画之AnimatorSet和AnimationSet的区别（作者：tml5945）<sup>【注】</sup>](https://blog.csdn.net/ttml5945/article/details/80324128 \"TOLINKS\")\n","tags":["Android","Matrix","ImageView","动画","ObjectAnimator"],"categories":["Android"]},{"title":"Android属性——矩阵Matrix入门","url":"/post/android/android-matrix-basic/","content":"<!-- more -->\n\n前言：最近项目中遇到了一个动画展示的需求——在不改变View的基础上，对“画布”进行动画变换，包括缩放、位移等，传统的 Animation 和 Animator 已经不能满足，于是开始着手接触 Matrix，将 Matrix 的入门知识与基础用法记录于本文。\n\n***\n\n# 1. Matrix初步认识\n\nMatrix：在英语里就是矩阵的意思，在Android中可以用来对控件在屏幕上的空间位置进行设置，Matrix在Android中是一个3×3的矩阵，但是是由长度为9的一维数组表示的，可以通过getMatrix().getValues();获取一个控件的矩阵，返回值是一个float[]数组，长度为9位：\n　　\n```java\nfloat matrixValues = new float[9];\nmatrixValues = view.getMatrix().getValues();\n```\n\n但是具体Matrix矩阵这个东西有什么用呢？先来看一下这个3×3矩阵在逻辑上的结构如何：\n\n<center>\n\n![Matrix结构](/post_files/android/android-matrix-basic/matrix_structure.png \"TOPICS\")\n\n</center>\n\n解释一下：\n- **MSCALE** 就是缩放Scale，也就是控件的放大和缩小。\n- **MSKEW**  就是Skew错切，是控件X（或Y）轴不变，Y（或X）轴根据比例平移形成的变化。\n- **MTRANS** 就是Translate平移，是控件平移指定距离后的图像\n- **MPERSP** 的原文为Perspective透视，但是没有用过，也没有找到相关资料，以后再补全。\n\n***\n\n# 2. Matrix的基本简介\n\n去掉不熟悉的Perspective透视，从其他三个基本参数来看，不难看出Matrix的基本功能如下：\n\n 1. **Translate平移**\n 2. **Scale缩放**\n 3. **Skew错切**\n 4. **Rotate旋转**\n\n这四种变换都分别有三种实现方式：\n```java\n//前乘\npreTranslate();\npreScale();\npreSkew();\npreRotate();\n\n//设置\nsetTranslate();\nsetScale();\nsetSkew();\nsetRotate();\n\n//后乘\npostTranslate();\npostScale();\npostSkew();\npostRotate();\n```\n\n对于这三种实现方式，很多地方的解释都是从数学矩阵的角度来解释：前乘、后乘，但是对于我这种一看数学就头大的人来说，看完了也没明白是咋回事，其实非常简单，前乘就是“先做”，后乘就是“后做”，例如：\n```java\n//先平移，再缩放\npreTranslate(x, y);\npostScale(2f, 2f);\n\n//先缩放，再平移\npreScale(2f, 2f);\npostTranslate(x, y);\n```\n这样实现的效果就是先放大再平移了，这两种方式是有区别的，在前面引用的博客中有相应的详细介绍。而设置``setXXX()``方式，则是先清除并重置Matrix矩阵，再进行指定变换。例如：\n```java\npreTranslate(x, y);\nsetRotate(50f);\npostScale(2f, 2f);\n```\n这个变换最后实现的效果就只有：先旋转50度，再放大2倍了，因为``setRotate()``执行后，会先将matrix对象重置为初始的单位矩阵，然后再执行旋转50度，也即``preTranslate()``方法没起作用。：\n\n<center>\n\n![Matrix单位矩阵](/post_files/android/android-matrix-basic/matrix_identity.png \"TOPICS\")\n\n</center>\n\n前面三个都好解释，就是分别对应了三个矩阵内的元素，但是旋转怎么说？旋转的具体实现其实是直接调用Matrix的``setRotate(angle)``方法，其中angle代表需要旋转的角度，需要注意的是，默认的``setRotate(angle)``方法是顺时针转动。\n\n***\n\n# 3. Android动画变换与图像变换\n\n在Android开发中，Matrix经常用来做图像的变换操作，这里要提一下所谓的图像变换。\n\n举个例子，我们都知道当想要将一个视图旋转时，可以给这个View设置一个Animation，然后实现旋转的效果，并且能实现动态效果，能控制动画的时间、方式、多重动画或者更高级的视觉效果等，但是有时我们并不想将这个View整个一起做变换，而只是想要变化View里面包含的图像时，就可以利用这个View的Matrix来实现，举个栗子！\n\nDemo布局很简单，就是一个ImageView以及右边一个Button，通过Button来控制动画。设置ImageView的宽高均为200dp，为了更直观的展现动画变换与图像变换的区别，给这个ImageView设置一个背景色。\n　　\n<center>\n\n![初始状态](/post_files/android/android-matrix-basic/image_initial.png \"TOPICS\")\n\n</center>\n\n如果我们用动画实现放大一倍，很简单\n\n```java\n//初始化控件\nImageView ivImage = (ImageView) findViewById(R.id.ivImage);\n//设置一个缩放动画\nScaleAnimation scaleAnimation = new ScaleAnimation(1f, 2f, 1f, 2f,\n\t\t\t\t\t\tAnimation.RELATIVE_TO_SELF, 0.5f,\n\t\t\t\t\t\tAnimation.RELATIVE_TO_SELF, 0.5f);\nscaleAnimation.setDuration(2000);\n//开始缩放动画\nivImage.startAnimation(scaleAnimation);\n```\n这样就完成了一个ImageView放大一倍的动画效果。小小地解释一下ScaleAnimation的参数：\n``ScaleAnimation(float fromX, float toX, float fromY, float toY, int pivotXType, float pivotXValue, int pivotYType, float pivotYValue)``\n\n参数有一点多，慢慢分析：\n\n 1. **fromX（Y）**：动画开始前X（Y）的缩放值，取1表示从当前大小开始。\n 2. **toX（Y）**：动画要将控件的X（Y）缩放的值，取2表示放大到现在的两倍。\n 3. **pivotXType（pivotYType）**：动画在X（Y）轴上相对控件的位置类型。说白了就是这个动画是基于哪个坐标轴进行缩放，例如上面代码用的RELATIVE_TO_SELF，代表这个缩放是基于自身的坐标轴进行的。\n 4. **pivotXValue（pivotYValue）**：动画在所选坐标轴的X（Y）轴的哪个位置作为缩放原点。\n\n看完参数，``fromX（Y）``和``toX（Y）``就很简单了，主要是解释一下后面四个，还是用例子说话。代码中，``pivotXValue``和``pivotYValue``都是0.5f，则说明是在中间位置，上面``pivotType``设定的是*RELATIVE_TO_SELF*，那么这个中间位置就是ImageView自己的中间位置了，如果上面``pivotType``设定的是*RELATIVE_TO_PARENT*，那么就是以父布局的中点作为缩放中心，在本例中父布局就是根布局，那么这个效果就是以屏幕中心作为缩放中心了，这么解释或许会比较直观。\n\n需要说明一点的是，在Android中，默认情况下坐标原点位于控件左上角，这个位置是(0,0)，也就是说原点相对于整个控件的长度比例为0，控件的最右端为该控件在X轴上的末端，所有处在最右端的点相对于控件的长度比例是1，控件的最下端为该控件在Y轴上的末端，所有处在最下端的点相对于控件的长度比例也是1，这就解释了为什么``pivotXValue``和``pivotYValue``均设为0.5f时是以该控件中心点作为缩放中心，如果是两个0.0f，则是以左上角作为缩放中心，两个1f，则是以右下角作为缩放中心。特别强调一点，对于矩形这样的规则图形，右边一条线上的所有点X轴上长度比例都为1，但对于一个不规则图形（例如自定义View等），长度比例为1的点是位于最末端的点。\n\n回到Demo中，做完这个动画后，我们可以看到界面的变化：\n\n<center>\n\n![通过Animation变换](/post_files/android/android-matrix-basic/animate_by_animation.gif \"TOPICS\")\n\n</center>\n\n但是我们也发现，放大后的ImageView与Button已经有一部分重合了，如果是以原点为缩放中心放大的话，覆盖的范围会更大，这对于某些时候是不合我们需求的。从动画的效果上来看，我们可以把动画变换——Animation类型的变换归类为：控件视图级别的变换，也就是说ImageView设定的src资源画面的变换是基于ImageView本身的变换，再通俗一点，我们的电脑在显示一个图片，我们想要旋转这个图片，如果采用Animation的方式，旋转的实际效果是：扛着显示器旋转，而图片相对显示器是不变的。而在很多时候，我们只是想要图片本身变换，而显示器不动，这时我们就要利用控件的变换矩阵Matrix了！（终于切回正题了？）\n下面是Matrix变换的代码，短短几行，先看一遍代码再来看效果如何：\n\n```java\n//ImageView的缩放类型ScaleType为Matrix时才能进行Matrix缩放\n//也可以在xml中设置scale_type属性，不设置时默认是fill_center\nivImage.setScaleType(ImageView.ScaleType.MATRIX);\nMatrix matrix = new Matrix();\nmatrix.setScale(2f, 2f);\n\nivImage.setImageMatrix(matrix);\n```\n\n代码非常简单，就是创建一个Matrix对象（新的Matrix对象默认为一个单位矩阵），再设置这个matrix的参数为放大两倍，最后把matrix的效果应用到ImageView中，逻辑非常清楚。效果如何请看动图：\n\n<center>\n\n![通过Matrix变换](/post_files/android/android-matrix-basic/animate_by_matrix.gif \"TOPICS\")\n\n</center>\n\n可以看到Android小人确实放大了两倍，但是黄色背景区域的ImageView还是原本的大小，对其他控件的控件布局没有任何影响，也完美的符合了一些情况下的需求，当然并不是说Matrix比Animation更好，只是这两者各有所长，对于一些复杂的变换、多边形等，对于Matrix来说，尽管可以通过分解的方式实现，但是工作量也会增加很多，这时就不如选择Animation来完成，还能避免一些UI线程上的错误。\n\n同时上面的两个动图也很直观的表示了，Animation是具有动画效果的，而Matrix是一个点到点、状态到状态的变化，当我们需要一些友好的视觉效果时，单用Matrix就不能满足需求了，但是我们就毫无办法了吗？并不是的，对Android有一点了解的人应该都知道，Android实现动画的方式就是“帧播放”，也就是多个不同状态下的单个帧快速播放形成的连续画面，知道了这个原理想要实现Matrix的动画就很简单了。首先最直观的思路就是利用循环，还是以放大图片作为例子，可以先用一个``while``或者``for``包裹Matrix，然后在循环中每次放大一点点，然后``sleep()``一小段时间，来达到一个视觉上的模拟动画效果。但是这样的做法非常低级也很不友好，容易造成主线程阻塞，或者在循环内出现异常导致**ANR（Application Not Responding程序无响应崩溃）**，改善这个问题的一个简单思路是利用Handler和Thread在子线程中进行处理，同时回调UI线程进行界面更新，但是这样做不仅效率低，对于应用而言也不具有美观性，因此，想要用Matrix达到Animation的效果，可以配合Android自带的一个属性动画工具：<font color=#EB6D39>ObjectAnimator</font>！ObjectAnimator的原理就是由你自己定义多个状态的变化趋势，然后由Android系统自动替你完成状态与状态间变化的过程，来实现动画的效果。\n\n***\n\n# 4. Matrix总结\n上文对Matrix进行了一些基本介绍和简单的用法实例，总结一下：Matrix用来定义控件内包含画面的变换状态，相比Animation的持续动画效果来说，Matrix更加偏向于一个确定的状态，在需要连续展示一个变化过程的时候，Animation是更好的选择，而当我们只需要显示一个特定的画面状态并且不希望在改变画面时影响控件本身，就应该选择Matrix啦！同时Matrix也并不是不能实现动画效果，在我们对控件和控件内某个单独的属性需要控制时，Matrix都是非常好的选择，利用Matrix + ObjectAnimator再配合上自定义View，一样能达到非常好的动画效果！\n\n***\n\n# 5. ObjectAnimator——属性动画\n\n最后，在下一篇博客中将会对ObjectAnimator做一个比较简单的介绍，详情点击：[Android动画——属性动画：ObjectAnimator](/post/Android/android-objectanimator-basic/ \"TOLINKS\")\n\n***\n\n# 6. 附录[参考指导]\n\n> - [【1】Android Matrix的使用与自定义动画（作者：西电吴同学）<sup>【注】</sup>](https://blog.csdn.net/a62321780/article/details/51278505 \"TOLINKS\")\n> - [【2】setScale,preScale和postScale的区别（作者：Groople）<sup>【注】</sup>](https://blog.csdn.net/u010838555/article/details/44307615 \"TOLINKS\")\n> - [【3】Pro Android学习笔记（一零九）：2D动画（4）：view的Matrix（作者：恺风）<sup>【注】</sup>](https://blog.csdn.net/flowingflying/article/details/38304057 \"TOLINKS\")\n> - [【4】Android 图形处理特效 Matrix 的set 、 pre、post方法的区别和使用（作者：Richard_tan0113）<sup>【注】</sup>](https://blog.csdn.net/legend12300/article/details/51868071 \"TOLINKS\")\n> - [【5】Android Matrix详解（作者：flash129）<sup>【注】</sup>](https://blog.csdn.net/flash129/article/details/8234599 \"TOLINKS\")\n","tags":["Android","Matrix","ImageView","动画"],"categories":["Android"]},{"title":"ML入门——交叉验证与模型选择","url":"/post/machinelearning/ml-model/ml-model-selection/","content":"<!-- more -->\n\n***\n\n# 1. 模型的交叉验证\n\n<br/>\n\n## 1.1 划分校验集\n\n模型的评估不能在训练集上进行，而应该在新的测试数据上检验其 推广能力 / 泛化能力。但在实际任务中，测试数据往往是需要用来预测的数据，其标签是未知的，因此可以选择从全体训练数据中分离出一部分作为校验数据，不参与模型的训练：\n\n<center>\n\n![校验数据](/post_files/machinelearning/ml-model/ml-model-selection/check_data.png \"TOPICS\")\n\n</center>\n\n当训练样本足够多时，划分剩下的训练样本仍足以训练出较好的模型时，即可采用这个方式。Scikit-Learn 中提供了划分校验集的功能：\n\n```python\n# class sklearn.model_selection.train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(*arrays, **options)\n\n\n# 例程\n>>> import numpy as np\n>>> from sklearn.model_selection import train_test_split\n\n>>> X, y = np.arange(10).reshape((5, 2)), range(5)\n\n>>> X\narray([[0, 1],\n      [2, 3],\n      [4, 5],\n      [6, 7],\n      [8, 9]])\n\n>>> list(y)\n[0, 1, 2, 3, 4]\n\n>>> X_train, X_test, y_train, y_test = train_test_split(\n         X, y, test_size=0.33, random_state=42)\n\n>>> X_train\narray([[4, 5],\n      [0, 1],\n      [6, 7]])\n\n>>> y_train\n[2, 0, 3]\n\n>>> X_test\narray([[2, 3],\n      [8, 9]])\n\n>>> y_test\n[1, 4]\n\n>>> train_test_split(y, shuffle=False)\n[[0, 1, 2], [3, 4]]\n```\n\n``*arrays``：\n需要划分的数据 (X, y)。sequence of indexables with same length / shape[0].\nAllowed inputs are lists, numpy arrays, scipy-sparse matrices or pandas dataframes.\n\n``test_size``：\n校验集大小。float, int or None, optional (default=None)\nIf float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the test split. If int, represents the absolute number of test samples. If None, the value is set to the complement of the train size. If train_size is also None, it will be set to 0.25.\n\n``train_size``：\n训练集大小。float, int, or None, (default=None)\nIf float, should be between 0.0 and 1.0 and represent the proportion of the dataset to include in the train split. If int, represents the absolute number of train samples. If None, the value is automatically set to the complement of the test size.\n\n``random_state``：\n随机种子。int, RandomState instance or None, optional (default=None)\nIf int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If None, the random number generator is the RandomState instance used by np.random.\n\n``shuffle``：\n划分数据前是否洗牌。boolean, optional (default=True)\nWhether or not to shuffle the data before splitting. If shuffle=False then stratify must be None.\n\n``stratify``：\n分层抽样。array-like or None (default=None)\nIf not None, data is split in a stratified fashion, using this as the class labels.\n分层抽样主要用在分类数据类别样本不均衡的时候，如正负样本比例为 1 : 9，假设划 20% 作为校验数据，则分别对正样本和负样本各自划分 20% 作为校验数据再合并。\n\n※ 注 | ``train_test_split`` 还能在数据集较大时，用来分隔出小部分数据进行 EDA。\n\n<br/>\n\n## 1.2 交叉验证\n\n当训练数据比较少，或模型训练需要更多数据时（训练样本越多越好），直接分离校验集就不太好了，这时可使用 K 折交叉验证。\n\nK 折交叉验证即：将全体训练样本等分为 K 份（若无法完全等分，多出来的部分都放进最后一份中），每次用 1 份数据作为校验集，余下 (K - 1) 份作为训练数据，重复 K 次：\n\n<center>\n\n![K 折交叉验证](/post_files/machinelearning/ml-model/ml-model-selection/k_fold.png \"TOPICS\")\n\n</center>\n\n※ 注 | 该方法计算代价很高，但不会浪费太多数据，当样本数据集较少时有优势，K 常取 [3, 5, 10]。\n\nScikit-Learn 中实现了 K 折交叉验证 ``KFold``：\n\n```python\n# class sklearn.model_selection.KFold\n\nKFold(n_splits=3,\n      shuffle=False,\n      random_state=None)\n```\n\n``n_splits``：\n交叉验证的折数 K，默认为 3。\n\n``shuffle``：\n是否在划分数据之前对全体数据进行洗牌（打乱顺序）。\n\n``random_state``：\n由随机数产生器产生的随机种子。当参数 ``shuffle == True`` 时用到。\n\n当数据是分类数据时（标签 y 为类别），为保证每折中各个类别样本比例一致，Scikit-Learn 实现了分层（Stratified）的 K 折交叉验证 ``StratifiedKFold``：\n\n```python\n# class sklearn.model_selection.StratifiedKFold\n\nStratifiedKFold(n_splits=3,\n                shuffle=False,\n                random_state=None)\n\n\n# 例程\n>>> import numpy as np\n>>> from sklearn.model_selection import StratifiedKFold\n\n>>> X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]])\n>>> y = np.array([0, 0, 1, 1])\n>>> skf = StratifiedKFold(n_splits=2)\n\n>>> skf.get_n_splits(X, y)  # 得到划分结果\n2\n\n>>> skf\nStratifiedKFold(n_splits=2, random_state=None, shuffle=False)\n\n>>> for train_index, test_index in skf.split(X, y):\n    # split() 取出每折训练和校验数据的索引\n        print(\"TRAIN:\", train_index, \"TEST:\", test_index)\n        X_train, X_test = X[train_index], X[test_index]\n        y_train, y_test = y[train_index], y[test_index]\n\nTRAIN: [1 3] TEST: [0 2]\nTRAIN: [0 2] TEST: [1 3]\n```\n\n``StratifiedKFold`` 参数含义与 ``KFold`` 相同。\n\n假设有一训练数据集如下表：\n\n| 样本索引 | $x_1$ | $x_2$ | y |\n| :---: | :---: | :---: | :---: |\n| 0 | 1 | 2 | 0 |\n| 1 | 3 | 4 | 0 |\n| 2 | 1 | 2 | 1 |\n| 3 | 3 | 4 | 1 |\n\nK 折交叉验证中，校验验证通常用于 模型选择 / 超参数调优（评价不同超参数对应模型的性能）。交叉验证的步骤流程如下图：\n\n<center>\n\n![K 折交叉验证流程](/post_files/machinelearning/ml-model/ml-model-selection/k_fold_detail.png \"TOPICS\")\n\n</center>\n\nScikit-Learn 中实现两个了采用 K 折交叉验证评估模型性能的函数：``cross_val_score`` 和 ``cross_validate``：\n\n```python\n# class sklearn.model_selection.cross_val_score\n\ncross_val_score(estimator,\n                X,\n                y=None,\n                groups=None,\n                scoring=None,\n                cv=None,\n                n_jobs=1,\n                verbose=0,\n                fit_params=None,\n                pre_dispatch='2*n_jobs')\n\n\n# 例程\n>>> from sklearn import datasets, linear_model\n>>> from sklearn.model_selection import cross_val_score\n\n>>> diabetes = datasets.load_diabetes()\n>>> X = diabetes.data[:150]\n>>> y = diabetes.target[:150]\n>>> lasso = linear_model.Lasso()\n\n>>> print(cross_val_score(lasso, X, y, cv=3))\n[0.33150734 0.08022311 0.03531764]\n```\n\n``estimator``：\n要训练的模型\n\n``X, y``：\n全体训练数据\n\n``groups``：\n数据的分组标识。\n通常假设数据是独立同分布（Independent Identical Distribution, IID），但在有些应用中如果数据生成过程依赖于样本的 groups，（如从多个患者收集医学数据，从每个患者身上采集多个样本。则每个样本的患者 ID 是其分组标识）。在这种情况下，想知道在一组特定的 groups 上训练的模型是否能很好地适用于未见过的 group 。因此，要确保验证数据的所有样本与对应的训练折中的数据没有相同的组。（Scikit-Learn 中有一整套与 groups 有关的校验验证实现）。\n\n``scoring``：\n评价指标。\n\n``cv``：\n交叉校验划分策略。可为整数（交叉验证的折数 K）、交叉验证生成器的对象、产生 train / test 划分的迭代器对象。默认为 ``None``，采用3折交叉验证。输入类别数据时，自动采用分层抽样。\n\n``n_jobs``：\n使用CPU的数目，-1 表示使用所有的CPU资源（与设置为 CPU 核的数目效果相同）。\n\n``verbose``：\n日志冗长度。\n0：不输出训练过程\n1：偶尔输出\n$> 1$：对每个子模型都输出\n\n``fit_params``：\nestimator 的 ``fit()`` 函数需要的参数。\n\n``pre_dispatch``：\n控制并行计算中预派遣的任务数。\n根据设备条件（内存大小）设置。例如 12 折 CV 任务，且 ``n_jobs = 3``。\n① 当该参数不设置时，程序一次性将所有并行任务派遣给 CPU，则 3 个 CPU 各获得 4 份 CV 训练数据集和 4 份 测试数据集，并存放在内存中，各个 CPU 则按顺序训练，此时内存占用最高，但由于提前一次性将所有数据分配完毕，开始训练后的等待时间最小。\n② 当设置 ``pre_dispatch='1*n_jobs'`` 时，本例中即 ``pre_despatch == 3``，则程序每次只为 3 个 CPU 各分配一份数据，分配后 CPU 立即开始训练，训练完成后再次分配，此时内存占用最低，但由于每次训练完后才分配数据，开始训练后的等待时间最长。\n③ 当设置 ``pre_dispatch='2*n_jobs'`` 时，本例中即 ``pre_despatch == 6``，则 3 个 CPU 各获得两份 CV 训练数据（一份即时训练，另一份在队列中等待）并存储在内存中，当某个 CPU 训练完一份 CV 数据后，程序再分配下一份数据，直到所有数据均被分配完毕。通常这种设置的综合效果最佳。\n\n```python\n# class sklearn.model_selection.cross_validate\n\ncross_validate(estimator,\n               X,\n               y=None,\n               groups=None,\n               scoring=None,\n               cv=None,\n               n_jobs=1,\n               verbose=0,\n               fit_params=None,\n               pre_dispatch='2*n_jobs',\n               return_train_score='warn')\n\n\n# 例程\n>>> from sklearn import datasets, linear_model\n>>> from sklearn.model_selection import cross_validate\n>>> from sklearn.metrics.scorer import make_scorer\n>>> from sklearn.metrics import confusion_matrix\n>>> from sklearn.svm import LinearSVC\n\n>>> diabetes = datasets.load_diabetes()\n>>> X = diabetes.data[:150]\n>>> y = diabetes.target[:150]\n>>> lasso = linear_model.Lasso()\n\n# Single metric evaluation using cross_validate\n\n>>> cv_results = cross_validate(lasso, X, y, cv=3)\n\n>>> sorted(cv_results.keys())\n['fit_time', 'score_time', 'test_score']\n\n# cross_validate 可以得到每折的训练和校验得分，此处仅查看校验得分。\n>>> cv_results['test_score']\narray([0.33150734, 0.08022311, 0.03531764])\n\n# Multiple metric evaluation using cross_validate\n# (please refer the scoring parameter doc for more information)\n\n>>> scores = cross_validate(lasso, X, y, cv=3,\n...                         scoring=('r2',\n...                                  'neg_mean_squared_error'),\n...                         return_train_score=True)\n\n# 多种评价指标：'r2', 'neg_mean_squared_error'\n>>> print(scores['test_neg_mean_squared_error'])\n[-3635.5... -3573.3... -6114.7...]\n\n>>> print(scores['train_r2'])\n[0.28010158 0.39088426 0.22784852]\n```\n\n``return_train_score``：\n是否包含训练得分。\n默认 'warn' 表示真，包含训练得分。计算训练得分可以通过训练得分和校验得分查看模型在过拟合状态还是欠拟合状态。但是训练得分较慢，且不计算也不影响模型 的最佳参数选取（最佳参数只看校验得分），后续版本可能将缺省值设为 ``False``。\n  \n其他参数与 ``cross_val_score`` 相同。\n\n使用 ``cross_validate`` 可以输出训练集和校验集上的分数，从而判断是否处于欠拟合或过拟合的状态。\n\n<br/>\n\n## 1.3 特殊的交叉验证\n\n### 1.3.1 留一交叉验证\n\n特别地，当交叉验证的折数与样本数相等时（$K = N$），因为每次仅留出一个样本做校验，因此称为留一交叉验证。由于折数更多，通常进行时间也更长，一般仅在样本数非常少的时候使用。\n\n但对于线性模型，可以采用广义交叉验证（Generalized Cross Validation, GCV）来近似留一交叉验证，极大降低交叉验证的计算量。Scikit-Learn 中实现了基于 GCV 的线性模型，如：``RidgeCV``, ``LassoCV``, ``LogisticRegressionCV`` 等。其流程大致如下图：\n\n<center>\n\n![留一交叉验证](/post_files/machinelearning/ml-model/ml-model-selection/leave_one_cv.png \"TOPICS\")\n\n</center>\n\n### 1.3.2 自助法（Bootstrap）\n\n交叉验证（包括留一交叉验证）均为无放回采样，一个实例仅能被选择一次。而 Bootstrap 是有放回采样，假设数据集中有 N 个样本，每次有放回地从数据集中抽取一个样本，共采样 N 次。一个 Bootstrap 样本有 N 个样本，其中很可能存在重复数据。由于每个样本被采样的概率为 $\\dfrac {1} {N}$，则不被采样的概率为 $1 - \\dfrac {1} {N}$，因此一个 Bootstrap 的 N 个样本中，某个样本点不被采样的概率为 $(1 - \\dfrac{1} {N})^N \\approx 0.368$，也即一个 Bootstrap 样本中只包含了全体训练集中约 $63.2 \\%$ 的数据（K 折交叉验证每次包含 $1 - \\dfrac {1} {K}$ 的训练数据），因此也称为“0.632 自助法”。\n\n### 1.3.3 特殊的校验验证\n\n通常，训练数据假设是独立同分布的（Independent Identical Distribution, IID）。\n\n但在实际任务中，有时样本时使用与时间相关的过程生成的，也即样本间存在时序关系，样本与各自的时序强相关，例如股票的价格等，此时使用 time-series aware cross-validation scheme 更安全。\n\n同样，如果知道数据生成过程中具有分组结构（group structure），例如从不同 subjects、不同实验、不同测量设备收集的样本等，则使用 group-wise cross-validation 更安全。\n\n***\n\n# 2. 超参数调优\n\nScikit-Learn 中实现了基于交叉验证的模型超参数调优方法 ``GridSearchCV``：\n\n```python\n# class sklearn.model_selection.GridSearchCV\n\nGridSearchCV(estimator,\n             param_grid,\n             scoring=None,\n             fit_params=None,\n             n_jobs=1,\n             iid=True,\n             refit=True,\n             cv=None,\n             verbose=0,\n             pre_dispatch='2*n_jobs',\n             error_score='raise',\n             return_train_score='warn')\n\n\n# 例程\n>>> from sklearn import svm, datasets\n>>> from sklearn.model_selection import GridSearchCV\n\n>>> iris = datasets.load_iris()\n>>> parameters = {'kernel':('linear', 'rbf'), 'C':[1, 10]}\n>>> svc = svm.SVC(gamma=\"scale\")\n>>> clf = GridSearchCV(svc, parameters, cv=5)\n\n# fit 过程可能较慢，若有 M 个参数需搜索，采用 K 折交叉验证，则需训练 M x K 次。\n>>> clf.fit(iris.data, iris.target)\nGridSearchCV(cv=5,\n             error_score=...,\n             estimator=SVC(C=1.0,\n                           cache_size=...,\n                           class_weight=...,\n                           coef0=...,\n                           decision_function_shape='ovr',\n                           degree=...,\n                           gamma=...,\n                           kernel='rbf',\n                           max_iter=-1,\n                           probability=False,\n                           random_state=None,\n                           shrinking=True,\n                           tol=...,\n                           verbose=False),\n             iid=...,\n             n_jobs=None,\n             param_grid=...,\n             pre_dispatch=...,\n             refit=...,\n             return_train_score=...,\n             scoring=...,\n             verbose=...)\n\n# 输出的结果都保存在字典 cv_results_ 中。\n# 最佳超参数：best_params_\n# 最佳得分：best_score_\n# 最佳模型：best_estimator_，仅在设置 refit=true 时适用\n>>> sorted(clf.cv_results_.keys())\n['mean_fit_time', 'mean_score_time', 'mean_test_score',...\n 'param_C', 'param_kernel', 'params',...\n 'rank_test_score', 'split0_test_score',...\n 'split2_test_score', ...\n 'std_fit_time', 'std_score_time', 'std_test_score']\n```\n\n``param_grid``：\n待评价参数（可以多个超参数一起调优：grid）。\n\n``X, y``：\n全体训练数据。\n\n``iid``：\n样本是否是独立同分布。\n\n``refit``：\n评价指标。\n是否在找到最佳超参数后用全体训练数据再次训练模型参数。\n\n``error_score``：\n训练失败的处理\n\n**<font color=EB6D39>总结来说，K 折交叉验证可以检验超参数对应的模型的性能，配合网格搜索 ``GridSearchCV`` 可以遍历一段取值范围内的超参数 $\\lambda$ 并找到模型效果最好时的超参数 $\\lambda^{\\ast}$，再选定该超参数，使用全体训练数据再次训练模型，得到最佳模型参数 $W$，最终模型为 $f(X;W, \\lambda^{\\ast})$ 。</font>**","tags":["AI","MachineLearning","人工智能","机器学习","交叉验证"],"categories":["MachineLearning","Model"]},{"title":"ML入门——模型性能评价指标","url":"/post/machinelearning/ml-model/ml-model-performance/","content":"<!-- more -->\n\n***\n\n一个机器学习模型训练好后，需要采用一些度量准则评价模型预测的效果。根据任务的种类可以分为回归模型评价指标和分类模型评价指标。\n\n***\n\n# 1. 回归模型性能评价指标\n\n<br/>\n\n# 1.1 常见的 6 种评价指标\n\n（1）开放均方误差（Rooted Mean Squared Error, RMSE）：\n\n$\nRMSE(y, \\hat{y}) = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i, \\hat{y_i})^2}\n$\n\n开放的目的在于使得 RMSE 的返回值与 $y$ 的单位一致。\n\n（2）平均绝对值误差（Mean Absolute Error, MAE）：\n\n$\nMAE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} |y_i - \\hat{y_i}|\n$\n\n（3）绝对误差中值（Median Absolute Error, MedAE）：\n\n$\nMedAE(y, \\hat{y}) = median(|y_1 - \\hat{y_1}|, \\cdots, |y_N - \\hat{y_N}|)\n$\n\n相对于均值，中值对噪声点较不敏感。\n\n（4）平均平方 $\\log$ 误差（Mean Squared Logarithmic Error, MSLE）：\n\n$\nMSLE(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} \\left( \\log (1 + y_i) - \\log (1 + \\hat{y_i}) \\right)^2\n$\n\n当 $y$ 呈指数增长时可以使用，如计数、一年的平均销量、价格等。$1 + y_i$ 与 $1 + \\hat{y_i}$ 的目的是为了确保 $\\log$ 计算有意义（当 $y_i / \\hat{y_i} = 0$ 时，$\\log 0$ 无意义）。\n\n（5）$R^2$ 分数（$R^2$ Score）：\n\n$\n\\begin{aligned}\n& SS_{res}(y, \\hat{y}) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2\n\\\\ \n& SS_{tot}(y) = \\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\bar{y})^2\n\\\\ \n& R^2(y, \\hat{y}) = 1 - \\dfrac {SS_{res}(y, \\hat{y})} {SS_{tot}(y)}\n\\end{aligned}\n$\n\n$R^2$ 分数既考虑了预测值与真实值之间的差异，又考虑了问题本身针织之间的差异，是 Scikit-Learn 线性回归模型的默认评价准则。当 $SS_{res} = 0$ 时，$R^2 = 1$ 为最佳分数，分数越低则模型性能越差，可能为负值。\n\n（6）已解释的访查分数（Explained variance socre）：\n\n$\nexplained_variance(y, \\hat{y}) = 1 - \\dfrac {Var(y - \\hat{y})} {Var \\{ y \\} }\n$\n\n<br/>\n\n## 1.2 Scikit-Learn中的评价指标\n\nScikit-Learn 中有三种评价模型性能的方式，但基本都是通过上述 6 种计算方式实现的。\n\n（1）每个学习器 Estimator 自己的 ``score`` 方法，提供一个默认的评估方法（回归为 $R^2$ 分数）。\n\n（2）Metric：``sklearn.metrics`` 模块实现了一些函数，用来评估预测误差。\n\n``sklearn.metrics`` 中的回归评价指标：\n\n① ``metrics.explained_variance_score(y_true, y_pred)``：Explained variance regression score function\n② ``metrics.mean_absolute_error(y_true, y_pred)``：Mean-Absolute-Error regression loss\n③ ``metrics.mean_squared_error(y_true, y_pred[, ...])``：Mean-Squared-Error regression loss\n④ ``metrics.mean_squared_log_error(y_true, y_pred)``：Mean-Squared-Logarithmic-Error regression loss\n⑤ ``metrics.median_absolute_error(y_true, y_pred)``：Median-Absolute-Error regression loss\n⑥ ``metrics.r2_score(y_true, y_pred[, ...])``：$R^2$ (coefficient of determination) regression score function.\n\n（3）Scoring 参数：使用交叉验证评估模型的工具有 Scoring 参数，与 Metrics 一一对应。\n\n① ``explained_variance``；metrics.explained_variance_score\n② ``neg_mean_absolute_error``：metrics.mean_absolute_error\n③ ``neg_mean_squared_error``：metrics.mean_squared_error\n④ ``neg_mean_squared_log_error``：metrics.mean_squared_log_error\n⑤ ``neg_median_absolute_error``：metrics.median_absolute_error\n⑥ ``r2``：metrics.r2_score\n\nScoring 越高代表模型性能越好，其中 explained_variance 和 $R^2$ 本来即越高越好，因此 Scoring 可直接使用。第 ②、③、④、⑤ 个参数取“error”对应 误差 / 损失，因此对 error 取负数“neg_”。\n\n***\n\n# 2. 分类模型性能评价指标","tags":["AI","MachineLearning","人工智能","机器学习","评价指标"],"categories":["MachineLearning","Model"]},{"title":"ML入门——类别样本不均衡问题","url":"/post/machinelearning/ml-logistic/ml-logistic-unbalanced/","content":"<!-- more -->\n\n***\n\n","tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"],"categories":["MachineLearning","LogisticRegression"]},{"title":"ML入门——多类分类任务","url":"/post/machinelearning/ml-logistic/ml-logistic-multiclassify/","content":"<!-- more -->\n\n***\n\n","tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"],"categories":["MachineLearning","LogisticRegression"]},{"title":"ML入门——Logistic优化求解与牛顿法","url":"/post/machinelearning/ml-logistic/ml-logistic-optimization/","content":"<!-- more -->\n\n***\n\n在机器学习的优化求解算法中，梯度下降法是无约束优化问题优化求解最常用的方法之一，还有一种求解方法就是牛顿法。相比梯度下降法，牛顿法的收敛速度更快，但同时，每次迭代需要的计算量也更大。\n\n在牛顿法之前，需要先了解：[泰勒公式](https://baike.baidu.com/item/泰勒公式/7681487?fr=aladdin \"TOLINKS\")。泰勒公式通俗地讲，就是当函数 $f$ 在点 $x$ 处的一阶导数、二阶导数……n 阶导数已知时，即可使用 n 阶泰勒展开来逼近函数 $f$ 在点 $x$ 的 <font color=red>邻域</font> 的函数值，因此泰勒公式求的是一个点的邻域的近似函数值。\n\n对应优化求解中，通常我们习惯于使用迭代法来求解，而迭代法的本质即：每次向正确的方向移动一小段，直到达到给定条件。这就与泰勒公式不谋而合——每次移动一小段之后的函数值可以使用移动前该点的泰勒展开来逼近，因此牛顿法或拟牛顿法都是在泰勒公式的基础上进行的。\n\n# 1. 牛顿法\n\n牛顿法（Newton - Raphson，牛顿 - 拉夫逊）是牛顿在 17 世纪提出的用于求解方程的根的方法。其求解思想如下：\n\n① 假设点 $x^{\\ast}$ 为函数 $f(x)$ 的根，则 $f(x) = 0$。\n\n② 将函数 $f(x)$ 在点 $x_0$ 处进行一阶泰勒展开有：$f(x) \\approx f(x_0) + (x - x_0) f'(x_0)$\n\n③ 假设点 $x$ 为 $x_0$ 邻域内一点，且 $x$ 为函数的根，则有：$f(x) \\approx f(x_0) + (x - x_0) f'(x_0) = 0$\n\n④ 将上式变换即可得：$x = x_0 - \\dfrac {f(x_0)} {f'(x_0)}$\n\n上述牛顿法得到的结论，拓展到迭代的过程中，假设当前处在迭代第 t 轮，则可以得到下一轮 (t + 1) 时刻的解的表达式为：\n\n$\nx^{(t + 1)} = x^{(t)} - \\dfrac {f(x^{(t)})} {f'(x^{(t)})}\n$\n\n这就是牛顿法优化求解的基本思想。下图展示了牛顿法求解方程 $f(x) = 0$ 的根的过程（图自 Wiki）：\n\n<center>\n\n![牛顿法迭代过程](/post_files/machinelearning/ml-logistic/ml-logistic-optimization/newton_iteration.png \"TOPICS\")\n\n</center>\n\n回到最优化问题中，通常会将问题转化成求极小值（误差、损失最小等），极小值对应了函数的导数为 0，因此需要适当调整牛顿法的目标，从求 $f(x) = 0$ 变为求 $f'(x) = 0$，因此原问题变为求 $f'(x)$ 的根。\n\n令 $g(x) = f'(x)$，则关于 $x$ 的迭代条件变为：\n\n$\nx^{(t + 1)} = x^{(t)} - \\dfrac {g(x^{(t)})} {g'(x^{(t)})} = x^{(t)} - \\dfrac {f'(x^{(t)})} {f''(x^{(t)})}\n$\n\n在实际问题中，通常输入 $X$ 的维度都大于 1，因此将一阶导数替换为梯度（即 $f$ 分别对每个 $x_i$ 求偏导后组成向量）：\n\n$\n\\nabla f(x_1, \\cdots, x_D)\n$\n\n将二阶导数替换为海森（Hessian）矩阵 H：\n\n$\nH(X) = \\left[\n\\begin{matrix}\n\\dfrac {\\partial^2 f} {\\partial^2 x^2_1} & \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_2} & \\cdots & \\dfrac {\\partial^2 f} {\\partial x_1 \\partial x_D}\n\\\\ \n\\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_1} & \\dfrac {\\partial^2 f} {\\partial^2 x^2_2} & \\cdots & \\dfrac {\\partial^2 f} {\\partial x_2 \\partial x_D}\n\\\\ \n\\vdots & \\vdots & \\ddots & \\vdots\n\\\\ \n\\dfrac {\\partial^2 f} {\\partial x_D \\partial x_1} & \\dfrac {\\partial^2 f} {\\partial x_D \\partial x_2} & \\cdots & \\dfrac {\\partial^2 f} {\\partial^2 x^2_D}\n\\end{matrix}\n\\right]\n$\n\nHessian 矩阵即：第 i 行第 j 列的元素为 $f$ 先对 $x_i$ 求偏导后再对 $x_j$ 求偏导。由于 $f$ 先对 $x_i$ 再对 $x_j$ 求偏导和 $f$ 先对 $x_j$ 再对 $x_i$ 求偏导相等，即 $\\dfrac {\\partial^2 f} {\\partial x_i \\partial x_j} = \\dfrac {\\partial^2 f} {\\partial x_j \\partial x_i}$，因此 Hessian 矩阵是对称的。\n\n这样，牛顿法的迭代公式就变换为：\n\n$$\nx^{(t + 1)} = x^{(t)} - H^{-1} (X^{(t)}) \\ \\nabla f(X^{(t)})\n$$\n\n※ 注 | 二阶导转换为 Hessian 矩阵 $H(X^{(t)})$ 后作为分母，使用逆运算 $H^{-1} (X^{(t)})$ 来表示。\n\n总结牛顿法求解目标函数极值的迭代步骤如下：\n\n① 从 $t = 0$ 开始，初始化 $X^{(0)}$ 为随机值\n\n② 计算目标函数 $f(X)$ 在点 $X^{(t)}$ 的梯度：$g^{(t)} = \\nabla f(X^{(t)})$，以及 Hessian 矩阵：$H^{(t)} = H(X^{(t)})$\n\n③ 计算移动方向：$d^{(t)} = (H^{(t)})^{-1} \\ g^{(t)}$\n\n④ 根据迭代公式更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$\n\n⑤ 判断是否满足迭代终止条件（是否到达最大迭代次数，或相邻两次迭代的相对变化量或绝对变化量小于预设值，通常使用绝对量：$\\dfrac {f(X^{(t + 1)}) - f(X^{(t)})} {f(X^{(t)})} \\le \\varepsilon$），若满足则循环计数，返回最佳参数 $X^{(t + 1)}$ 和目标函数极小值 $f(X^{(t + 1)})$，否则跳转到第 2 步\n\n其中，第 ③ 步计算移动方向 $d^{(t)}$ 时，由于矩阵的逆求解困难，因此常用线性方程组计算：$H^{(t)} d^{(t)} = g^{(t)}$，当 $X$ 维度比较小时，可采用解析法求解 $d^{(t)}$，当 $X$ 维度比较高时，可采用梯度下降法或共而梯度下降法求解，因此对 $d^{(t)}$ 的求解又是一个迭代的计算过程。\n\n对比梯度下降法中的移动方向：$d^{(t)} = - \\eta g^{(t)}$，牛顿法：$d^{(t)} = - (H^{(t)})^{-1} \\ g^{(t)}$，Hessian 矩阵相比学习率（步长）$\\eta$ 包含的信息更多，因此牛顿法收敛速度更快，但从上述步骤也可明显看出牛顿法每次迭代的计算量都大幅增加。\n\n由于梯度下降法仅使用了一阶导数，而牛顿法使用了二阶导数矩阵，因此梯度下降法是一阶最优化算法，而牛顿法是二阶最优化算法。\n\n***\n\n# 2. 拟牛顿法\n\n牛顿法虽然收敛速度比梯度下降法更快，但在高维的情况下，计算目标函数二阶偏导数的复杂度很大，而且有时候目标函数的 Hessian 矩阵无法保持正定，不存在逆矩阵，此时牛顿法将不再能使用。\n\n为此提出：拟牛顿法（Quasi-Newton Methods），拟牛顿法旨在：不用二阶偏导数，而构造出可以近似 Hessian 矩阵（或 Hessian 矩阵的逆矩阵）的正定对称矩阵，再逐步优化目标函数。不同的近似 Hessian 矩阵构造方法产生了不同的拟牛顿法：BFGS / L-BFGS。\n\n  > 扩展阅读：\n  > \n  > 1. [谈谈常见的迭代优化方法](https://blog.csdn.net/aws3217150/article/details/50548177 \"TOLINKS\")\n  > 2. [Mathematical optimization: finding minima of functions](https://www.scipy-lectures.org/advanced/mathematical_optimization/ \"TOLINKS\")\n\n重新考虑迭代条件，假设有某点 $x_0$，目标函数 $f(x)$ 在该点（已知点）进行二阶泰勒展开：\n\n$\nf(x) \\approx f(x_0) + f'(x_0) (x - x_0) + \\dfrac {1} {2} f''(x_0) (x - x_0)^2\n$\n\n当 $X$ 为 向量 / 矩阵 时，导数即为梯度，上式转换为：\n\n$\nf(X) \\approx f(X_0) + \\nabla f(X_0) (X - X_0) + \\dfrac {1} {2} (X - X_0)^T \\nabla^2 f(X_0) (X - X_0)\n$\n\n对上式取梯度运算（$X_0$ 为已知点，因此其与其导数均可视为常数项）得：\n\n$\n\\nabla f(X) \\approx \\nabla f(X_0) + \\nabla^2 f(X_0) (X - X_0)\n$\n\n由于函数在点 $X_0$ 处的泰勒展开可以近似 $X_0$ 邻域内的函数值，假设 $X_0$ 即为迭代 t 次后得到的 $X^{(t + 1)}$，则迭代前一轮的 $X^{(t)}$ 即为邻域内一点，可用二阶泰勒展开逼近，因此可得迭代关系：\n\n$\n\\nabla f(X^{(t)}) \\approx \\nabla f(X^{(t + 1)}) + \\nabla^2 f(X^{(t + 1)}) (X^{(t)} - X^{(t + 1)})\n$\n\n再使用 gradiant 和 Hessian 分别表示 $X$ 的一阶梯度和二阶梯度矩阵：$g^{(t)} = \\nabla f(X^{(t)})$，$H^{(t)} = \\nabla^2 f(X^{(t)})$，整理可得：\n\n$\ng^{(t + 1)} - g^{(t)} \\approx H^{(t + 1)} (X^{(t + 1)} - X^{(t)})\n$\n\n进一步，引入记号：$s^{(t)} = X^{(t + 1)} - X^{(t)}$ 表示 $X$ 的变化量，$y^{(t)} = g^{(t + 1)} - g^{(t)}$ 表示梯度变化量，则可得简洁迭代关系：\n\n$$\ny^{(t)} \\approx H^{(t + 1)} s^{(t)}\n$$\n\n由于牛顿法中 Hessian 矩阵的逆难以计算，因此在拟牛顿法中，令 $B$ 表示 $H$ 的近似，$D$ 表示 $H^{-1}$ 的近似，代入上式即可得到 <font color=EB6D39>拟牛顿法的条件</font> 为：\n\n<font color=EB6D39>\n<center>\n\n$$\ny^{(t)} = B^{(t + 1)} s^{(t)}\n$$\n\n或\n\n$$\ns^{(t)} = D^{(t + 1)} y^{(t)}\n$$\n\n</center>\n\n实际上，拟牛顿法的条件给出了 Hessian 矩阵的近似需要满足的条件。\n\n</font>\n\n<br/>\n\n## 2.1 BFGS\n\nBFGS（Broyden, Fletcher, Glodfarb, Shanno）被认为是数值效果最好的拟牛顿法，且具有全局收敛性和超线性收敛速度。\n\nBFGS 算法采用迭代法逼近 Hessian 矩阵：$B^{(t + 1)} = B^{(t)} + \\Delta B^{(t)}$，初始值 $B^{(0)} = I$ 为单位矩阵，因此关键在于如何构造 $\\Delta B^{(t)}$。\n\n为保证矩阵 $B$ 的正定性，令 $\\Delta B^{(t)} = \\alpha u u^T + \\beta v v^T$，代入上述拟牛顿法条件可得：\n\n$\n\\begin{aligned}\ny^{(t)} &= B^{(t + 1)} s^{(t)} = (B^{(t)} + \\Delta B^{(t)}) s^{(t)} = B^{(t)} s^{(t)} + \\Delta B^{(t)} s^{(t)}\n\\\\ \n&= B^{(t)} s^{(t)} + \\alpha u u^T s^{(t)} + \\beta v v^T s^{(t)}\n\\\\ \n&= B^{(t)} s^{(t)} + u (\\alpha u^T s^{(t)}) + v (\\beta v^T s^{(t)})\n\\end{aligned}\n$\n\n※ 注 | 当 $u^T$ 或 $v^T$ 的维数与 $s^{(t)}$ 的维数一致（由于 $\\Delta B^{(t)}$ 是构造的，因此可以构造为相同维数）时，$u^T s^{(t)}$ 以及 $v^T s^{(t)}$ 均为一个标量数值（向量的转置 x 向量 = 数值）。\n\n令 $\\alpha u^T s^{(t)} = 1$，$\\beta v^T s^{(t)} = -1$，即 $\\alpha = \\dfrac {1} {u^T s^{(t)}}$，$\\beta = - \\dfrac {1} {v^T s^{(t)}}$，得到：\n\n$\nu - v = y^{(t)} - B^{(t)} s^{(t)}\n$\n\n不妨令 $u = y^{(t)}$，$v = B^{(t)} s^{(t)}$，代入 $\\alpha$ 和 $\\beta$ 的表达式得：\n\n$\n\\alpha = \\dfrac {1} {u^T s^{(t)}} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}\n$\n\n$\n\\beta = - \\dfrac {1} {v^T s^{(t)}} = - \\dfrac {1} {(B^{(t)} s^{(t)})^T s^{(t)}} = - \\dfrac {1} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}\n$\n\n代入 $\\Delta B^{(t)}$ 的表达式得：\n\n<font color=EB6D39>\n\n$$\n\\begin{aligned}\n\\Delta B^{(t)} &= \\alpha u u^T + \\beta v v^T\n\\\\ \n&= \\dfrac {y^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} - \\dfrac {B^{(t)} s^{(t)} (B^{(t)} s^{(t)})^T} {(s^{(t)})^T (B^{(t)})^T s^{(t)}}\n\\end{aligned}\n$$\n\n</font>\n\n※ 注 | Sherman-Morrison 公式：若 $A$ 为非奇异方阵，$1 + v^T A^{-1} u \\ne 0$，则有：\n\n$\n(A + uv^T)^{-1} = A^{-1} - \\dfrac {A^{-1} u v^T A^{-1}} {1 + v^T A^{-1}}\n$\n\n由于牛顿法迭代过程需要计算 Hessian 矩阵的逆矩阵，因此根据 Sherman-Morrison 公式可得：\n\n\n<font color=EB6D39>\n\n$$\n(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}\n$$\n\n</font>\n\n综上，对于 $\\Delta B^{(t)}$ 和 $D^{(t + 1)}$，均可使用 $s^{(t)}$（$X$ 的变化量）和 $y^{(t)}$（函数梯度的变化量）表示，而初始化 $B^{(0)} = D^{(0)} = I$ 是一指的，$s^{(t)}$ 和 $y^{(t)}$ 在 $X$ 已知（优化求解的目的是寻找最优的 $X$，而 $X$ 本来就是已知的）时均是可计算的。\n\n整理得 BFGS 更新参数的流程如下：\n\n① 从 $t = 0$ 开始，初始化 $D^{(0)} = I$\n\n② 计算移动方向：$d^{(t)} = D^{(t)} g^{(t)}$\n\n  > ※ 注 | 先用 $B^{(t)} = B^{(t - 1)} + \\Delta B^{(t - 1)}$ 迭代解出 $B^{(t)}$，再用 Sherman-Morrison 公式解出 $D^{(t)}$。\n\n③ 更新 $X$ 的值：$X^{(t + 1)} = X^{(t)} - d^{(t)}$\n\n④ $s^{(t)} = d^{(t)}$\n\n⑤ 若 $||g^{(t + 1)}|| \\le \\varepsilon$，则迭代终止\n\n⑥ 计算：$y^{(t)} = g^{(t + 1)} - g^{(t)}$\n\n⑦ $t = t + 1$，跳转第 2 步\n\n<br/>\n\n## 2.2 L-BFGS\n\n在 BFGS 中，每一轮迭代需要存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），但当 $X$ 维数很高时，矩阵的维度也会很高，需要耗费大量存储空间。\n\nL-BFGS（Limited memory BFGS）不直接存储 Hessian 矩阵或其近似（$B^{(t)}$ 或 $D^{(t)}$），而是存储迭代计算过程中的 $s^{(t)}$ 和 $y^{(t)}$ 来计算，从而减少参数存储所需空间。\n\n在 BFGS 中，Hessian 矩阵的更新公式为：\n\n$\n(B^{(t + 1)})^{-1} = D^{(t + 1)} = \\left( I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) D^{(t)} \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) + \\dfrac {s^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}}\n$\n\n令 $\\rho^{(t)} = \\dfrac {1} {(y^{(t)})^T s^{(t)}}$，$V^{(t)} = \\left( I - \\dfrac {y^{(t)} (s^{(t)})^T} {(y^{(t)})^T s^{(t)}} \\right) = I - \\rho^{(t)} y^{(t)} (s^{(t)})^T$\n\n  > ※ 注 | 由于向量 $s^{(t)}$（X的变化量）和向量 $y^{(t)}$（梯度变化量）的维数相同（都与 $X$ 维度相等），因此 $s^{(t)} (y^{(t)})^T$ 和 $s^{(t)} (s^{(t)})^T$ 是矩阵，而 $(y^{(t)})^T s^{(t)}$ 是一个数值，因此 $\\rho^{(t)}$ 是一个常数。\n\n则有：\n\n$\n\\begin{aligned}\n(V^{(t)})^T &= \\left( I - \\rho^{(t)} y^{(t)} (s^{(t)})^T \\right)^T\n\\\\ \n&= I - \\rho^{(t)} \\left( y^{(t)} (s^{(t)})^T \\right)^T\n\\\\ \n&= I - \\rho^{(t)} s^{(t)} (y^{(t)})^T\n\\\\ \n&= I - \\dfrac {s^{(t)} (y^{(t)})^T} {(y^{(t)})^T s^{(t)}}\n\\end{aligned}\n$\n\n因此原 Hessian 更新公式变为：\n\n<font color=EB6D39>\n\n$$\nD^{(t + 1)} = (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T\n$$\n\n</font>\n\n将上述迭代更新公式展开得：\n\n$\n\\begin{aligned}\nD^{(t + 1)} &= (V^{(t)})^T D^{(t)} V^{(t)} + \\rho^{(t)} s^{(t)} (s^{(t)})^T\n\\\\ \n& \\Downarrow\n\\\\ \nD^{(1)} &= (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T\n\\\\ \\\\ \nD^{(2)} &= (V^{(1)})^T D^{(1)} V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T\n\\\\ \n&= (V^{(1)})^T \\left( (V^{(0)})^T D^{(0)} V^{(0)} + \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right) V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T\n\\\\ \n&= (V^{(1)})^T (V^{(0)})^T D^{(0)} V^{(0)} V^{(1)} + (V^{(1)})^T \\rho^{(0)} s^{(0)} (s^{(0)})^T V^{(1)} + \\rho^{(1)} s^{(1)} (s^{(1)})^T\n\\\\ \n& \\ \\ \\vdots\n\\\\ \nD^{(t + 1)} &= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(0)})^T \\right] D^{(0)} \\left[ V^{(0)} V^{(1)} \\dots V^{(t)} \\right]\n\\\\ \n& \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(1)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(1)} V^{(2)} \\dots V^{(t)} \\right]\n\\\\ \n& \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(2)})^T \\right] \\left[ \\rho^{(1)} s^{(1)} (s^{(1)})^T \\right] \\left[ V^{(2)} V^{(3)} \\dots V^{(t)} \\right]\n\\\\ \n& \\ + \\ \\cdots \\cdots\n\\\\ \n& \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}\n\\\\ \n& \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T\n\\end{aligned}\n$\n\n从上述迭代过程可知，计算 $D^{(t + 1)}$ 需要用到 $\\left \\{ s^{(k)} y^{(k)} \\right \\}^t_{k = 0}$，若存储空间有限，仅能存储 m 组 $\\left \\{ s^{(k)} y^{(k)} \\right \\}$，当 $t > m$ 时，应当丢弃较早生成的 $\\left \\{ s^{(k)} y^{(k)} \\right \\}$。当然，由于丢弃了部分信息，此时计算的 $D^{(m + 1)}$ 是 $D^{(t + 1)}$ 的近似，也即 Hessian 矩阵的逆矩阵的进一步近似。\n\n当 $t > m + 1$ 时，构造近似公式：\n\n$\n\\begin{aligned}\nD^{(t + 1)} &= \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 1)})^T \\right] D^{(0)} \\left[ V^{(t - m + 1)} V^{(1)} \\dots V^{(t)} \\right]\n\\\\ \n& \\ + \\left[ (V^{(t)})^T (V^{(t - 1)})^T \\dots (V^{(t - m + 2)})^T \\right] \\left[ \\rho^{(0)} s^{(0)} (s^{(0)})^T \\right] \\left[ V^{(t - m + 2)} V^{(2)} \\dots V^{(t)} \\right]\n\\\\ \n& \\ + \\ \\cdots \\cdots\n\\\\ \n& \\ + (V^{(t)})^T \\left[ \\rho^{(t - 1)} s^{(t - 1)} (s^{(t - 1)})^T \\right] V^{(t)}\n\\\\ \n& \\ + \\rho^{(t)} s^{(t)} (s^{(t)})^T\n\\end{aligned}\n$\n\n$D^{(t)}$ 的迭代计算很繁琐，但计算 $D^{(t)}$ 的目的是为了得到搜索方向 $d^{(t)} = D^{(t)} g^{(t)}$，因此可以设计快速计算 $D^{(t)} g^{(t)}$ 的方法：\n\n<center>\n\n![双向循环快速求解搜索方向](/post_files/machinelearning/ml-logistic/ml-logistic-optimization/double_circle_direction.png \"TOPICS\")\n\n</center>\n\n算法中还有部分不太明白，暂时只放上图片，待研究透彻后改为 Python 代码形式。另有几篇关于该双向循环快速求解 $D^{(t)} g^{(t)}$ 算法的参考文章如下：\n\n  > 1. [机器学习中牛顿法凸优化的通俗解释（作者：红色石头Will）](https://blog.csdn.net/red_stone1/article/details/80821760 \"TOLINKS\")\n  > 2. [牛顿法与拟牛顿法学习笔记（五）L-BFGS 算法（作者：皮果提）](https://blog.csdn.net/itplus/article/details/21897715 \"TOLINKS\")\n  > 3. [spark L-BFGS实现（作者：snaillup）](https://blog.csdn.net/snaillup/article/details/53524415 \"TOLINKS\")\n  > 4. [LBFGS.scala（作者：ScalaNLP）](https://github.com/scalanlp/breeze/blob/master/math/src/main/scala/breeze/optimize/LBFGS.scala \"TOLINKS\")\n  > 5. [LBFGS方法推导（作者：慢慢的回味）](https://liuxiaofei.com.cn/blog/lbfgs方法推导/#lbfgs方法推导 \"TOLINKS\")\n\n\n***\n\n# 3. Logistic优化求解算法\n\nLogistic 回归采用 Logistic 损失 / 交叉熵损失：\n\n$\nL(y, \\mu (X)) = - y \\log (\\mu (X)) - (1 - y) \\log (1 - \\mu (X))\n$\n\n其中 $y$ 为真值， $\\mu (X)$ 为预测值为 1 的概率。\n\n与其他机器学习一样，Logistic 回归的目标函数也包括两项：训练集上的损失和 + 正则项。\n\n$\nJ(W; \\lambda) = \\sum^N_{i = 1} L(y_i, \\mu (X_i; W)) + \\lambda R(W)\n$\n\n  > ※ 注 | 由于 L1 正则在零点不可导，因此当正则项中含有 L1 正则时，不能直接使用基于梯度、Hessian 矩阵的优化求解算法，而通常使用坐标轴下降法求解，或也可使用次梯度法。\n\n在给定正则参数 $\\lambda$ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W, \\lambda)$，取得最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W, \\lambda)} {\\partial W} = 0$。\n\n与线性回归模型不同的是，Logistic 回归模型的参数无法用解析法求解，因此可使用迭代法逼近求解。\n\n其中一阶近似有与梯度相关的几个算法：\n\n  - 梯度下降（Logistic 使用梯度下降法收敛速度较慢）\n  - 随机梯度下降（SGD）\n  - 随机平均梯度法（SAG）\n  - 随机平均梯度法改进版（SAGA）\n  - 共轭梯度\n  - 坐标轴下降\n\n二阶近似有：\n\n  - 牛顿法\n  - 拟牛顿法（BFGS、L-BFGS）\n\n观察目标函数的损失和部分：\n\n$\nJ_1 (W) = \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)\n$\n\n<br/>\n\n## 3.1 梯度\n\n最优化问题的求解离不开梯度的计算，由于目标函数中包含了 $\\mu$，即 Sigmoid 变换，记 $\\mu_i = \\mu (X_i; W) = \\sigma (W^T X_i)$，令 $z_i = W^T X_i$，根据复合函数的求导，$\\dfrac {\\partial \\mu_i} {\\partial W}$ 的求解如下：\n\n$\n\\begin{aligned}\n\\dfrac {\\partial \\mu_i} {\\partial W} &= \\dfrac {\\partial \\sigma (W^T X_i)} {\\partial W} = \\dfrac {\\partial \\sigma {z_i}} {\\partial W}\n\\\\ \n&= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}\n\\end{aligned}\n$\n\n其中 ① 复合函数外层 $\\sigma (z_i)$ 求导：\n\n$\n\\begin{aligned}\n\\dfrac {d \\sigma (z_i)} {d z_i} &= \\dfrac {d (\\dfrac {1} {1 + e^{- z_i}})} {d z_i}\n\\\\ \n&= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times \\dfrac {d (1 + e^{- z_i})} {d z_i}\n\\\\ \n&= - \\dfrac {1} {(1 + e^{- z_i})^2} \\times (- e^{- z_i})\n\\\\ \n&= \\dfrac {1} {(1 + e^{- z_i})^2} \\times (e^{- z_i})\n\\\\ \n&= \\dfrac {1} {1 + e^{- z_i}} \\times \\dfrac {(1 + e^{- z_i}) - 1} {1 + e^{- z_i}}\n\\\\ \n&= \\sigma (z_i) \\times (1 - \\sigma (z_i))\n\\end{aligned}\n$\n\n② 复合函数内层 $z_i$ 求导：\n\n$\n\\dfrac {\\partial z_i} {\\partial W} = \\dfrac {\\partial (W^T X_i)} {\\partial W} = X_i\n$\n\n综合上述 2 式得：\n\n$\n\\begin{aligned}\n\\dfrac {\\partial \\mu_i} {\\partial W} &= \\dfrac {d \\sigma (z_i)} {d z_i} \\dfrac {\\partial z_i} {\\partial W}\n\\\\ \n&= \\sigma (z_i) \\times (1 - \\sigma (z_i)) \\times X_i\n\\\\ \n&= \\mu_i \\times (1 - \\mu_i) \\times X_i\n\\end{aligned}\n$\n\n回到目标函数梯度，将上式代入求导得：\n\n$\n\\begin{aligned}\nJ_1 (W) &= \\sum^N_{i = 1} \\left( - y_i \\log (\\mu (X_i; W)) - (1 - y_i) \\log (1 - \\mu (X_i; W)) \\right)\n\\\\ \n&= \\sum^N_{i = 1} \\left( - y_i \\log \\mu_i - (1 - y_i) \\log (1 - \\mu_i) \\right)\n\\\\ \n&= - \\sum^N_{i = 1} \\left(y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right)\n\\end{aligned}\n$\n\n$\n\\begin{aligned}\ng_1 (W) &= \\nabla J_1 (W) = \\dfrac {d J_1 (W)} {d W}\n\\\\ \n&= - d \\left( \\sum^N_{i = 1} \\left( y_i \\log \\mu_i + (1 - y_i) \\log (1 - \\mu_i) \\right) \\right) / d W\n\\\\ \n&= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} \\times \\dfrac {\\partial \\mu_i} {\\partial W} + (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\times - \\dfrac {\\partial \\mu_i} {\\partial W} \\right)\n\\\\ \n&= - \\sum^N_{i = 1} \\left( y_i \\dfrac {1} {\\mu_i} - (1 - y_i) \\dfrac {1} {1 - \\mu_i} \\right) \\times \\mu_i (1 - \\mu_i) X_i\n\\\\ \n&= - \\sum^N_{i = 1} \\left( y_i (1 - \\mu_i) - (1 - y_i) \\mu_i \\right) \\times X_i\n\\\\ \n&= - \\sum^N_{i = 1} (y_i - \\mu_i) \\times X_i\n\\\\ \n&= (\\mu - y) X\n\\end{aligned}\n$\n\n整理可得 Logistic 回归损失和部分的梯度表达式：\n\n<font color=EB6D39>\n\n$$\ng_1 (W) = X^T (\\mu - y)\n$$\n\n※ 注 | 这里直接解出来的结果是 $(\\mu - y) X$，但表达式使用的是 $X^T (\\mu - y)$，对此我有些自己的理解方式如下。\n\n首先要提一下矩阵的形式。在机器学习中有一个很重要的工具包 ``numpy``，这个工具包里其中两个很重要的类：``numpy.matrix`` 和 ``numpy.array``也即矩阵和向量，通常手动创建一个矩阵的时候可以用如下方式：\n\n```python\n>>> import numpy as np\n\n>>> A = np.matrix([[1, 2], [3, 4]])\n\n>>> print(A)\n[[1 2]\n [3 4]]\n```\n\n这就可以视为一个 2 x 2 的矩阵：$\\left[ \\begin{matrix} 1 & 2 \\\\ 3 & 4 \\end{matrix} \\right]$，但是当我们如下创建一个向量时：\n\n```python\n>>> B = np.array([1, 2])\n\n>>> print(B)\n[1 2]\n\n>>> print(B.shape)\n(2,)\n```\n\n可以看到，尽管输出的 B 的形式还是 ``[1 2]``，但这是一个 2 行（也即 1 列）的向量（之所以没有标出 ``(2, 1)`` 是因为向量要么只有 1 行要么只有 1 列，防止与矩阵的 n x m 搞混了）。也就是说，默认情况下的向量是列向量，这也符合机器学习中的直觉，例如标签 y，预测值，或单个特征等都是列向量。\n\n回到原问题的梯度表达式中，假设训练数据共有 D 维特征 N 个样本，则 X 是 N x D 维的矩阵，$\\mu$ 和 y 均为 N 行的列向量，都知道矩阵的乘法 (A x B) 需要满足 A 的列数 = B 的行数时才有意义，而当作为矩阵运算 $(\\mu - y) X$ 时，$(\\mu - y)$ 列数为 1，此时无论 $X$ 是否转置，$(\\mu - y) X$ 都无意义，不能做乘法运算。因此 $\\sum^N_{i = 1} (\\mu_i - y_i) \\times X_i$ 转换为矩阵表达式时，将 $X$ 提到左乘并转置，不仅 $X^T$ 的列数恰好为 N，与 $\\mu$ 和 $y$ 的行数相等，可以做乘法，而且从矩阵的乘法运算规则上符合直观地计算过程（$X$ 转置后，每一列为一个样本，分别与每个 $(\\mu_i - y_i)$ 相乘）。\n\n因此，梯度的表达式为：$g_1 (W) = X^T (\\mu - y)$。\n\n</font>\n\n<br/>\n\n## 3.2 Hessian矩阵\n\nLogistic 损失和部分的梯度为 $g_1 (W) = X^T (\\mu - y)$，由此求解 Hessian 矩阵：\n\n$\n\\begin{aligned}\nH_1 (W) &= \\dfrac {\\partial g_1 (W)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} (\\mu_i - y_i) X_i \\right)} {\\partial W} = \\dfrac {\\partial \\left( \\sum^N_{i = 1} X^T_i (\\mu_i - y_i) \\right)} {\\partial W}\n\\\\ \n&= \\sum^N_{i = 1} X^T_i \\dfrac {\\partial (\\mu_i)} {\\partial W}\n\\\\ \n&= \\sum^N_{i = 1} X^T_i \\mu_i (1 - \\mu_i) X_i\n\\end{aligned}\n$\n\n  > ※ 注 | 说明：$\\dfrac {\\partial (a^T y)} {\\partial y} = a^T$\n\n令矩阵 $S \\triangleq \\mu_i (1 - \\mu_i)$，即 $S$ 为对角阵，对角元素为 $\\mu_i (1 - \\mu_i)$。可得 Hessian 矩阵表达式：\n\n<font color=EB6D39>\n\n$$\nH_1 (W) = X^T S X\n$$\n\n</font>\n\n<br/>\n\n## 3.3 牛顿法求解Logistic损失函数和极小值：IRLS\n\n当解得梯度 $g_1 (W) = X^T (\\mu - y)$ 和 Hessian 矩阵 $H_1 (W) = X^T S X$ 后，即可代入牛顿迭代公式中：\n\n$\n\\begin{aligned}\nW^{(t + 1)} &= W^{(t)} - H(W^{(t)})^{-1} g(W)\n\\\\ \n&= W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)\n\\\\ \n&= (X^T S^{(t)} X)^{-1} (X^T S^{(t)} X) \\times W^{(t)} - (X^T S^{(t)} X)^{-1} X^T (\\mu - y)\n\\\\ \n&= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T (\\mu - y) \\right)\n\\\\ \n&= (X^T S^{(t)} X)^{-1} \\times \\left( X^T S^{(t)} X W^{(t)} - X^T S^{(t)} {S^{(t)}}^{-1} (\\mu - y) \\right)\n\\\\ \n&= (X^T S^{(t)} X)^{-1} X^T S^{(t)} \\times \\left( X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y) \\right)\n\\end{aligned}\n$\n\n令 $z^{(t)} \\triangleq X W^{(t)} - {S^{(t)}}^{-1} (\\mu - y)$，则得到牛顿法迭代求 Logistic 损失函数和极小值的解：\n\n<font color=EB6D39>\n\n$$\nW^{(t + 1)} = (X^T S^{(t)} X)^{-1} X^T S^{(t)} z^{(t)}\n$$\n\n</font>\n\n对比线性回归 $X W = y$ 方程中最小二乘的解：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，给每个样本加权（每个样本的权重为 $S_i$）即可得加权最小二乘的解：\n\n$\n\\hat{W}_{OLS\\_weight} = (X^T S X)^{-1} X^T y\n$\n\n牛顿迭代法求得的 Logistic 损失函数和极小值的解 与 加权最小二乘的解形式类似，因此也称为 **<font color=EB6D39>迭代加权最小二乘（Iteratively Reweighted Least Squares, IRLS）</font>**，其中每个样本的权重为 $S_i = \\mu_i (1 - \\mu_i)$。而 IRLS 又通过 共轭梯度（Conjugate Gradient）法 求解，因此 Scikit-Learn 中采用牛顿法求解的优化算法为 ``'newton-cg'``。\n\n***\n\n# 4. Logistic的优化求解器Solver\n\nLogistic 回归有多种优化求解方法。当使用 L2 正则时，可采用所有优化算法，而由于 L1 正则在零点处不可导，因此次不能使用需要计算梯度 / Hessian 矩阵的方法，此时可以类似 Lasso 求解，采用坐标轴下降法。\n\nScikit-Learn 中的 Logistic 类已在：[《ML入门——Logistic回归简介》](/post/machinelearning/ml-logistic/ml-logistic-introduction/ \"TOLINKS\") 文中介绍，此处展开参数 ``solver`` 的一些可选项：\n\n'liblinear'：\n线性求解器，适用于小数据集，支持 L1 正则和 L2 正则。\n内部使用了坐标轴下降法来迭代优化损失函数，如果模型的特征非常多，希望一些不重要的特征系数归零从而让模型系数稀疏的话，可以使用 L1 正则化。在多类 Logistic 回归任务中仅支持 OvR，不支持多项分布损失（MvM），但 MVM 相对精确。\n\n'lbfgs'：\n拟牛顿法，适用于较大数据集，仅支持 L2 正则。\n支持 OvR 和 MvM 两种多类 Logistic 回归。\n\n'newton-cg'：\n牛顿法，适用于较大数据集，仅支持 L2 正则。\n每个大迭代中的加权最小二乘回归部分采用共轭梯度算法实现。支持 OvR 和 MvM 两种多类 Logistic 回归。\n\n'sag'：\n随机平均梯度下降，适用于很大（如大于 5 万）的数据集，仅支持 L2 正则。\n梯度下降法的变种，支持 OvR 和 MvM 两种多类 Logistic 回归。\n\n'saga'：\n改进的随机平均梯度下降，适用于非常大的数据集，支持 L1 正则。\n当数据量很大，且选择 L1 正则时，只能采用 'saga' 优化求解器。支持 OvR 和 MvM 两种多类 Logistic 回归。\n\n其中，'sag' 和 'saga' 只有在特征尺度大致相等时才能保证收敛，因此需要对数据做缩放（``class sklearn.preprocessing`` 可以实现如：标准化、MinMaxScaler、MaxAbsScaler 等）。在实际任务中，大部分情况下数据预处理时都最好做标准化。实际上，加正则项本身也要求对每维特征做缩放。\n\n另外，对于大数据集的训练任务，可以使用 ``SGDClassifier``，并使用 LogLoss 作为损失函数。\n\n  > ※ 注 | 若 ``SGDClassifier`` 使用 HingeLoss 作为损失函数，则为实现随机梯度下降的 SVM。在回归任务中还有 ``SDGRegressor``。","tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"],"categories":["MachineLearning","LogisticRegression"]},{"title":"ML入门——Logistic回归简介","url":"/post/machinelearning/ml-logistic/ml-logistic-introduction/","content":"<!-- more -->\n\n***\n\n # 1. Logistic回归简介\n\n 回归任务和分类任务都属于有监督学习（Supervised Learning），其训练数据的格式为：$D = \\{ X_i, y_i \\}^N_{i = 1}$。回归任务中 $y_i \\in R$，而分类任务中 $y_i \\in C, C = \\{ 1, \\cdots c \\}$，任务目标都为：学习一个从输入 $X$ 到输出 $y$ 的映射 $f$。分类任务的图示如下：\n\n<center>\n\n![分类任务图示](/post_files/machinelearning/ml-logistic/ml-logistic-introduction/classify_demo.png \"TOPICS\")\n\n</center>\n\n典型的分类任务有：垃圾邮件过滤、手写数字/文本识别、语音识别、人脸识别、医疗诊断、金融风控等。\n\n贝努力（Bernoulli）分布：$y \\sim Bernoulli(\\mu)$，其中 $\\mu$ 为分布的期望，表示 $y = 1$ 的概率。则该分布的概率密度函数为：\n\n$\np(y; \\mu) = \\mu^y (1 - \\mu)^{(1 - y)}\n$\n\n以两类分类为例。两类分类任务中，假设样本的输出为 $y_i \\in \\{ 0, 1 \\}$，当给定输入 $X$ 的情况下，输出 y 符合贝努力分布：\n\n$\ny | X \\sim Bernoulli(\\mu (X))\n$\n\n其中期望 $\\mu (X)$ 表示在给定 $X$ 的情况下，$y = 1$ 的概率。则其概率密度函数为：\n\n$\np(y | X; \\mu) = \\mu (X)^y (1 - \\mu (X))^{1 - y}\n$\n\n$\np(y = 1) = \\mu(X), \\quad p(y = 0) = 1 - \\mu (X)\n$\n\n<br/>\n\n## 1.1 Sigmoid函数\n\n当选择最简单的线性模型来表示期望 $\\mu (X)$ 时，即 $\\mu (X) = W^T X$，期望 $\\mu(X)$ 表示 $y = 1$ 的概率，因此 $\\mu (X) \\in [0, 1]$，而 $W^T X \\in (- \\infty, + \\infty)$，因此需要把 $(- \\infty, + \\infty)$ 缩放到 $[0, 1]$：Sigmoid 函数。\n\nSigmoid 函数表达式为：$\\sigma (z) = \\dfrac {1} {1 + e^{-z}}$，其图形如下：\n\n<center>\n\n![Sigmoid 函数](/post_files/machinelearning/ml-logistic/ml-logistic-introduction/sigmoid.png \"TOPICS\")\n\n</center>\n\n**Sigmoid 函数亦被称为 Logistic 函数或 Logit 函数，Logistic 回归亦被称为 Logit 回归。**\n\n※ 注 | LogisticRegression 虽然名字上用了“回归”，但实际上是分类算法。\n\n使用 Sigmoid 函数对 $W^T X$ 缩放后得到：\n\n$\np(y = 1 | X) = \\mu (X) = \\sigma (W^T X)\n$\n\n$\np(y = 0 | X) = 1 - \\mu (x) = 1 - \\sigma (W^T X)\n$\n\n定义一个事件的几率（Odd，与概率 Probability 不是一个概念）为该事件发生的概率与不发生的概率的比值：\n\n$\n\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\dfrac {\\sigma (W^T X)} {1 - \\sigma (W^T X)} = \\dfrac {\\dfrac {1} {1 + e^{- W^T X}}} {\\dfrac {e^{- W^T X}} {1 + e^{- W^T X}}} = e^{W^T X}\n$\n\n两边同取 $\\log$ 运算，得到 **对数几率**：$\\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = \\log (e^{W^T X}) = W^T X$。\n\n当 $p(y = 1 | X) > p(y = 0 | X)$ 时，如果取最大后验概率，即输入 $X$ 的类别取 $y = 1$，则有：\n\n$\n\\dfrac {p(y = 1 | X)} {p(y = 0 | X)} > 0, \\Longrightarrow \\log \\dfrac {p(y = 1 | X)} {p(y = 0 | X)} = W^T X > 0\n$\n\n  ① 当 $W^T X > 0$ 时，$p(y = 1 | X) > p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 1$。\n\n  ② 当 $W^T X < 0$ 时，$p(y = 1 | X) < p(y = 0 | X)$，因此可以认为输入 $X$ 对应的类别为 $y = 0$。\n\n  ③ 当 $W^T X = 0$ 时，$p(y = 1 | X) = p(y = 0 | X)$，输入 $X$ 对应的类别可以是 1 或 0，此时 $X$ 位于决策面上，可以将 $X$ 分类到任意类别，或拒绝作出判断。\n\n令决策函数 $f(X) = W^T X$，其根据 $W^T X$ 的符号将输入控件 $X$ 分出两个区域。由于 $W^T X$ 为线性函数，因此 Logistic 回归模型是一个线性分类器。一个线性分类模型实例如下：\n\n<center>\n\n![线性分类实例](/post_files/machinelearning/ml-logistic/ml-logistic-introduction/linear_classify.png \"TOPICS\")\n\n</center>\n\n<br/>\n\n## 1.2 决策边界\n\n更一般地：根据需要划分的类别，分类器将输入控件 $X$ 划分为一些互不相交的区域。这些区域的边界叫决策边界（Decision Boundaries）。根据预测函数 $f$ 的不同，会使得决策面或光滑、或粗糙。\n\n当决策面是输入 $X$ 的线性函数时，称为线性决策面，对应的分类器就是线性分类器。\n\n分类器为每个类别分配一个判别函数，根据判别函数来判断一个新样本属于该类别的可能性，然后将新样本归类为可能性最大的一类。假设有 C 个类别，则对应有 C 个判别函数：$\\delta_c (X), c \\in \\{ 1, \\cdots, C \\}$。\n\n对一个新样本 $X$，通常是找到最大的 $\\delta_c (X)$，即该样本的类别为：\n\n$$\n\\hat{y} = \\arg_c \\max \\delta_c (X)\n$$\n\n判别函数 $\\delta_c (X)$ 和  $\\delta_k (X)$ 相等的点的集合，就是分类 C 和分类 K 之间的决策面：\n\n<center>\n\n![分类决策面](/post_files/machinelearning/ml-logistic/ml-logistic-introduction/decision_separating_hyperplane.png \"TOPICS\")\n\n</center>\n\n例如两类分类问题中，决策函数 $f_1 = p(y = 1 | X)$ 即为类别 $y = 1$ 的判别函数，决策函数 $f_0 = p(y = 0 | X)$ 即为类别 $y = 0$ 的判别函数。若对一新样本 $X$，有 $f_1 (X) > f_0 (X)$，则新样本 $X$ 被分入类别 $y = 1$。\n\n***\n\n# 2. Logistic损失函数\n\n<br/>\n\n## 2.1 负log似然损失\n\n以两类分类问题为例，直观地，可以定义一种损失：0 / 1 损失，预测类别正确时预测损失为 0，否则为 1。记为：\n\n$\nL(y, \\hat{y}) = \\left \\{\n\\begin{aligned}\n0, && {y = \\hat{y}}\n\\\\ \n1, && {y \\ne \\hat{y}}\n\\end{aligned}\n\\right.\n$\n\n但 0 / 1 损失不连续，优化计算不方便。因此需要寻找其他 **替代损失函数（Surrogate Loss Function）**。替代损失函数应当符合几个特征：\n\n  - 通常是凸函数，计算方便。\n  - 与 0 / 1 损失函数具有等效性。\n\n下图列举了几种不同的损失函数：\n\n<center>\n\n![多种损失函数图](/post_files/machinelearning/ml-logistic/ml-logistic-introduction/some_loss_functions.png \"TOPICS\")\n\n</center>\n\n图中横轴为 $y \\hat{y}$ 取值，纵轴为损失。\n\n定义两类分类中，真值 $y$ 只有两种取值：$y \\in \\{ 1, -1 \\}$，而预测值可取连续值：$\\hat{y} \\in \\{ - \\infty, + \\infty \\}$，以符号区分预测值的预测类别（正数对应类别 1，负数对应类别 -1），当 $y$ 和 $\\hat{y}$ 符号相同时（即 $y \\hat{y} > 0$，对应图中横坐标右半部分）表示预测正确，此时损失为 0。反之亦然。\n\n可以看出，浅蓝色曲线 L2 损失并不能很好地代替 0 / 1 损失，因此优化 L2 损失并不能很好地优化模型的准确度。\n\n整理 Logistic 回归模型：$y | X \\sim Bernoulli (\\mu (X))$，对应的概率密度函数为：\n\n$\np(y | X; \\mu (X)) = \\mu (X)^y (1 - \\mu (X))^{(1 - y)}\n$\n\n其中，$\\mu (X)$ 是线性模型经过 Sigmoid 变化而来：$\\mu (X) = \\sigma (W^T X)$。\n\nLogistic 的似然函数为：$likelihood (f) = p(D) = \\prod^N_{i = 1} p(y_i | x_i)$，则 $\\log$ 似然函数为：\n\n$\n\\begin{aligned}\nl(\\mu) &= \\log p(D) = \\log \\prod^N_{i = 1} p(y_i | x_i) = \\sum^N_{i = 1} \\log p(y_i | x_i)\n\\\\ \n&= \\sum^N_{i = 1} \\log \\left( \\mu (X_i)^{y_i} (1 - \\mu (X_i))^{(1 - y_i)} \\right)\n\\\\ \n&= \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i))\n\\end{aligned}\n$\n\n取极大似然估计        ：\n\n$\n\\begin{aligned}\n\\max l(\\mu) &= - \\min l(\\mu)\n\\\\ \n&= \\min - \\left( \\sum^N_{i = 1} y_i \\log (\\mu (X_i)) + (1 - y_i) \\log (1 - \\mu (X_i)) \\right)\n\\\\ \n&= \\min \\sum^N_{i = 1} - y_i \\log (\\mu (X_i)) - (1 - y_i) \\log (1 - \\mu (X_i))\n\\end{aligned}\n$\n\n**<font color=red>因此极大似然估计等价于最小训练集上的负 $\\log$ 损失。而负 $\\log$ 似然损失亦被称为 Logistic 损失。</font>**\n\n<br/>\n\n## 2.2 交叉熵损失\n\nLogistic 损失亦被称为 **交叉熵损失（Corss Entropy Loss, CE）**。\n\n交叉熵损失：两个分布之间的差异（已知真实分布的情况下，预测分布与真实分布之间的差异）。定义交叉熵 $H(p, q)$ 如下：\n\n$$\n\\begin{aligned}\nH(p, q) &= \\sum_x p(x) \\log (\\dfrac {1} {q(x)})\n\\\\ \n&= - \\sum_x p(x) \\log (q(x))\n\\end{aligned}\n$$\n\n假设预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，即 $\\hat{y} \\sim Bernoulli (\\mu (X))$，则预测值 $\\hat{y} = 0$ 的概率为 $1 - \\mu (X)$。\n\n（1）假设已知真值 $y = 1$，即 $y | X \\sim Bernoulli (1)$，即在已知真值 $y = 1$ 的情况下，$y$ 取 1 的概率 $\\mu = p(y = 1) = 1$，因此 $y = 0$ 的概率 $p(y = 0) = 0$。则这两个分布之间的交叉熵为：\n\n$\n\\begin{aligned}\nCE(y = 1, \\hat{y}) &= - \\sum_y p(y | X) \\log p(\\hat{y} | X)\n\\\\ \n&= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)\n\\\\ \n&= - \\log \\mu (X)\n\\end{aligned}\n$\n\n（2）同理，假设已知真值 $y = 0$，即 $y | X \\sim Bernoulli (0)$，因此 $\\mu = p(y = 1) = 0$，$p(y = 0) = 1$，此时这两个分布之间的交叉熵为：\n\n$\n\\begin{aligned}\nCE(y = 0, \\hat{y}) &= - \\sum_y p(y | X) \\log p(\\hat{y} | X)\n\\\\ \n&= \\left( - p(y = 1 | X) \\log p(\\hat{y} = 1 | X) \\right) + \\left( - p(y = 0 | X) \\log p(\\hat{y} = 0 | X) \\right)\n\\\\ \n&= - \\log (1 - \\mu (X))\n\\end{aligned}\n$\n\n整理合并得：\n\n$\nCE(y, \\hat{y}) = \\left \\{\n\\begin{aligned}\n& - \\log \\mu (X), && {y = 1}\n\\\\ \n& - \\log (1 - \\mu (X)), && {Otherwise}\n\\end{aligned}\n\\right.\n$\n\n定义 $p_t$（Probability of Ground Truth Class）为：\n\n$\np_t = \\left \\{\n\\begin{aligned}\n& \\mu (X), && {if (y = 1)}\n\\\\ \n& 1 - \\mu (X), && {Otherwise}\n\\end{aligned}\n\\right.\n$\n\n则可得到交叉熵损失简洁表达式：\n\n$$\nCE(y, \\hat{y}) = - \\log (p_t)\n$$\n\n交叉熵损失与 $p_t$ 的关系曲线如下：\n\n<center>\n\n![交叉熵损失曲线](/post_files/machinelearning/ml-logistic/ml-logistic-introduction/cross_entropy_and_pt.png \"TOPICS\")\n\n</center>\n\n**※ 注 | 对 $p_t$ 的理解：根据 $p_t$ 的表达式，当真实值 $y = 1$ 时，$p_t = \\mu (X)$。由于 $\\mu (X)$ 表示的是预测值 $\\hat{y} = 1$ 的概率，因此 <font color=EB6D39>$p_t$ 即表示预测分布接近真实分布的概率</font>。因此 $p_t$ 越大，表示预测越准确，同时对应的交叉熵损失 $Loss = - \\log (p_t)$ 也就越小，与图中曲线含义相同。**\n\n***\n\n# 3. Logistic正则项\n\nLogistic 回归采用 Logistic 损失 / 交叉熵损失，由于预测值 $\\hat{y} = 1$ 的概率为 $\\mu (X)$，因此可使用 $\\mu (X)$ 表示 $\\hat{y}$：\n\n$\n\\begin{aligned}\n& L(y, \\mu(X)) = -y \\log (\\mu (X)) - (1- y) \\log (1 - \\mu (X))\n\\\\ \n& \\mu (X) = \\sigma (W^T X)\n\\end{aligned}\n$\n\nLogistic 回归的目标函数同样包括训练集上的损失和与正则项，正则项同样可选 L1 正则、L2 正则、或 L1 + L2 正则。\n\n假设有一个两类分类任务，且训练样本完全可分（即所有同类样本均可被分对），为了使 Logistic 损失和最小（完全可分时最小损失和即为 0），则对每个样本有：$L(y_i, \\mu (x_i)) = 0$。当想要使得每个样本损失均为 0 时，即：\n\n  > ① 对于每个真实值 $y_i = 1$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 1（必定预测分类为 1），也即 $\\mu (X) = 1$。\n  > \n  > ② 而对于每个真实值 $y_i = 0$ 的样本，其预测值 $\\hat{y} = 1$ 的概率为 0（不可能预测分类为 1），也即 $\\mu (X) = 0$。\n\n由于 $\\mu (X) = \\sigma (W^T X)$ 是将线性模型 $W^T X$ 经过 Sigmoid 变化而来，Sigmoid 图形如下：\n\n<center>\n\n![Sigmoid 函数](/post_files/machinelearning/ml-logistic/ml-logistic-introduction/sigmoid.png \"TOPICS\")\n\n</center>\n\n**<font color=EB6D39>当 $\\mu (X)$ 取 $\\pm 1$ 时，$W^T X$ 取 $\\pm \\infty$，也即 $|W_j| = \\infty$，这样的模型是无意义的。</font>**\n\n<center>\n\n**<font color=red>因此 Logistic 回归必须加正则！</font>**\n\n</center>\n\n※ 注 | Scikit-Learn 中实现的 Logistic 回归 ``LogisticRegression`` 默认为 L2 正则。\n\n与 SVM 类似的是，Logistic 回归的超参数 $C$ 加在损失函数上：\n\n$$\nJ(W; \\lambda) = C \\sum^N_{i = 1} L(y_i, \\mu (x_i; W)) + R(W)\n$$\n\n***\n\n# 4. Scikit-Learn中的Logistic\n\nScikit-Learn 中实现了 3 种 Logistic 回归：\n\n  - ``LogisticRegression``\n  - ``LogisticRegressionCV``\n  - ``SGDClassifier``\n\n① ``LogisticRegression`` 是最原始的 Logistic 回归模型，超参数调优时需要手动搭配 ``GridSearchCV`` 使用。② ``LogisticRegressionCV`` 是 Scikit-Learn 提供的已集成了交叉验证的 Logistic 回归模型，可以直接使用内置的交叉验证对超参数调优。③ ``SGDClassifier``（随机梯度下降分类）则是在样本数很大（样本数 $N > 10^5$，特征数 $M > 10^5$）时效果更好。\n\n<br/>\n\n## 4.1 LogitsicRegression\n\n```python\n# class sklearn.linear_model.LogisticRegression\n\nLogisticRegression(penalty='l2',\n                   dual=False,\n                   tol=0.0001,\n                   C=1.0,\n                   fit_intercept=True,\n                   intercept_scaling=1,\n                   class_weight=None,\n                   random_state=None,\n                   solver='liblinear',\n                   max_iter=100,\n                   multi_class='ovr',\n                   verbose=0,\n                   warm_start=False,\n                   n_jobs=1)\n```\n\n**（1）``LogitsicRegression`` 的参数**\n\n``penalty``：\n惩罚函数 / 正则函数，默认：'L2'。\n支持 L2 正则和 L1 正则。选择 L1 正则时优化器可选 'liblinear' 和 'saga'。\n\n``dual``：\n是否是对偶问题求解，默认：``False``。\n是原问题（primal）还是对偶问题（dual）求解。对偶问题只支持 L2 正则和 'liblinear' 优化器。\n\n``tol``：\n迭代终止判据的误差范围，默认：$10^{-4}$。\n\n``C``：\n交叉熵损失函数系数，默认：1。\n\n``fit_intercept``：\n是否在决策函数中加入截距项。默认：``True``。\n如果数据已经中心化，则不需要拟合截距项。\n\n``intercept_scaling``：\n截距缩放因子。\n当 ``fit_intercept`` 为 ``True`` 且优化器 ``solver`` 设置为 ``liblinear`` 时有效。输入为 ``[X, self.intercept_scaling]``，即对输入特征插入 1 维常数项。由于增加的常数项系数也受到 L1 / L2 正则的惩罚，因此要适当增大常数项。\n\n``class_weight``：\n不同类别样本的权重。默认：``None``。\n可指定每类样本权重，或设置为 'balanced'，则每类样本权重与该类别样本数比例成反比。\n\n``random_state``：\n随机种子，默认：``None``。\n\n``solver``：\n优化求解算法，默认：'liblinear'。\n可选：'newton-cg'，'lbfgs'，'liblinear'，'sag'，'saga'。\nL1 正则优化器仅可选 'liblinear' 和 'saga'，L2 正则可使用所有优化器。\n\n``max_iter``：\n最大迭代次数，默认：100。\n仅当 ``solver`` 设置为 'newton-cg'，'sag'，或 'lbfgs' 时有效。\n\n``multi_class``：\n多类分类处理策略，默认：'ovr'。\n可选：'ovr'，'multinomial'。\n'ovr'：One-Versus-Rest，一对多。将 C 类分类问题转化为 C 个两类分类问题，每一次分类当前类别样本为正样本，其余样本视为负样本。\n'multinomial'：即 softmax 分类器。使用 'multinomial' 时，优化器仅可选 'newton-cg'，'lbfgs'，'sag'。\n※ OVO：One-Versus-One，一对一。\nOVR 相对简单但分类效果相对略差。MVM 分类相对精确，但分类速度比 OVR 慢。\n\n``verbose``：\n是否详细输出。\n\n``warm_start``：\n是否热启动，默认：``False``。\n``solver`` 设置为 'liblinear' 时无效。\n\n``n_jobs``：\n多线程控制，默认：-1.\n取 -1 时算法自动检测可用 CPU 核，并使用全部核。\n\n**（2）``LogitsicRegression`` 的属性**\n\n``coef``：\n回归系数 / 权重。\n与特征的维数相同。如果是多任务回归，标签 $y$ 为 m 维数组，则回归系数也为 m 维数组。\n\n``intercept_``：\n截距项。\n\n``n_iter_``：\n每个类的迭代此时。\n\n**（3）``LogitsicRegression`` 的方法**\n\n``fit(X, y[, sample_weight])``：\n模型训练。\n参数 X，y 为训练数据，也可以通过 ``sample_weight`` 设置每个样本的权重。\n\n``predict(X)``：\n返回 X 对应的预测值（类别标签）。\n\n``predict_log_proba(X)``：\n返回 X 对应的预测值（每个类别对应的概率的 $log$ 值）。\n\n``predict_proba(X)``：\n返回 X 对应的预测值（每个类别对应的概率）。\n\n``score(X, y[, sample_weight])``：\n评估模型预测性能，返回模型预测的正确率。\n\n``decision_function(X)``：\n预测的置信度（样本到分类超平面的带符号距离）。\n在分对的情况下，正样本得到的应为正值，负样本得到的应为负值。\n\n``densify()``：\n如果之前将系数矩阵变成了稀疏模式，再将其变回稠密模式（``fit`` 函数要求系数矩阵为稠密模式）。\n\n``sparsify()``：\n将系数矩阵变成了稀疏模式。\n\n<br/>\n\n## 4.2 LogisticRegressionCV\n\n```python\n# class sklearn.linear_model.LogisticRegressionCV\n\nLogisticRegressionCV(Cs=10,\n                     fit_intercept=True,\n                     cv=None,\n                     dual=False,\n                     penalty='l2',\n                     scoring=None,\n                     solver='lbfgs',\n                     tol=0.0001,\n                     max_iter=100,\n                     class_weight=None,\n                     n_jobs=1,\n                     verbose=0,\n                     refit=True, i\n                     ntercept_scaling=1.0,\n                     multi_class='ovr',\n                     random_state=None)\n```\n\n**（1）``LogisticRegressionCV`` 的参数**\n\n``Cs``：\n超参数调优范围。\n在区间 $[10^{-4}, 10^4]$ 的 $log$ 域均匀取 Cs 个值作为正则参数 C 的搜索空间。\n\n``cv``：\n交叉校验划分策略。\n\n``solver``：\n与 ``LogisticRegression`` 相同，但默认为 'lbfgs'。\n\n``multi_class``：\n对多类分类问题，采用的是 'ovr' 的方式，用交叉验证得到每个类的最佳正则参数。\n\n其余参数与 ``LogisticRegression`` 相同。\n\n**（2）``LogisticRegressionCV`` 的属性**\n\n与 ``LogisticRegression`` 相同。\n\n**（3）``LogisticRegressionCV`` 的方法**\n\n与 ``LogisticRegression`` 相同。\n\n<br/>\n\n## 4.3 SGDClassifier\n\n```python\n# class sklearn.linear_model.SGDClassifier\n\nSGDClassifier(loss='hinge',\n              penalty='l2',\n              alpha=0.0001,\n              l1_ratio=0.15,\n              fit_intercept=True,\n              max_iter=None,\n              tol=None,\n              shuffle=True,\n              verbose=0,\n              epsilon=0.1,\n              n_jobs=1,\n              random_state=None,\n              learning_rate='optimal', \n              ta0=0.0,\n              power_t=0.5,\n              class_weight=None,\n              warm_start=False,\n              average=False,\n              n_iter=None)\n```\n\n**（1）``SGDClassifier`` 的参数**\n\n``lose``：\n损失函数。\n可选：'hinge'（合页损失，SVM 中常用），'log'（负 $log$ 似然损失，即 Logistic 回归使用的损失），'modified_huber'（对噪声不损失），'squared_hinge'，'perceptron'，还有回归中使用的损失函数：'squared_loss'，'huber'，'epsilon_insensitive'，'squared_epsilon_insensitive'。\n使用回归的方式也可以实现分类。在分类中，$f(X)$ 表示样本输入 $X$ 取某个类别的概率，当使用回归的方式进行分类时，$f(X)$ 为一具体数值，可通过数值判断分类。例如二分类任务中，对 $f(X) > 0.5$，分为类别 1，对 $f(X) < 0.5$，分为类别 0。\n\n``epsilon``：\n额外参数项。\n某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）所需要的额外参数。\n\n``penalty``：\n正则项。\n可选：'none'，'l2'，'l1'，'elasticnet'（弹性网络，L1 + L2）。\n\n\n``alpha``：\n正则惩罚系数。\n对应为目标函数中的 $\\lambda$，也用于学习率的计算。\n\n``l1_ratio``：\nL1 正则比例。\n仅当正则项为 'elasticnet' 时有效，用于控制 L1 正则所占比例。\n\n优化相关参数如下：\n\n``max_iter``：\n最大迭代次数（访问所有训练数据的次数 / epoches 次数），默认：5。\nSGD 在接近 $10^6$ 的训练样本时收敛，因此可将 ``max_iter`` 设置为 ``np.ceil(10^6 / N)``（$\\dfrac {10^6} {N}$），其中 N 为训练集样本数。\n\n``tol``：\n迭代停止条件。\n若非 ``None``，则当 (loss > previous_loss - tol) 时迭代终止。\n\n``learning_rate``：\n学习率。\n对应为迭代优化算法中的 $\\alpha$。\n可选：'constant'，'optimal'，'invscaling'。\n'constant'：eta = eta0\n'optimal'：eta = 1.0 / (alpha * (t + t0))\n'invscaling'：eta = eta0 / pow(t, power_t)\n\n``shuffle``：\n每轮 SGD 之前是否洗牌。\n默认为 ``True``。\n\n``warm_start``：\n是否热启动。\n随机梯度下降中初始值可以是之前的训练结果，支持在线学习。初始值可在 ``fit()`` 函数中作为参数传递。\n\n``average``：\n是否采用平均随机梯度下降法（随机梯度下降法的改进）ASGD。\n\n其他参数与 ``LogisticRegression`` 相同。\n\n关于“随机梯度下降实现”的参考文献：\n\n> - \"Stochastic Gradient Descent\" L. Bottou - Website, 2010\n> - \"The Tradeoffs of Large Scale Machine Learning\" L. Bottou - Website, 2011","tags":["AI","MachineLearning","人工智能","机器学习","Logistic回归"],"categories":["MachineLearning","LogisticRegression"]},{"title":"ML入门——损失和正则的概率解释","url":"/post/machinelearning/ml-linear/ml-linear-loss-regular/","content":"<!-- more -->\n\n***\n\n结论：最小 L2、L1 损失均等价于极大似然估计；带正则的回归等价于贝叶斯估计。\n\n# 1. 损失函数的概率解释\n\n<br/>\n\n## 1.1 L2损失与极大似然估计\n\n对采用 L2 损失的模型，目标函数为：\n\n$$\nJ(W) = RSS(W) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2\n$$\n\n在回归任务重，令模型中的真实值 $y_i$ 和预测值 $\\hat{y_i}$ 之间的差异为白噪声 $\\varepsilon$，假设噪声（随机变量）$\\varepsilon$ 符合 0 均值的正态分布：$\\varepsilon \\sim N(0, \\sigma^2)$。\n\n用 $y | X$ 表示给定输入 $X$ 的情况下的输出 $y$，当输入$X$ 给定时，$f(X) = W^T X$ 是一个常数，因此 $y = f(X) + \\varepsilon$ 也是一个随机变量：$y | X \\sim N(f(X), \\sigma^2)$\n\n※ 注 | 随机变量加上一个常数，只改变分布的均值，不改变分布的方差。\n\n对于正态分布，其概率密度函数为：\n\n$$\np(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {\\left( y - f(X) \\right)^2} {2 \\sigma^2} \\right)\n$$\n\n※ 注 | 很多分布的概率密度函数为指数函数形式，因此通常取 log 运算，log 函数为单调函数，对似然函数取 log 不影响极值点位置。\n\n似然函数（Likelihood）为：$likelihood(f) = p(D)$，定义为数据出现的概率。在回归任务中，通常假定所有数据都是独立同分布的，因而对所有数据 $D$，其联合概率等于每个独立样本概率的积：\n\n$$\np(D) = \\prod^N_{i = 1} p(y_i | x_i)\n$$\n\n对似然函数取 $\\log$ 运算（$\\log$ 是单调函数，不改变极值点位置，与似然函数等价）得到 $\\log$ 似然函数（积取 log 等于 log 再取和，）即为：\n\n$$\n\\begin{aligned}\nl(f) &= \\log p(D) = \\sum^N_{i = 1} \\log p(y_i | x_i)\n\\\\ \n&= \\sum^N_{i = 1} \\log \\left[ \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]\n\\\\ \n&= \\sum^N_{i = 1} \\log \\left[ (2 \\pi)^{- \\dfrac {1} {2}} \\cdot \\sigma^{-1} \\cdot \\exp \\left( - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right) \\right]\n\\\\ \n&= \\sum^N_{i = 1} \\left[ - \\dfrac {1} {2} \\log (2 \\pi) - \\log \\sigma - \\dfrac {(y_i - f(x))^2} {2 \\sigma^2} \\right]\n\\\\ \n&= - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x))^2} {2 \\sigma^2}\n\\end{aligned}\n$$\n\n去掉 $l(f)$ 中常数项（不影响极值点位置），当 $l(f)$ 取最大值时可得 **<font color=EB6D39>极大似然估计</font>**：\n\n$$\n\\begin{aligned}\n& \\max l(f)\n\\\\ \n= & \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)\n\\\\ \n= & \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)\n\\\\ \n= & \\dfrac {1} {2 \\sigma^2} \\min \\sum^N_{i = 1} (y_i - f(x_i))^2\n\\end{aligned}\n$$\n\n同样，去掉系数 $\\dfrac {1} {2 \\sigma^2}$ 不影响极值点位置，而其中的似然项\n\n$\n\\sum^N_{i = 1} (y_i - f(x_i))^2 = RSS(f)\n$\n\n恰好 是残差平方和 / 训练集上的 L2 损失和，因此：\n\n$$\n\\begin{aligned}\n\\max l(f) &\n\\\\ \n极大似然估计 &\n\\end{aligned}\n\\begin{aligned}\n\\Longleftrightarrow \\min \\sum^N_{i = 1} (y_i - f(x_i))^2 \\Longleftrightarrow\n\\\\ \n\\quad\n\\end{aligned}\n\\begin{aligned}\n& \\min RSS(f)\n\\\\ \n& 最小二乘\n\\end{aligned}\n$$\n\n<center>\n\n**<font color=red>极大似然估计等价于最小二乘。</font>**\n\n</center>\n\n又由于 log 似然即：$l(f)$，与极大似然有：\n\n$$\n\\begin{aligned}\n& \\max l(f)：极大似然估计\n\\\\ \n= & \\max \\left( - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)\n\\\\ \n= & \\min \\left( \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i))^2} {2 \\sigma^2} \\right)\n\\\\ \n= & \\min - l(f)：负 log 似然最小\n\\end{aligned}\n$$\n\n<center>\n\n**<font color=red>极大似然估计等价于负 log 似然最小。</font>**\n\n</center>\n\n因此负 log 似然也被成为一种损失函数：负 log 似然损失。\n\n  - L2 损失是负 log 似然损失。\n  - 分类任务中的 Logistic 回归使用的也是负 log 似然损失。\n\n将上述极大似然估计推广为一般形式：\n\n$$\nl(\\theta) = \\log (D | \\theta) = \\sum^N_{i = 1}\\log p(X_i | \\theta)\n$$\n\n其中 $\\theta$ 为需要求解的分布的参数，$X$ 为每条样本。\n\n统计中需要根据观测数据 $D= \\{ X_i \\}^N_{i = 1}$ 估计分布的参数 $\\theta$，一种常用的参数估计即为 **<font color=EB6D39>极大似然估计</font>**，即，使得 log 似然函数 $l(f)$ 最大时的 $\\theta$ 作为估计值：\n\n$$\n\\hat{\\theta} = \\arg_{\\theta} \\max l(\\theta)\n$$\n\n<br/>\n\n## 1.2 L1 损失与极大似然估计\n\nL1 损失最小也等价于极大似然估计，此时噪声模型为 Laplace 分布：\n\n$$\n\\varepsilon \\sim Laplace(\\mu, b) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|x - \\mu|} {b} \\right)\n$$\n\n***\n\n# 2. 正则项的概率解释\n\n<br/>\n\n## 2.1 L2正则与正态分布先验\n\n在损失函数的概率解释中已经推出：假设数据产生模型为\n\n$\ny = f(X) + \\varepsilon, \\quad \\varepsilon \\sim N(0, \\sigma^2)\n$\n\n则 $y | X \\sim N(f(X; W), \\sigma^2)$，即\n\n$\np(y | X) = \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y - f(X; W))^2} {2 \\sigma^2} \\right)\n$\n\n**<font color=EB6D39>似然函数为：</font>**\n\n$$\n似然 \\quad likelihood(f) = p(D | W) = \\prod^N_{i = 1} p(y_i | x_i) = \\prod^N_{i = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\sigma} \\exp \\left( - \\dfrac {(y_i - f(x_i; W))^2} {2 \\sigma^2} \\right)\n$$\n\n为了模型不太复杂，增加一个参数的先验：$w_j$ 的值不能太大，也即 $w_j$ 取 0 附近的值概率更高，假设 $W$ 为独立同分布，此时可用正态分布来表示 $w_j$ 的取值分布：$w_j \\sim N(0, \\tau^2)$\n\n<center>\n\n![W 取值分布](/post_files/machinelearning/ml-linear/ml-linear-loss-regular/w_distribution.png \"TOPICS\")\n\n</center>\n\n则对每一个 $w_j$，其概率密度函数为：\n\n$\np(w_j) = \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)\n$\n\n因此对 $W$，其联合概率密度函数即为 **<font color=EB6D39>先验</font>**：\n\n$$\n先验 \\quad p(W) = \\prod^D_{j = 1} p(w_j) = \\prod^D_{j = 1} \\dfrac {1} {\\sqrt {2 \\pi} \\tau} \\exp \\left( - \\dfrac {w_j^2} {2 \\tau^2} \\right)\n$$\n\n根据 [贝叶斯公式](https://baike.baidu.com/item/贝叶斯公式 \"TOLINKS\")，参数的 **<font color=EB6D39>后验分布</font>** 正比于 **<font color=EB6D39>先验 x 似然</font>**：\n\n$$\n后验 \\quad p(W | D) \\propto p(W) p(D | W)\n$$\n\n去掉正比系数（不影响极值点位置）并两边同取 log 运算可得：\n\n$\n\\begin{aligned}\n& \\log p(W | D) = \\log p(W) + \\log p(D | W)\n\\\\ \n&= - \\dfrac {D} {2} \\log (2 \\pi) - D \\log \\tau - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\dfrac {N} {2} \\log (2 \\pi) - N \\log \\sigma - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2}\n\\end{aligned}\n$\n\n贝叶斯最大后验估计（Maximun A Posteriori estimation, MAP）为\n\n$\n\\hat{W} = \\arg_W \\max \\log p(W | D)\n$\n\n将上述 $\\log p(W | D)$ 代入并去掉与 $W$ 无关的常数项（不影响极值点位置）后得：\n\n$\n\\begin{aligned}\n\\hat{W} &= \\arg_W \\max \\log p(W | D)\n\\\\ \n&= \\arg_W \\max \\left( - \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} - \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)\n\\\\ \n&= \\arg_W \\min \\left( \\sum^D_{j = 1} \\dfrac {w^2_j} {2 \\tau^2} + \\sum^N_{i = 1} \\dfrac {(y_i - f(x_i; w))^2} {2 \\sigma^2} \\right)\n\\\\ \n乘以 2 \\sigma^2 &= \\arg_W \\min \\left( \\dfrac {\\sigma^2} {\\tau^2} \\sum^D_{j = 1} w^2_j + \\sum^N_{i = 1} (y_i - f(x_i; w))^2 \\right)\n\\end{aligned}\n$\n\n上式令 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 得：\n\n$$\n\\hat{W} = \\arg_W \\min \\left( \\sum^N_{i = 1} (y_i - f(x_i; w))^2 + \\lambda \\sum^D_{j = 1} w^2_j \\right)\n$$\n\n**等价于岭回归的目标参数**，因此有结论：\n\n<center>\n\n**<font color=red>L2 正则等价于正态分布先验 $N(0, \\tau^2)$。</font>**\n\n</center>\n\n由于 $\\sigma^2$ 控制了噪声分布，而 $\\tau^2$ 控制了先验，因此 $\\lambda = \\dfrac {\\sigma^2} {\\tau^2}$ 实际上控制了先验的强度（$w_j$ 靠近 0 的程度）。\n\n<br/>\n\n## 2.2 L1正则与Laplace分布先验\n\nL1 正则等价于 Laplace 先验，此时先验分布为 Laplace 分布：\n\n$$\np(w_j) = \\dfrac {1} {2 b} \\exp \\left( - \\dfrac {|w_j|} {b} \\right)\n$$\n\n<center>\n\n![Laplace 分布](/post_files/machinelearning/ml-linear/ml-linear-loss-regular/laplace_distribution.png \"TOPICS\")\n\n</center>","tags":["AI","MachineLearning","人工智能","机器学习","线性回归"],"categories":["MachineLearning","LinearRegression"]},{"title":"ML入门——线性回归三种求解","url":"/post/machinelearning/ml-linear/ml-linear-solutions/","content":"<!-- more -->\n\n***\n\n# 1. 解析法\n\n在给定正则参数（超参数）λ 的情况下，目标函数的最优解为：$\\hat{W} = \\arg_W \\min J(W)$，满足最优解的必要条件即一阶导数为零：$\\dfrac {\\partial J(W)} {\\partial W} = 0$。\n\n<br/>\n\n## 1.1 OLS最优解析解\n\n**（1）正规方程组**\n\n对 OLS 目标函数矩阵形式展开：\n\n$$\n\\begin{aligned}\nJ(W) &= ||y - X W||^2_2 = (y - X W)^T (y - X W)\n\\\\ \n&= y^T y - y^T X W - W^T X^T y + W^T X^T X W\n\\end{aligned}\n$$\n\n根据矩阵的转置运算有：$A^T B = B^T A$，也即 $y^T X W = W^T X^T y$，因此上式等价于：\n\n$$\nJ(W) = y^T y - 2 W^T X^T y + W^T X^T X W\n$$\n\n因此满足 OLS 最优解即：\n\n$$\n\\begin{aligned}\n&\\dfrac {\\partial J(W)} {\\partial W} = 0\n\\\\ \n\\Longrightarrow \\quad &\\dfrac { \\partial (y^T y - 2 W^T X^T y + W^T X^T X W)} { \\partial W } = 0 \\quad（0 矩阵）\n\\end{aligned}\n$$\n\n\n根据矩阵的微分运算有：\n\n$\n\\begin{aligned}\n&① \\quad \\dfrac {\\partial (A^T B)} {\\partial A} = B\n\\\\ \n&② \\quad \\dfrac {\\partial (A^T B A)} {\\partial A} = (B^T + B) A\n\\end{aligned}\n$\n\n进而得到下式：\n\n$$\n0 - 2 X^T y + [ (X^T X)^T + (X^T X) ] W = 0\n$$\n\n根据矩阵的运算法则有：\n\n$\n\\begin{aligned}\n\\because \\quad &X^T X = (X)^T (X^T)^T = (X^T X)^T\n\\\\ \n\\therefore \\quad &X^T X 为对称矩阵\n\\\\ \n\\Longrightarrow \\quad &X^T X = (X^TX)^T\n\\end{aligned}\n$\n\n进一步合并得：\n\n$$\n\\begin{aligned}\n&-2 X^T y + 2 X^T X W = 0\n\\\\ \n&\\Longrightarrow X^T X W = X^T y \\quad （正规方程组）\n\\\\ \n&\\Longrightarrow \\hat{W}_{OLS} = (X^T X)^{-1} X^T y\n\\end{aligned}\n$$\n\n这种求解方式也称为用正规方程组解析求解最小二乘线性回归。但在解析 $ \\hat{W}_{OLS} $ 的过程中涉及到了逆矩阵的计算，应当避免。\n\n**（2）Moore-Penrose广义逆**\n\n通常，训练的目标是 OLS 目标函数 $J(W) = ||y - XW||^2_2$ 最小，通俗来讲也即 $y$ 与 $X W$ 越接近越好，最好的情况即求解：$y = X W$。\n\n（1）假如 $X$ 为方阵，则可以求其逆：$W = X^{-1} y$，\n（2）假如 $X$ 不为方阵，则求其逆矩阵无意义，可求 Moore-Penrose 广义逆：$W = X^+ y$\n（3）※ 注 | 广义逆的符号为：\n  \n![广义逆符号](/post_files/machinelearning/ml-linear/ml-linear-solutions/pseudoinverse.png \"TOPICS\") \n  \nLaTeX 代码为 ``X^{\\dag}``，但 Hexo 不支持引入宏包无法显示，因此使用 $X^+$ 代替。\n  \nMoore-Penrose 广义逆可采用奇异值分解（Singular Value Decomposition, SVD）实现：\n\n$\n\\begin{aligned}\n&若有：X = U \\Sigma V^T,\n\\\\ \n&其中 U, V 为正交阵，\\Sigma 为对角阵（不一定为方阵）\n\\\\ \n&则：X^+ = V \\Sigma^+ V^T\n\\end{aligned}\n$\n\n对角阵 $\\Sigma$ 求伪逆，则将非零元素求倒数即可：\n\n$$\n\\Sigma = \\left(\n\\begin{matrix}\n \\lambda_1 & 0         & \\cdots & 0\n \\\\ \n 0         & \\lambda_2 & \\cdots & 0\n \\\\ \n \\vdots    & \\vdots    & \\ddots & \\vdots\n \\\\ \n 0         & 0         & \\cdots & 0\n \\\\ \n\\end{matrix}\n\\right), \n\\Sigma^+ = \\left(\n\\begin{matrix}\n \\dfrac 1 \\lambda_1 & 0                  & \\cdots & 0\n \\\\ \n 0                  & \\dfrac 1 \\lambda_2 & \\cdots & 0\n \\\\ \n \\vdots             & \\vdots             & \\ddots & \\vdots\n \\\\ \n 0                  & 0                  & \\cdots & 0\n \\\\ \n\\end{matrix}\n\\right), \n$$\n\n这也是 Scikit-Learn 中 LinearRegression 推荐的求解方式。\n\n<br/>\n\n## 1.2 Ridge最优解析解\n\nRidge 比 OLS 多一个 L2 正则，目标函数为：\n\n$$\n\\begin{aligned}\nJ(W) &= ||y - X W||^2_2 + \\lambda ||W||^2_2\n\\\\ \n&= (y - X W)^T (y - X W) + \\lambda W^T W\n\\end{aligned}\n$$\n\n其最优解也采用 SVD 分解的方式实现。求解偏导数等于零：\n\n$$\n\\begin{aligned}\n\\dfrac {\\partial J(W)} {\\partial W} &= -2 X^T y + 2 (X^T X) W + 2 \\lambda W = 0\n\\\\ \n\\Longrightarrow \\hat{W}_{Ridge} &= (X^T X + \\lambda I)^{-1} X^T y\n\\\\ \n&（其中 I 为 D \\times D 的单位阵）\n\\end{aligned}\n$$\n\n对比 OLS 的解：\n\n$$\n\\hat{W}_{OLS} = (X^T X)^{-1} X^T y\n$$\n\n对 Ridge 的解进行变形，配出一个 $\\hat{W}_{OLS}$：\n\n$$\n\\begin{aligned}\n\\hat{W}_{Ridge} &= (X^T X + \\lambda I)^{-1} X^T y\n\\\\ \n&= (X^T X + \\lambda I)^{-1} (X^T X) (X^T X)^{-1} X^T y\n\\\\ \n&= (X^T X + \\lambda I)^{-1} (X^T X) \\hat{W}_{OLS}\n\\end{aligned}\n$$\n\n将 $(X^T X + \\lambda I)^{-1}$ 看成是分母，将 $(X^T X)$ 看成分子，由于 $(X^T X + \\lambda I) > (X^T X)$，因此有 $\\hat{W}_{Ridge} < \\hat{W}_{OLS}$。\n\n因此 $\\hat{W}_{Ridge} $ 在 $ \\hat{W}_{OLS}$ 的基础上进行了收缩，L2 正则也称为权重收缩。\n\n<br/>\n\n## 1.3 总结\n\n（1）OLS 的解为：$\\hat{W}_{OLS} = (X^T X)^{-1} X^T y$，需要对矩阵 $X^T X$ 求逆。\n\n  - 当输入特征存在共线性（某些特征可以用其他特征的线性组合表示），矩阵 X 是接近不满秩，矩阵 $X^T X$ 接近奇异，求逆不稳定。\n\n（2）Ridge 的解为：$\\hat{W}_{Ridge} = (X^T X + \\lambda I)^{-1} X^T y$，需要对矩阵 $(X^T X + \\lambda I)$ 求逆。\n\n  - 即使输入特征存在共线性，矩阵 $X$ 不满秩，矩阵 $X^T X$ 对角线存在等于 0 或接近于 0 的元素，但 $0 + \\lambda \\ne 0$，$(X^T X + \\lambda I)$ 求逆仍可得到稳定解。因此岭回归 Ridge 在输入特征存在共线性的情况仍然能得到稳定解。\n\n（3）Lasso 无法无法求得解析解，可以用迭代求解。\n\n***\n\n# 2. 梯度下降法\n\n<br/>\n\n## 2.1 梯度下降法思想\n\n解析求解法对 N x D 维矩阵 X 进行 SVD 分解的复杂度为：$O(N^2 D)$。\n\n  - 当样本数 N 很大或特征维度 D 很大时，SVD 计算复杂度高，或机器的内存根本不够。\n  - 可采用迭代求解的方法：梯度下降法、随机梯度下降法、次梯度法、坐标轴下降法等。\n  - 梯度下降法（Gradient Descent）是求解无约束优化问题最常采用的方法之一。\n\n在微积分中，一元函数 $f(x)$ 在 $x$ 处的梯度为函数在该点的导数 $\\dfrac {df} {dx}$。\n\n对应在多元函数 $f(x_1, ..., x_D)$ 中，在点 $x = (x_1, ..., x_D)$ 处共有 D 个偏导数：$\\dfrac {\\partial f} {\\partial x_1}, ..., \\dfrac {\\partial f} {\\partial x_D}$。将这 D 个偏导数组合成一个 D 维的矢量 $(\\dfrac {\\partial f} {\\partial x_1}, ..., \\dfrac {\\partial f} {\\partial x_D})^T$，即称为函数 $f(x_1, ..., x_D)$ 在点 $x$ 处的梯度，一般记为 $\\nabla$ 或 $grad$，即：\n\n$$\n\\nabla f(x_1, ..., x_D) = grad \\ f(x_1, ..., x_D) = (\\dfrac {\\partial f} {\\partial x_1}, ..., \\dfrac {\\partial f} {\\partial x_D})^T\n$$\n\n（1）从几何意义上讲，某点的梯度是函数在该点变化最快的地方。\n（2）沿着梯度方向，函数增加最快，更容易找到函数的最大值\n（3）沿负梯度方向，函数减少最快，更容易找到函数的最小值。\n\n※ 注 | $\\nabla$ 发音为 nabla，表示微分，不属于希腊字符，只是一个记号。\n\n正负梯度的例子如下：\n\n<center>\n\n![梯度示意图](/post_files/machinelearning/ml-linear/ml-linear-solutions/gradient_demo.png \"TOPICS\")\n\n</center>\n\n\n在计算 $f(x)$ 的最小值时，当函数形式比较简单且数据量小，可用解析计算 $ f'(x) = 0 $，否则可用迭代法求解：\n\n（1）从 t = 0 开始，随机寻找一个值 $x^{t = 0}$ 为初始值；\n（2）找到下一个点 $x^{t + 1}$，使得函数值越来越小，即 $f(x^{t + 1}) < f(x^t)$；\n（3）重复，直到函数值不再见小，则已经找到函数的 **局部极小值**。\n※ 注 | 该方法仅能找到局部极小值。\n\n为此，可以对该迭代方案进行改进：\n  - （1）随机寻找初始值时，初始化多个点；\n  - （2）最后从多个局部极小值中取最小的作为最终的极小值。\n\n<br/>\n\n## 2.2 梯度下降法数学解释\n\n对函数 $f(x)$ 进行一节泰勒展开得到：\n\n$$\nf(x + \\Delta x) \\approx f(x) + \\Delta x \\nabla f(x)\n$$\n\n要找到函数的最小值，也即每一次步进 $\\Delta x$ 后的函数值均小于原函数值，因此有：\n\n$$\n\\begin{aligned}\n& f(x + \\Delta x) < f(x)\n\\\\ \n\\Longrightarrow & \\Delta x \\nabla f(x) < 0\n\\end{aligned}\n$$\n\n假设令 $\\Delta x = - \\eta \\nabla f(x), \\ \\ (\\eta > 0)$，其中步长 $\\eta$ 为一个较小的正数，从而有：\n\n$$\n\\Delta x \\nabla f(x) = - \\eta \\left( \\nabla f(x) \\right)^2 < 0\n$$\n\n令 $\\Delta x = - \\eta \\nabla f(x)$ 即可确保 $\\left( \\nabla f(x) \\right)^2 > 0$。\n\n因此，对 $x$ 的更新为：$x^{t + 1} = x + \\Delta x = x^t - \\eta \\nabla f(x)$，也即 $x$ 向负梯度方向 $- \\eta \\nabla f(x)$ 移动步长 $\\eta$，会使得$f(x^{t + 1}) < f(x^t)$，$\\eta$ 也称为学习率。\n\n由于只对 $f(x)$ 进行一阶泰勒展开，因此梯度下降法是一阶最优化算法。\n\n<br/>\n\n## 2.3 OLS的梯度下降\n\nOLS 的目标函数为：\n\n$$\n\\begin{aligned}\nJ(W) &= \\sum^N_{i = 1} (y_i - W^T X_i)^2\n\\\\ \n&= ||y - X W||^2_2\n\\\\ \n&= (y - X W)^T (y - X W)\n\\end{aligned}\n$$\n\n其梯度为：\n\n$$\n\\nabla J(W) = -2 X^T y + 2 X^T X W = -2 X^T (y - X W)\n$$\n\n梯度下降：\n\n$$\n\\begin{aligned}\nW^{t + 1} &= W^t - \\eta \\nabla J(W^t)\n\\\\ \n&= W^t + 2 \\eta X^T (y - X W^T)\n\\end{aligned}\n$$\n\n其中 $(y - X W^T)$ 即为预测残差 r，说明参数的更新量与输入 X 和预测残差 r 的相关性有关。$X^T$ 与 r 的相关性较强时需要把 $\\eta$ 调大一些，则 r 逐渐与输入 $X^T$ 无关，直到无需再更新 W。\n\nOLS 的梯度下降过程：\n\n（1）从 t = 0 开始，随机寻找一个值 $W^{t = 0}$ 为初始值（或 0）；\n（2）计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$；\n（3）根据学习率 $\\eta$，更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$；\n（4）判断是否满足迭代终止条件。若满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t + 1})$，否则跳转至第 2 步。\n\n迭代终止条件有：\n\n（1）迭代次数达到预设的最大次数。\n（2）迭代过程中目标函数的变化值小于预设值：$\\dfrac{J(W^t) - J(W^{t + 1})}{J(W^t)} \\le \\varepsilon$。\n\n<br/>\n\n## 2.4 Ridge的梯度下降\n\nRidge 的目标函数为：\n\n$$\n\\begin{aligned}\nJ(W) &= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j\n\\\\ \n&= ||y - X W||^2_2 + \\lambda ||W||^2_2\n\\end{aligned}\n$$\n\n其梯度为：\n\n$$\n\\nabla J(W) = -2 X^T y + 2 X^T X W + 2 \\lambda W\n$$\n\nRidge 的梯度下降过程与 OLS 的相同。\n\n<br/>\n\n## 2.5 Lasso次梯度法\n\nLasso 的目标函数为：\n\n$$\n\\begin{aligned}\nJ(W) &= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |W_j|\n\\\\ \n&= ||y - X W||^2_2 + \\lambda ||W||_1\n\\end{aligned}\n$$\n\n绝对值函数 &||W||_1& 在原点 $W = 0$ 处不可导，无法使用梯度下降求解。\n\n（1）可用次梯度概念替换梯度，得到次梯度法。\n\n（2）或用坐标轴下降求解。\n\n<br/>\n\n## 2.6 梯度下降的实用Tips\n\n（1）梯度下降中的学习率 η 需要小心设置。太大可能引起目标函数震荡，太小收敛速度过慢，可以采用自适应学习率的方案：\n\n<center>\n\n![不同 η 的影响](/post_files/machinelearning/ml-linear/ml-linear-solutions/different_eta.png \"TOPICS\")\n\n</center>\n\n（2）梯度下降对特征的取值范围敏感，建议对输入特征 X 做去量纲处理（可用 sklearn.preprocessing.StandardScaler 实现）：\n\n$$\nW^{t + 1} = W^t + 2 \\eta X^T (y - X W^t) \\ \\ \\ \\ （与输入 X 的取值有关）\n$$\n\n梯度下降算法延伸阅读：[Introduction to Gradient Descent Algorithm (along with variants) in Machine Learning](https://www.analyticsvidhya.com/blog/2017/03/introduction-to-gradient-descent-algorithm-along-its-variants/ \"TOLINKS\")\n\n<br/>\n\n## 2.7 随机梯度下降\n\n在机器学习模型中，目标函数形式为：\n\n$$\nJ(W) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)\n$$\n\n梯度形式为：\n\n$$\n\\nabla J(W^t) = \\sum^N_{i = 1} \\nabla L \\left( y_i, f(X_i; W^t) \\right) + \\lambda \\nabla R(W^t)\n$$\n\n当样本中存在信息冗余（正负抵消或梯度相似）时效率不高，因此可以使用随机梯度下降，即每次梯度下降更新时只计算一个样本上的梯度：\n\n$$\n\\nabla J(W^t) = \\nabla L \\left( y_t, f(X_t; W^t) \\right) + \\lambda \\nabla R(W^t)\n$$\n\n通俗而言，每一次迭代时，随机选择一个样本，向该样本的负梯度方向移动一步。梯度下降法每一次迭代都需要计算所有样本的梯度，随机梯度下降每一次迭代仅需计算单个样本的梯度：\n\n（1）为了确保收敛，相比于同等条件下的梯度下降，随机梯度下降需要采用更小的步长和更多的迭代轮数。\n\n（2）相比于非随机算法，随机梯度下降在前期的迭代效果卓越。\n\n小批量梯度下降法：介于一次使用所有样本（批处理梯度下降）和一次只是用一个样本（随机梯度下降）之间，也即在随机梯度下降中，每次使用一个小批量的样本代替单个样本。实践中常采用小批量样本（mini-batch）下降。\n\n> 随机梯度下降参考文章：\n>\n> ① \"Stochastic Gradient Descent\" L. Bottou - Website, 2010\n> ② \"The Tradeoffs of Large Scale Machine Learning\" L. Bottou - Website, 2011\n\n<br/>\n\n## 2.8 Ridge和SGDRegressor\n\n### 2.8.1 Ridge\n\n```python\n# class sklearn.linear_model.Ridge\nRidge(alpha=1.0,\n      fit_intercept=True,\n      normalize=False,\n      copy_X=True,\n      max_iter=None,\n      tol=0.001,\n      solver=’auto’,\n      random_state=None)\n```\n\n**（1）其中与优化计算有关的参数如下**\n\n``max_iter``：\n共轭梯度求解器的最大迭代次数。\n对于优化算法 solver 为 'sparse_cg' 和 'lsqr'，则默认值由 ``scipy.sparse.linalg`` 确定，对于 'sag' 求解器，默认值为 1000。\n\n``tol``：\n解的精度，判断迭代收敛与否的阈值。\n当（loss > previous_loss - tol）时迭代终止。\n\n``solver``：\n求解最优化问题的算法。\n可取：'auto'，'svd'，'cholesky'，'lsqr'，'sparse_cg'，'sag'，'saga'。\n\n``random_state``：\n数据洗牌时的随机种子。\n仅用于 'sag' 求解器。\n\n**（2）其中求解器 ``solver`` 可选的算法如下**\n\n``auto``：\n根据数据类型自动选择求解器。\n默认算法。\n\n``svd``：\n使用 X 的奇异值分解来计算 Ridge 系数。\n对于奇异矩阵，比 'cholesky' 更稳定。\n\n``cholesky``：\n使用标准的 ``scipy.linalg.solve`` 函数获得解析解。\n\n``sparse_cg``：\n使用 ``scipy.sparse.linalg.cg`` 中的共轭梯度求解器。\n对大规模数据，比“cholesky”更合适。\n\n``lsqr``：\n使用专用的正则化最小二乘常数 ``scipy.sparse.linalg.lsqr``。\n速度最快。\n\n``sag``：\n使用随机平均梯度下降。\n当样本数 n_samples 和特征维数 n_feature 都很大时，通常比其他求解器更快。\n\n``saga``：\n'sag' 的改进算法。\n当 ``fit_intercept`` 为 ``True`` 时，'sag’ 和 'saga' 只支持稀疏输入。'sag' 和 'saga' 快速收敛仅在具有近似相同尺度的特征上被保证，因此数据需要标准化。\n\n### 2.8.2 SGDRegressor\n\nScikit-Learn 中实现了随机梯度下降回归：SGDRegressor，其对大数据量训练集（n_sample > 10000）的回归问题合适。\n\nSGDRegressor 的目标函数为：\n\n$$\nJ(W) = \\dfrac {1} {N} \\sum^N_{i = 1} L \\left( y_i, f(X_i) \\right) + \\alpha R(W)\n$$\n\n```python\n# class sklearn.linear_model.SGDRegressor\nSGDRegressor(loss='squared_loss',\n             penalty='l2',\n             alpha=0.0001,\n             l1_ratio=0.15,\n             fit_intercept=True,\n             max_iter=None,\n             tol=None,\n             shuffle=True,\n             verbose=0,\n             epsilon=0.1,\n             random_state=None,\n             learning_rate='invscaling',\n             eta0=0.01,\n             power_t=0.25,\n             warm_start=False,\n             average=False,\n             n_iter=None)\n```\n\n（1）参数 ``loss`` 支持的损失函数包括：\n\n  - ``squared_loss``：L2 损失。\n  - ``huber``：Huber 损失。\n  - ``epsilon_insensitive``：ɛ 不敏感损失 (如：SVM)\n  - ``squared_epsilon_insensitive``\n\n（2）参数 ``penalty`` 支持的正则函数包括：\n\n  - ``none``：无正则\n  - ``l2``：L2正则\n  - ``l1``：L1正则\n  - ``elasticnet``：L1 正则 + L2 正则（配合参数 ``l1_ratio`` 为 L1 正则的比例）\n\n（3）参数 ``epsilon`` 是某些损失函数（huber、epsilon_insensitive、squared_epsilon_insensitive）需要的额外参数。\n\n（4）参数 ``alpha`` 是正则惩罚系数，也用于学习率计算。\n\n（5）优化算法有关的参数包括：\n\n``max_iter``：\n最大迭代次数（访问训练数据的次数，Epoches 的次数），默认值 5。\n一个迭代循环只使用一个随机样本的梯度，并且循环所有的样本，则称为一个 Epoches。SGD 在接近 $10^6$ 的训练样本时收敛。因此可将迭代数设置为 np.ceil($10^6$ / 𝑁)，其中 𝑁 是训练集的样本数目。参数 ``n_iter`` 意义相同，已被抛弃。\n\n``tol``：\n停止条件。\n如果不为 'None'，则当（loss > previous_loss - tol）时迭代终止。\n\n``shuffle``：\n每轮 SGD 之前是否重新对数据进行洗牌。\n\n``random_state``：\n随机种子，Scikit-Learn 中与随机有关的算法均有此参数，含义相同。\n当参数 ``shuffle == True`` 时使用。如果随机种子相同，每次洗牌得到的结果一样。可设置为某个整数以复现结果。\n\n``learning_rate``：\n学习率。\n支持 3 种选择：\n① 'constant'：$\\eta = \\eta_0$。\n② 'optimal'：$\\eta = 1.0 / \\alpha * (t + t_0)$，分类任务中随机梯度下降默认值。\n③ 'invscaling'：$\\eta = \\eta_0 / pow(t, \\ power\\_t)$，回归任务重随机梯度下降默认值。\n\n``warm_start``：\n是否从之前的结果继续。\n随机梯度下降中初始值可以是之前的训练结果，支持在线学习，即可以在原来的学习基础上继续学习新加入的样本并更新模型参数（输出）。初始值可在 ``fit`` 函数中作为参数传递。\n\n``average``：\n是否采用平均随机梯度下降法（ASGD）。\n\n***\n\n# 3. 次梯度法\n\n当函数可导时，梯度下降法是非常有效的优化算法。但 Lasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$，其中正则项 $||W||_1$ 为绝对值函数，在 $W_j = 0$ 处不可导，无法计算梯度，也无法用梯度下降法求解。因此需要将梯度扩展为次梯度，用次梯度法求解该问题。\n\n为了处理不平滑函数，扩展导数的表示。定义一个凸函数 $f$ 在点 $x_0$ 处的 **次导数** 为一个标量 g，使得：\n\n$\nf(x) - f(x_0) \\ge g(x - x_0), \\forall x \\in \\mathrm{I}\n$\n\n其中 $\\mathrm{I}$ 为包含 $x_0$ 的某个区间。如下图所示，对于定义域中的任何 $x_0$，总可以做一条直线通过点 $(x_0, f(x_0))$，且直线要么接触 $f$，要么在其下方：\n\n<center>\n\n![次导数](/post_files/machinelearning/ml-linear/ml-linear-solutions/subderivative.png \"TOPICS\")\n\n</center>\n\n上式等价于：\n\n$\n\\Delta f(x) \\ge g \\Delta x \\Rightarrow g \\le \\dfrac {\\Delta f(x)} {\\Delta x}\n$\n\n从该直线方程可知，$g$ 也就是在直线 $y = f(x_0)$ 下方的直线的斜率，所有 $g$ 的解（斜率）都称为函数的次导数（Subderivative），所有次导数（$g$ 的解）的集合称为函数 $f$ 在 $x_0$ 处的次微分（Subdifferential），记为 $\\partial f(x_0)$。\n\n次微分是次导数的集合，定义该集合为区间 $[a, b]$：\n\n$$\na = \\lim_{x \\rightarrow x^-_0} \\dfrac {f(x) - f(x_0)} {x - x_0}, \\quad b = \\lim_{x \\rightarrow x^+_0} \\dfrac {f(x) - f(x_0)} {x - x_0}\n$$\n\n也即 $x_0$ 点的次微分的集合左边界 $a$ 是从点 $x_0$ 的左侧逼近函数值，右边界 $b$ 是从点 $x_0$ 的右侧逼近函数值。**当函数在 $x_0$ 处可导时，该点的次微分只有一个点组成，也就是函数在该点的导数。**\n\n例如求凸函数 $f(x) = |x|$ 的次微分，由于 $f(x)$ 在点 $x = 0$ 处不可导，因此该点的次微分区间左边界为 $f(0^-) = -1$，右边界为 $f(0^+) = 1$：\n\n$$\n\\partial f(x) = \\left \\{\n\\begin{aligned}\n\\{ -1 \\}, && {x < 0}\n\\\\ \n[-1, +1], && {x = 0}\n\\\\ \n\\{ +1 \\}, && {x > 0}\n\\end{aligned}\n\\right.\n$$\n\n若求解多维点的次微分，则分别求解每个分量的次微分并组成向量，即作为函数在该点的次梯度。\n\n<font color=EB6D39>\n\n对可导函数，最优解的条件为 $f(x) = 0$，对此类仅局部可导，需要使用次微分的函数，最优解的条件为：\n\n$\n0 \\in \\partial f(x^*) \\Longleftrightarrow f(x^*) = \\min_x f(x)\n$\n\n当且仅当 0 属于函数 $f$ 在点 $x^*$ 处次梯度集合时，$x^*$ 为极值点。当然，因为函数在可导的点的次微分等于其导数，因此该条件可扩展到全局可导函数。\n\n</font>\n\n※ 注 | Python 可用 ``numpy.sign`` 函数实现绝对值函数的次梯度。\n\n将梯度下降法中的梯度换成次梯度就得到次梯度法：\n\n| 梯度下降法 | 次梯度法 |\n| :------- | :------ |\n| 1. 从 $t = 0$ 开始，初始化 $w^0$ | 1. 从 $t = 0$ 开始，初始化 $w^0$ |\n| 2. 计算目标函数 $J(W)$ 在当前值的梯度：$\\nabla J(W^t)$ | 2. 计算目标函数 $J(W)$ 在当前值的次梯度：$\\partial J(W^t)$ |\n| 3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\nabla J(W^t)$ | 3. 根据学习率 $\\eta$ 更新参数：$W^{t + 1} = W^t - \\eta \\partial J(W^t)$ |\n| 4. 判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步 | 判断是否满足迭代总之条件，如果满足，循环结束并返回最佳参数 $W^{t + 1}$ 和目标函数极小值 $J(W^{t+ 1})$，否则跳转到第 2 步 |\n\n<font color=EB6D39>\n\n与梯度下降算法不同，次梯度算法并不是下降算法（每次对参数的更新，并不能保证目标函数单调递减）。因此一般情况下会从多个点同时应用次梯度法，最后选择最小值：\n\n$$\nf(x^*) = \\min_{1, ..., t} f(x^t)\n$$\n\n虽然次梯度法不能保证迭代过程中目标函数保持单调下降，但可以证明，满足一定条件的凸函数，次梯度法可以保证收敛，只是收敛速度比梯度下降法慢。因此 Lasso 通常使用 **坐标轴下降法** 求解。\n\n</font>\n\n***\n\n# 4. 坐标轴下降法求解\n\n次梯度法收敛速度慢，Lasso 求解推荐使用坐标轴下降法。\n\n坐标轴下降法即：沿着坐标轴方向搜索。和梯度下降法与随机梯度下降法的概念类似，例如对 D 维样本参数 $W_0, ..., W_D$，坐标轴下降法是每次仅对其中一个 $W_j$ 搜索最优值。循环使用不同的坐标轴（不同维度），一个周期的以为搜索迭代过程相当于一个梯度迭代。\n\n坐标轴下降发利用当前坐标系统进行搜索，无需计算目标函数的导数，只按照某一坐标方向进行搜索最小值，而梯度下降法验目标函数的负梯度方向搜索，因此梯度方向通常不与任何坐标轴平行。\n\n坐标轴下降法在系数矩阵上的计算速度非常快。\n\n<br/>\n\n## 4.1 Lasso坐标轴下降的数学解释\n\nLasso 的目标函数为：$J(W) = ||y - X W||^2_2 + \\lambda ||W||_1$。\n\n将 Lasso 目标函数中的损失和及正则项分别应用坐标轴下降法搜索，每次仅搜索一个维度。定义 $w_{-j}$ 为 $W$ 去掉 $w_j$ 后的剩余 $(D - 1)$ 维向量。\n\n（1）对 RSS 的第 j 维坐标轴下降（可导，直接计算梯度）：\n\n$$\n\\begin{aligned}\n\\dfrac {\\partial} {\\partial w_j} RSS(W) &= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T X_i)^2\n\\\\ \n&= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - (W^T_{-j} X_{i, -j} + w_j x_{ij}))^2\n\\\\ \n&= \\dfrac {\\partial} {\\partial w_j} \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_j x_{ij})^2\n\\\\ \n（复合函数求导） &= -2 \\sum^N_{i = 1} (y_i - W^T_{-j} X_{i, -j} - w_i x_{ij}) \\cdot x_{ij}\n\\\\ \n&= 2 \\sum^N_{i = 1} x^2_{ij} w_j - 2 \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})\n\\\\ \\\\ \n令：a_j &= 2 \\sum^N_{i = 1} x^2_{ij}, \\quad c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})\n\\\\ \\\\ \n\\Longrightarrow \\dfrac {\\partial} {\\partial w_j} RSS(W) &= a_j w_j - c_j\n\\end{aligned}\n$$\n\n（2）再对 $R(W)$ 的第 j 维坐标轴下降（计算次梯度）：\n\n$$\n\\dfrac {\\partial} {\\partial w_j} R(W) = \\dfrac {\\partial} {\\partial w_j} \\lambda |w_j| =\n\\left \\{\n\\begin{aligned}\n& \\dfrac {\\partial} {\\partial w_j} (- w_j \\lambda) = \\{ - \\lambda \\}, && {w_j < 0}\n\\\\ \n& [- \\lambda, + \\lambda], && {w_j = 0}\n\\\\ \n& \\dfrac {\\partial} {\\partial w_j} (w_j \\lambda) = \\{ \\lambda \\}, && {w_j > 0}\n\\end{aligned}\n\\right.\n$$\n\n（3）合并为对 $J(W, \\lambda)$ 的第 j 维坐标轴下降：\n\n$$\n\\begin{aligned}\n& \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda) = \\dfrac {\\partial} {\\partial w_j} (RSS + R(W))\n\\\\ \n&= \\left \\{\n\\begin{aligned}\n& \\{ a_j w_j - c_j - \\lambda \\}, && {w_j < 0}\n\\\\ \n& [a_j w_j - c_j - \\lambda, a_j w_j - c_j + \\lambda] = [- c_j - \\lambda, - c_j + \\lambda], && {w_j = 0}\n\\\\ \n& \\{ a_j w_j - c_j + \\lambda \\}, && {w_j > 0}\n\\end{aligned}\n\\right.\n\\end{aligned}\n$$\n\n（4）最优解需满足：$0 \\in \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$，对于可导部分，则为 $0 = \\dfrac {\\partial} {\\partial w_j} J(W, \\lambda)$：\n\n$$\n\\Longrightarrow \\left \\{\n\\begin{aligned}\n& 0 = a_j w_j - c_j - \\lambda, && {w_j < 0}\n\\\\ \n& 0 \\in [- c_j - \\lambda, - c_j + \\lambda], && {w_j = 0}\n\\\\ \n& 0 = a_j w_j - c_j + \\lambda, && {w_j > 0}\n\\end{aligned}\n\\right.\n$$\n\n其中：\n\n$\n\\begin{aligned}\n& 0 \\in [- c_j - \\lambda, - c_j + \\lambda]\n\\\\ \n& \\Longrightarrow \\left \\{\n\\begin{aligned}\n0 \\ge - c_j - \\lambda\n\\\\ \n0 \\le - c_j + \\lambda\n\\end{aligned}\n\\right.\n\\\\ \n& \\Longleftrightarrow c_j \\in [- \\lambda, \\lambda]\n\\end{aligned}\n$\n\n由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij} > 0$，\n\n① 当 $w_j < 0$ 时有：\n\n$\n\\begin{aligned}\n& 0 = a_j w_j - c_j - \\lambda\n\\\\ \n& w_j = \\dfrac {c_j + \\lambda} {a_j} < 0\n\\\\ \n& \\Longrightarrow c_j < - \\lambda\n\\end{aligned}\n$\n\n② 同理，当 $w_j > 0$ 时有：\n\n$\n\\begin{aligned}\n& 0 = a_j w_j - c_j + \\lambda\n\\\\ \n& w_j = \\dfrac {c_j - \\lambda} {a_j} > 0\n\\\\ \n& \\Longrightarrow c_j > \\lambda\n\\end{aligned}\n$\n\n因此可以转换为下式：\n\n$$\n\\hat{w_j}(c_j) = \\left \\{\n\\begin{aligned}\n& \\dfrac {c_j + \\lambda} {a_j}, && {c_j < - \\lambda}\n\\\\ \n& 0, && {c_j \\in [- \\lambda, \\lambda]}\n\\\\ \n& \\dfrac {c_j - \\lambda} {a_j}, && {c_j > \\lambda}\n\\end{aligned}\n\\right.\n$$\n\n<br/>\n\n## 4.2 Lasso坐标轴下降步骤\n\n由于 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$ 对于已知的输入 $X$ 是可以预计算的，因此 Lasso 坐标轴下降的步骤如下：\n\n① 预计算 $a_j = 2 \\sum^N_{i = 1} x^2_{ij}$\n\n② 初始化参数 $W$（全 0 或随机）\n\n③ 选择变化幅度最大的维度、或随机选择、或轮流选择需要更新的参数 $w_j$\n\n④ 计算 $c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$\n\n⑤ 计算 $\\hat{w_j}(c_j) = \\left \\{\n\\begin{aligned}\n& \\dfrac {c_j + \\lambda} {a_j}, && {c_j < - \\lambda}\n\\\\ \n& 0, && {c_j \\in [- \\lambda, \\lambda]}\n\\\\ \n& \\dfrac {c_j - \\lambda} {a_j}, && {c_j > \\lambda}\n\\end{aligned}\n\\right.$\n\n⑥ 重复第 3 ~ 5 步直到收敛\n\n⑦ 根据训练好的 $W$ 调整 $\\lambda$ 的取值。\n\n<font color=EB6D39>\n\n注意 $c_j =  \\sum^N_{i = 1} x_{ij} (y_i - W^T_{-j} X_{i, -j})$，其中的 $W^T_{-j} X_{i, -j}$ 本质上是分别从 $W$ 和 $X$ 中各去掉了一维后的向量/矩阵相乘，但从另一方面理解，也可以认为是去掉了第 j 维特征后用剩下的特征计算出来的预测值，因此 $y_i - W^T_{-j} X_{i, -j}$ 实际上也是第 i 个样本的预测残差 $r_i$，而 $c_j = X_j \\cdot r$ 可以表示输入特征 $X$ 和预测残差 $r$ 的相关性。\n\n</font>\n\n\n**（1）当特征与预测残差强相关时，表示该输入特征的取值（实际上由权重 $w_j$ 控制）对预测结果（残差）有很大影响（例如 $r_j$ 下降很快），则说明这个特征很重要（即权重 $w_j$ 是必须的）。**\n\n**（2）当特征与预测残差弱相关时，则表示有没有该特征对预测结果没有什么影响，因此直接使得 $w_j = 0$，这也是 L1 正则起到特征选择作用的原理。**\n\n**（3）这也印证了目标函数 $J(W, \\lambda) = \\sum Loss + \\lambda R(W)$ 中正则参数 $\\lambda$ 的理解：$\\lambda$ 为正则项的惩罚，$\\lambda$ 越大，对应的 $[ -\\lambda, \\lambda]$ 区间也越宽，则 $w_j = 0$ 的可能性越大，因此得到的解越稀疏，从而 $W$ 的复杂度越低。**\n\n**（4）是否 $c_j \\in [- \\lambda, \\lambda]$ 决定了 $w_j$ 是否为 0，而 $c_j$ 同样表示输入特征和预测残差之间的相关性。当 $\\lambda$ 大于某个最值时，会导致所有的权重均为零 $w_j = 0$。这个最大值同样是可以预计算的：当 $\\lambda$ 取最大值时，所有权重均为零，因此每条样本的预测值全为 0，对应的每条样本的预测残差即为真实值本身：$r_i = y_i$，因此 $c_j$ 即可用输入特征和真实值的相关性来代替：$c_j = X^T_{: j} y$，其中 $X_{: j}$ 表示所有样本的第 j 维特征值，因此当 $\\lambda \\ge \\max_j (X^T_{: j} y)$ 时，可得所有 $w_j = 0$。**\n\n<br/>\n\n## 4.3 Scikit-Learn中的Lasso\n\n```python\n# class sklearn.linear_model.Lasso\nLasso(alpha=1.0,\n      fit_intercept=True,\n      normalize=False,\n      precompute=False,\n      copy_X =True,\n      max_iter=1000,\n      tol=0.0001,\n      warm_start=False,\n      positive=False,\n      random_state=None,\n      selection='cyclic')\n```\n\n``precompute``：\n是否使用预计算的 Gram 矩阵来加速计算。\n可取值：'True', 'False', ‘auto’ 或数组（array-like）。若设置为 'auto' 则由机器决定。\n\n``max_iter``：\n最大迭代次数。\n\n``tol``：\n解的精度，判断迭代收敛与否的阈值。\n当更新量小于tol时，优化代码检查优化的 dual gap 并继续直到小于 tol 为止。\n\n``warm_start``：\n是否从之前的结果继续。\n初始值可以是之前的训练结果，支持在线学习。初始值可在 fit 函数中作为参数传递。\n\n``positive``：\n是否强制使系数 $W$ 为正。\n\n``random_state``：\n随机选择特征的权重进行更新的随机种子。\n仅当参数 ``selection == 'random'`` 时有效。\n\n``selection``：\n选择特征权重更新的方式。\n可选项有：\n① 'cyclic'：循环更新\n② 'random'：随机选择特征进行更新，通常收敛更快，尤其当参数 tol > (10 - 4) 时。\n","tags":["AI","MachineLearning","人工智能","机器学习","线性回归"],"categories":["MachineLearning","LinearRegression"]},{"title":"ML入门——线性回归简介","url":"/post/machinelearning/ml-linear/ml-linear-introduction/","content":"<!-- more -->\n\n***\n\n# 1. 什么是回归\n\n假设有一数据集 $D = \\{ X_i, y_i \\}^N_{i = 1}$，其中 N 为训练样本数目，i 为样本索引，$X_i$ 为第 i 个样本的输入特征，$y_i$ 为第 i 个样本的输出/响应，那么：\n\n**根据训练样本 D，学习一个从输入 $X$ 到输出 $y$ 的映射 $f$，使得 $y_i = f(X_i)$，<font color=EB6D39>且 $y_i \\in R$</font>，这就是回归任务。**\n\n※ 注 | 没有特殊说明的情况下，$W$、$X$、$y$ 等均为矩阵（一维矩阵有时作为向量使用）形式，在强调向量性质时使用 $\\vec{X}$、$\\vec{W}$、$\\vec{y}$ 表示。\n\n回归任务的一个重要特征即为 $y_i \\in R$，当 $y_i$ 取类别型数值时，就变成了分类任务。\n\n当学习到回归任务的映射 f 后，即可对新的输入数据 $X$ 预测其输出 $\\hat{y} = f(X)$。\n\n***\n\n# 2. 什么是线性回归\n\n线性回归是最简单的回归模型之一：即从输入 $X$ 到输出 $y$ 的映射 $f$ 为线性关系：\n\n$\n\\begin{aligned}\ny &= f(X) = W^T X\n\\\\ &= [w_0, w_1, ..., w_D] \\begin{bmatrix} 1 \\\\ x_1 \\\\ ... \\\\ x_D \\end{bmatrix} = w_0 + \\sum^D_{j = 1} w_j x_j\n\\end{aligned}\n$\n\n$X = (1, x_1, ..., x_D)^T$\n\n其中，$w_0$ 为截距项/偏置（bias），$w_j$ 为第 j 维特征的权重/回归系数，$x_j$ 为第 j 维特征，D 为特征维数，j 为特征索引，$X$ 为特征向量。\n\n$X$ 在 D 维特征的基础上，再增加一个常数项1，与 $w_0$ 相乘作为截距项，是为了表达式更简洁。也即，$b（bias）= w_0$。\n\n假设有这么一个例子：根据在线广告投入费用预测每月电子商务销售量，其数据分布和预测直线如下图所示：\n\n<center>\n\n![线性回归模型例](/post_files/machinelearning/ml-linear/ml-linear-introduction/linear_predict.png \"TOPICS\")\n\n</center>\n\n在 Scikit-Learn 中，线性回归模型的建立过程大致如下：\n\n```python\nfrom sklearn.linear_model import LinearRegression\n\n# 使用默认参数初始化\nlr = LinearRegression()\n\n# 训练\nlr.fit(X_train, y_train)\n```\n\n在图例中，所有的广告费用构成了 ``X_train``，所有的销售量构成了 ``y_train``，将数据对应输入到 ``fit()`` 方法中即可，以例中的数据解得最后的直线方程为：\n\n$$\ny = 123.94 + 167.89 \\cdot x\n$$\n\n其中 $w_0 = 123.94$，将需要预测的的输入 ``2.8`` 代入 x 即可求得 $\\hat{y} = 593.78$。\n\n不过需要注意的一点是，Scikit-Learn 中训练数据 $X$ 是一个二维数组，在本例中，输入只是长度为 6 的一维数组，因此需要先转换成 n 行 m 列的形式，使用：\n\n```python\nX_train = X_train.reshape(-1, 1)\n```\n\n来指定列数为 1，行数自动调整。\n\n``fit()`` 完后，``lr`` 这个实例化的线性回归模型对象内就会具有一个默认配置的线性回归参数 $W$，这些参数在经过 ``fit()`` 训练后就存在了 ``lr`` 对象内部，根据这些参数生成的直线即为图中绿色直线，这就是一个简单的线性回归模型了。\n\n***\n\n# 3. 线性回归损失函数\n\n仍然以 “广告投入 - 销售量” 为例，在上文使用默认配置训练后得到了绿色的直线，假设通过手动配置，训练出了另一条蓝色直线：\n\n<center>\n\n![两条回归直线](/post_files/machinelearning/ml-linear/ml-linear-introduction/two_predict_lines.png \"TOPICS\")\n\n</center>\n\n显然，蓝色直线也是符合线性回归的定义的，因此需要使用预测残差来评价哪个线性模型更优。\n\n<br/>\n\n## 3.1 预测残差\n\n根据例中表格数据可以求得：\n  - 绿色直线在训练集上的预测残差为：-41.20, -35.64, 33.92, -8.92, -11.08, 62.91\n  - 蓝色直线在训练集上的预测残差为：14, 10, 70, 204, 25, 142\n\n<center>\n\n![两条直线预测残差](/post_files/machinelearning/ml-linear/ml-linear-introduction/two_lines_residual.png \"TOPICS\")\n\n</center>\n\n由于绿色直线的预测残差有负值，在计算残差总和时会发生抵消，因此考虑使用平方计数，也就得到残差平方：\n\n$$\nr^2 = (y - \\hat{y})^2\n$$\n\n用残差平方来计算残差总和，就得到残差平方和 RSS（Residual Sum of Squares），根据定义显然可得其表达式为：\n\n<font color=Eb6D39>\n\n$$\nRSS = \\sum^N_{i = 1} r^2_i = \\sum^N_{i = 1} (y_i - \\hat{y}_i)^2\n$$\n\n</font>\n\n根据定义求得：\n  - 绿色直线 RSS = 8277.32\n  - 蓝色直线 RSS = 67601\n\nRSS 可以表示模型预测的整体性能，RSS 最小亦称为为最小二乘 OLS（Ordinary Least Square）。RSS 越小的直线预测越准确，因此显然，绿色直线比蓝色直线要好得多。\n\n<br/>\n\n## 3.2 三种损失函数\n\n在机器学习中，用<font color=EB6D39>损失函数 L（Loss Function）</font>来**度量**样本真实值与模型预测值之间的差异，该差异用预测残差 r（Residual）来表示：$r = y - \\hat{y}$。\n\n常见的损失函数有三种：\n  - L2 损失\n  - L1 损失\n  - Huber 损失\n\n损失函数的意义在于，使得模型趋向于**最小训练集上的损失（经验风险最小）**，也即在模型训练时给予一个训练目标，使得训练出来的模型在训练集上的损失总和最小。由于模型的参数即为 $W$，因此定义一个目标函数：\n\n$$\nJ(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i)\n$$\n\n则模型训练的目标也就是求：$J(W)$ 最小。\n\n### 3.2.1 L2损失\n\n在前面的例中，当损失函数采用 RSS 时，损失函数为二次函数，范数为 2，因此也称为 L2 损失（差的平方即为距离的 L2 模长），表达式为：\n\n$$\nL(y, \\hat{y}) = (y - \\hat{y})^2 = r^2\n$$\n\n此时目标函数即为：\n\n$$\nJ(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i) = \\sum^N_{i = 1} r^2_i\n$$\n\nL2 损失是二次函数，因此最大的优点就是：处处可导，优化计算方便。但缺点也很明显：对噪声敏感。若数据中某点的预测残差 r 特别大（下图红点），经过平方放大后 $ r^2 $ 会更大，则会在模型中占主导作用，由于模型的训练目标是使得目标函数最小，在 L2 损失的模型中，也即使得 RSS 最小，因此会导致模型向该噪声点偏移（变为下图橙线）：\n\n<center>\n\n![L2 损失对噪声敏感](/post_files/machinelearning/ml-linear/ml-linear-introduction/noise_in_l2.png \"TOPICS\")\n\n</center>\n\nScikit-Learn 中使用 L2 损失的线性回归模型：\n\n```python\n# 使用 L2 损失（线性回归默认使用 L2 损失）\nfrom sklearn.linear_model import LinearRegression\nlr = LinearRegression()\nlr.fit(X_train, y_train)\ny_train_pred_lr = lr.predict(X_train)  # 预测\n```\n\n### 3.2.2 L1损失\n\n为了减弱噪声点对模型的影响，同时保留损失函数“避免抵消正负”的特性，除了采用平方之外，还可以采用绝对值。当损失函数采用绝对值计量预测误差总和时，损失函数为绝对值函数，范数为 1，因此也称为 L1 损失（差的绝对值即为距离的 L1 模长），表达式为：\n\n$$\nL(y, \\hat{y}) = |y - \\hat{y}| = |r|\n$$\n\n此时目标函数即为：\n\n$$\nJ(W) = \\sum^N_{i = 1} L(y_i, \\hat{y}_i) = \\sum^N_{i = 1} |r|_i\n$$\n\nL1 函数是绝对值函数，因此最大的有点是：对噪声不敏感：\n\n<center>\n\n![L1 损失对噪声不敏感](/post_files/machinelearning/ml-linear/ml-linear-introduction/l2_l1_residual.png \"TOPICS\")\n\n</center>\n\n但缺点同样明显：在零点处左右导数不相等，因此不可导，不便于优化计算。\n\n### 3.2.3 Huber损失\n\n为了结合 L2 和 L1 损失的优点，同时规避二者的缺点，可以考虑选择一个新的损失函数：其在靠近零点处表达式为 L2 损失，具有“可导”的优点，在远离零点处表达式为 L1 损失，具有“抗噪声”的优点，得到如下表达式：\n\n$$\nL_{\\delta} (r) = \\left \\{\n\\begin{aligned}\n& \\frac {1} {2} r^2 && {|r| \\le \\delta}\n\\\\ \n\\delta |r| & - \\frac {1} {2} \\delta^2 && {Otherwise}\n\\end{aligned}\n\\right.\n$$\n\n或代入预测残差：\n\n$$\nL_{\\delta} (r) = \\left \\{\n\\begin{aligned}\n& \\frac {1} {2} (y - \\hat{y})^2 && {|r| \\le \\delta}\n\\\\ \n\\delta |y & - \\hat{y}| - \\frac {1} {2} \\delta^2 && {Otherwise}\n\\end{aligned}\n\\right.\n$$\n\nHuber 损失的图像如下：\n\n<center>\n\n![L1 损失对噪声不敏感](/post_files/machinelearning/ml-linear/ml-linear-introduction/l1_l2_huber_lines.png \"TOPICS\")\n\n</center>\n\nHuber 表达式中对 L2 和 L1 损失部分均有变形：\n  - 取 L2 损失的部分，添加系数 $\\frac {1} {2}$ 的目的是抵消 $r^2$ 在求导时产生的系数 2。\n  - 取 L1 损失的部分，添加一项 $- \\frac {1} {2} \\delta^2$ 的目的是使得函数在交点 δ 处（图中黑点标识）连续（当取 $|r| = \\delta$ 时，代入函数两段函数值相等）。\n\nScikit-Learn 中实现了采用 Huber 损失的回归模型：HuberRegressor，其调用接口几乎相同：\n\n```python\n# 使用 Huber 损失\nfrom sklearn.linear_model import HuberRegressor\nhuber = HuberRegressor()\nhuber.fit(X_train, y_train)\ny_train_pred_huber = huber.predict(X_train)  # 预测\n```\n\n***\n\n# 4. Scikit-Learn中的线性回归\n\n最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只考虑了模型对训练样本的拟合程度：\n\n$$\nJ(W = \\sum^N_{i = 1} L(y_i, f(X_i; W))^2 = ||y - X W||^2_2\n$$\n\n其中 $f(X_i; W) = \\hat{y}$\n\nScikit-Learn 中的线性回归模型 ``LinearRegression`` 就是最小二乘线性回归：\n\n```python\n# class sklearn.linear_model.LinearRegression\nLinearRegression(fit_intercept=True,\n                 normalize=False,\n                 copy_X=True,\n                 n_jobs=1)\n```\n\n**（1）LinearRegression 类参数**\n\n``fit_intercept``：\n模型是否包含截距项。\n如果数据在预处理时已经中心化（训练样本集 y 均值为0，则训练结果 $W_0$ 即为0），则可设置为 ``False``。\n\n``normalize``：\n是否对输入特征 $X$ 做归一化。\n对每一条样本，减去均值并除以 L2 模，使得模长变为 1，因此对数据归一化处理会使得超参数学习更加 Robust，且几乎和样本数目没有关系。但在回归中对样本归一化用的比较少，通常对特征标准化。\n\n``copy_X``：\n是否拷贝数据 $X$。\n当设置为 ``False`` 时，对 $X$ 的操作会在原始数据集上完成从而覆盖原始数据。当原始数据后续不再需要使用时可以设置为 ``False`` 节省内存。\n\n``n_jobs``：\n并行计算时使用 CPU 的数目。\n设置为 -1 表示使用所有 CPU 核，与显示设置为 CPU 核数目的效果相同。\n\n**（2）LinearRegression 类属性**\n\n``coef_``：\n回归系数，与特征维数相同。\n也即特征权重 $\\hat{W}_0$，如果是多任务回归，则与标签 y 的维度相同。\n\n``intercept_``：\n截距项。\n也即偏置（bias）：$b = \\hat{W}_0$\n\n**（3）LinearRegression 类方法**\n\n``fit(X, y[, sample_weight])``：\n训练模型。\nX, y 为训练特征和标签，可通过 sample_weight 设置每个样本的权重。例如某个数据由多个设备采集，则高精度设备采集到的数据可以提高权重。\n\n``predict(X)``：\n使用已训练完成的模型进行预测。\n输出即为预测值 $\\hat{y}$\n\n``score(X, y[, sample_weight])``：\n评估模型性能，返回模型预测的 $R^2$ 分数（y 与 $\\hat{y}$ 的差异）。\n根据输入 X 利用模型计算出预测值 $\\hat{y}$ 并和真实值 y 比较。详见回归模型评价指标部分。\n\n※ 注 | 关于归一化、标准化、中心化的参考理解：\n\n（1）归一化：①把数据映射到区间 (0, 1) 或 (-1, 1)，主要为了数据处理方便。②把有量纲表达式转换为无量纲表达式，便于不同量级或单位的指标能进行比较和加权。\n\n（2）标准化：将数据转换为均值为 0（每个特征都减掉原始数据中该特征的均值），且标准差为 1。\n\n（3）中心化：将样本数据的输出 y 转换为均值为 0。\n\n***\n\n# 5. 欠拟合与过拟合\n\nOLS 中，目标函数只考虑了模型对 **训练样本** 的拟合程度：\n\n$$\nJ(f) = RSS(f) = \\sum^N_{i = 1} L(y_i, \\hat{y_i}) = \\sum^N_{i = 1} L(y_i, f(x_i)) = \\sum^N_{i = 1} (y_i - f(x_i))^2\n$$\n\n因此在训练样本集上残差和可以接近甚至等于零。原则上，任意复杂的模型，若能完全拟合训练数据，则称为过拟合。反之若模型连训练样本都无法较好的拟合，则称为欠拟合：\n\n  - 过拟合（Overfitting）：过于复杂的模型与训练数据拟合的太好，导致推广性和扩展性较差，因此和测试数据拟合的较差。\n\n  - 欠拟合（Underfitting）：过于简单的模型与训练数据尚且拟合的较差，更加不足以拟合测试数据。\n\n※ 注 | 线性回归采用的线性模型比较简单，因此当特征维数不太高时，线性回归的过拟合现象通常不太严重。\n\n<br/>\n\n## 5.1 $\\sin$函数曲线实例\n\n假设数据产生模型为：$y = \\sin (2 \\pi x) + \\varepsilon$，其中 $\\sin$ 函数如下：\n\n<center>\n\n![sin 函数部分](/post_files/machinelearning/ml-linear/ml-linear-introduction/sin_function.png \"TOPICS\")\n\n</center>\n\n$\\varepsilon$ 为白噪声（随机噪声），假设方差为 0.03：\n\n$\n\\varepsilon \\sim N (0, 0.03^2)\n$\n\n通常，$\\sin$ 函数需要使用无穷多阶多项式拟合，在此给定 $N = 10$ 共 10 个样本点，如上图中蓝点所示，采用 M 阶多项式拟合数据：\n\n$\ny = \\sum^M_{j = 0} w_j x^j\n$\n\n当有 10 个样本时，最多可以解出 10 个未知数（$M = 9$ 时可取 $w_0, ..., w_9$ 共 10 个系数），分别取 $M = 0, 1, 3, 9$ 并绘制图形如下：\n\n<center>\n\n![sin 函数部分](/post_files/machinelearning/ml-linear/ml-linear-introduction/different_m_in_sin.png \"TOPICS\")\n\n</center>\n\n（1）当 $M = 0$ 时，$y = w_0$，此时为了使 RSS 最小，则训练结果 $w_0 = \\bar{y}$。\n\n（2）当 $M = 9$ 时，可看出函数已经完全拟合了所有 10 个样本（函数通过每个样本点），此时训练集上 $RSS = 0$，但显然，该多项式并没有较好地表达数据的分布。\n\n<br/>\n\n## 5.2 训练误差与测试误差\n\n评价模型性能不能在训练集上评估，而应该在新的测试数据集上评估其 **推广性** / **泛化能力（Generalization）**。理论上，随着模型训练的进行，训练误差总是会越来越小，直到为零。根据如下误差计算公式：\n\n$$\nE_{RMS} = \\sqrt {\\dfrac {1} {N} \\sum^N_{i = 1} (y_i - \\hat{y_i})^2}\n$$\n\n统计各样本点的训练误差和测试误差：\n\n<center>\n\n![训练误差和测试误差](/post_files/machinelearning/ml-linear/ml-linear-introduction/loss_of_train_and_test.png \"TOPICS\")\n\n</center>\n\n从 $M = 3$ 开始，当模型复杂度继续增加时，训练误差继续下降，甚至为 0，而测试误差反而增大，此时发生了过拟合。在本例中，取 $M = 3$ 时的模型最理想，当 $M \\in [4, 8]$ 时，虽然测试误差没有增加，但模型复杂度增加，这是没有必要的（奥卡姆剃刀原理）。\n\n<br/>\n\n## 5.3 过拟合时的模型参数\n\n统计当 $M$ 分别取 $0 \\sim 9$ 时训练出来的模型系数 $w_0 \\sim w_M$：\n\n<center>\n\n![所有 W 取值](/post_files/machinelearning/ml-linear/ml-linear-introduction/all_w_in_sin.png \"TOPICS\")\n\n</center>\n\n可以看到，随着阶数的增加，系数 $W$ 的绝对值越来越大，发生过拟合时，回归系数的 绝对值 / 平方值 很大，即使输入 $x$ 变化很小也可能带来 $y$ 很大的变化，函数的抖动很剧烈。\n\n<br/>\n\n## 5.4 抑制过拟合\n\n（1）增加训练样本数\n\n当训练数据增多时，同样使用九阶多项式拟合，也不会产生明显的过拟合现象：\n\n<center>\n\n![增加训练样本](/post_files/machinelearning/ml-linear/ml-linear-introduction/add_train_data_set.png \"TOPICS\")\n\n</center>\n\n通常，样本数 N 为系数数量（特征维度）D 的 5 ~ 10 倍时训练效果比较好。\n\n（2）目标函数增加正则项\n\n在给定有限训练样本数时，可通过在目标增加正则项减弱过拟合现象。同样 10 个样本，使用 9 阶多项式拟合，但加入 **L2 正则项**，即可得到 **岭回归（Ridge Regression）**：\n\n$$\nJ_{Ridge} (W, \\lambda) = \\sum^N_{i = 0} \\left( y_i - \\sum^M_{j = 0} w_j, x^j_i \\right)^2 + \\lambda \\sum^M_{j = 1} w^2_j\n$$\n\n得到的拟合结果如下：\n\n<center>\n\n![增加正则项](/post_files/machinelearning/ml-linear/ml-linear-introduction/add_r_function.png \"TOPICS\")\n\n</center>\n\n统计模型系数 W 随正则参数 $\\lambda$ 的变化表：\n\n<center>\n\n![W 随 $\\lambda$ 变化表](/post_files/machinelearning/ml-linear/ml-linear-introduction/change_of_w_with_lambda.png \"TOPICS\")\n\n</center>\n\n当 $\\ln \\lambda = - \\infty$ 时，$\\lambda = 0$，此时相当于没有正则项。从表格可以看出，$\\ln \\lambda$ 越大，也即 $\\lambda$ 越大，对模型复杂度惩罚越多，回归系数的 绝对值 / 平方值 越小，模型越简单。训练误差及测试误差与正则参数的关系如下图：\n\n<center>\n\n![训练误差和测试误差与 $\\lmabda$ 的关系](/post_files/machinelearning/ml-linear/ml-linear-introduction/loss_with_lambda.png \"TOPICS\")\n\n</center>\n\n常用的正则项如下：\n\n① L2 正则（L2 范数：平方距离）：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$\n\n② L1 正则（L1 范数：绝对值距离）：$R(W) = ||W||_1 = \\sum^D_{j = 1} |w_j|$\n\n其中 $W$ 为模型参数，D 为参数的维数。<font color=EB6D39>这里需要注意，正则项求和中，只对 $1 \\sim D$ 求和，也即不惩罚截距项（Bias）$b = w_0$，因此在实际任务中，通常需要先对数据作中心化处理，去掉截距项的影响。</font>\n\n还有一种 L0 正则（L0 范数：向量中非零元素数目）：$R(W) = ||W||_0$，但因为 L0 正则是 NP 问题，优化计算不方便，且 L1 范数是 L0 范数的最优凸近似，更方便优化计算，因此常用 L1 正则去近似 L0 正则。\n\nL1 / L0 正则可以得到稀疏解，因此可以起到特征选择的作用，这是因为当确定某个系数 $w_j = 0$ 时，对应的特征 $x_j$ 是无用的，在某些场景（如医学等）下，下一次采样可考虑去掉该特征。\n\n（3）减少噪声\n\n另一种抑制过拟合的方法是减少噪声，但在实际面对的任务中，大部分情况下训练数据是给定的，因此增加或调整正则项是抑制过拟合最常用的手段。\n\n**<font color=EB6D39>\n※ 正则项发挥作用的理解：对于目标函数 $J(W, \\lambda) = Loss + \\lambda R(W)$，若模型过拟合，由于模型的训练目标是目标函数最小，过拟合时虽然 $Loss$ 可能较小，但模型过于复杂，回归系数的 绝对值 / 平方值 过大，导致目标函数整体较大，则增大 $\\lambda$，为了使得目标函数最小，模型会趋于减小 $W$，从而减小模型复杂度（$W$ 元素的值减小或非零元素减少都是减小模型复杂度）。当处于欠拟合状态，则 $Loss$ 较大，模型复杂度尚且不够拟合训练数据，此时减小 $\\lambda$，以增加模型复杂度。通常，训练的过程分为系数 $W$ 的训练和超参数 $\\lambda$ 的训练，使用某个超参数训练出系数后，模型复杂度即确定下来，再去搜索最优的超参数即可。\n</font>**\n\n***\n\n# 6. 带正则的线性回归\n\n最小二乘（OLS）线性回归中，目标函数 $J(W)$ 只包括训练集上的损失和（经验风险），也即仅考虑了模型对训练样本的拟合程度，因此可能会导致模型太过于复杂，甚至训练误差为0，产生过拟合。为此可在原目标函数中加入正则项，使得模型不会太复杂。则目标函数变为损失和 + 正则项：\n\n$$\nJ(W, \\lambda) = \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)\n$$\n\n其中 R 为 Risk，表示 $W$ 复杂度的风险，新的目标函数也称为 **结构风险**。正则项的加入使目标函数符合奥拉姆剃刀（Occam's Razor）原理：简单有效，选择能解释数据的模型中最简单的一个。\n\n常用的正则项有：L2 正则、L1 正则。\n\n（1）L2 正则：$R(W) = ||W||^2_2 = \\sum^D_{j = 1} w^2_j$\n\n（2）L1 正则：$R(W) = ||W||_1 = \\sum^D_{j = 1} |w_j|$\n\n其中 $W$ 为模型参数，D 为参数的维数。\n\n<br/>\n\n## 6.1 岭回归\n\n岭回归（Ridge）：L2 损失 + L2 正则 + LinearRegression。\n\n岭回归正则项对截距项不施加惩罚，也即：\n\n$$\nR(W) = \\sum^D_{j = 1} w^2_j，（j 从 1 开始）\n$$\n\n线性模型中增加常数项 $x_0 = 1$ 用于表示截距项：\n\n$$\nf(X; W) = W^T X = \\sum^D_{j = 0} w_j x_j，（j 从 0 开始）\n$$\n\n当 j = 0 时，$x_0 = 1 \\rightarrow w_0 x_0 = w_0$ 作为截距项。因此而得岭回归目标函数（目标函数的损失和部分不惩罚截距项，所以目标函数不需要从 0 开始）：\n\n$$\n\\begin{aligned}\nJ(W; \\lambda) &= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)\n\\\\ &= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} w^2_j\n\\\\ &= ||y - X W||^2_2 + \\lambda ||W||^2_2\n\\end{aligned}\n$$\n\nScikit-Learn 中的岭回归：\n\n```python\n# class sklearn.linear_model.Ridge\nRidge(alpha=1.0,\n      fit_intercept=True,\n      normalize=False,\n      copy_X=True,\n      max_iter=None,\n      tol=0.001,\n      solver='auto',\n      random_state=None)\n```\n\n**（1）Ridge 类参数**\n\n``alpha``：\n正则参数，也即正则项中的 λ。\n目标：求 $\\arg_W \\min (||X W - y||^2_2 + \\alpha ||W||^2_2)$\n\n部分参数与 LinearRegression 相同。\n其他参数与优化计算有关（详见优化求解部分）。\n\n**（2）Ridge 类属性**\n\n与 LinearRegression 相同。\n\n**（3）Ridge 类方法**\n\n与 LinearRegression 相同。\n\n<br/>\n\n## 6.2 Lasso\n\nLasso（Least **Absolute** **Shrinkage** and **Selection** Operator）：L2 损失 + L1 正则 + LinearRegression。\n\nLasso 有三个关键点：\n\n  - Absolute：表示用的是 L1 正则，绝对值的模。\n  - Shrinkage：相比普通的线性回归，L1 正则会使得 $W$ 有一定收缩。\n  - Selection：L1 正则可能使得 $W$ 中某些元素变为 0 得到稀疏解，从而起到特征选择的作用。\n\nLasso 的目标函数为：\n\n$$\n\\begin{aligned}\nJ(W; \\lambda) &= \\sum^N_{i = 1} L \\left( y_i, f(X_i; W) \\right) + \\lambda R(W)\n\\\\ \n&= \\sum^N_{i = 1} (y_i - W^T X_i)^2 + \\lambda \\sum^D_{j = 1} |w_j|\n\\\\ \n&= ||y - X W||^2_2 + \\lambda ||W||_1\n\\end{aligned}\n$$\n\nScikit-Learn 中的 Lasso：\n\n```python\n# class sklearn.linear_model.Lasso\nLasso(alpha=1.0,\n      fit_intercept=True,\n      normalize=False,\n      precompute=False,\n      copy_X=True,\n      max_iter=None,\n      tol=0.001,\n      warm_start=False,\n      random_state=None,\n      selection='cyclic')\n```\n\n**（1）Lasso 类参数**\n\n大部分与 Ridge 相同。\n其他参数与优化计算有关（详见优化求解部分）。\n\n**（2）Ridge 类属性**\n\n与 LinearRegression 相同。\n\n**（3）Ridge 类方法**\n\n与 LinearRegression 相同。\n\n<br/>\n\n## 6.3 弹性网络\n\n弹性网络：L2 损失 + （L1 正则 + L2 正则） + LinearRegression。\n\n在 性网络中，使用 ρ 表示 L1 正则所占比例，$\\dfrac {(1 - \\rho)} {2}$ 表示 L2 正则所占比例：\n\n$$\nR(W) = \\sum^D_{j = 1} \\left( \\rho |w_j| + \\dfrac {(1 - \\rho)} {2} w^2_j \\right)\n$$\n\n弹性网络的目标函数：\n\n$$\nJ(W; \\lambda; \\rho) = \\dfrac {1} {2N} ||y - X W||^2_2 + \\lambda \\left( \\rho ||W||_1 + \\dfrac {(1 - \\rho)} {2} ||W||^2_2 \\right),\\ \\ \\ \\ \\ 0 \\le \\rho \\le 1\n$$\n\nScikit-Learn 中使用 ElasticNet 实现弹性网络：\n\n```python\n# class sklearn.linear_model.ElasticNet\nElasticNet(alpha=1.0,\n           l1_ratio=0.5,\n           fit_intercept=True,\n           normalize=False,\n           precompute=False,\n           max_iter=None,\n           copy_X=True,\n           tol=0.001,\n           warm_start=False,\n           postive=False,\n           random_state=None,\n           selection='cyclic')\n```\n\n**（1）ElasticNet 类参数**\n\n``l1_ratio``：\n即正则比例参数 ρ。\n\n大部分参数与 Lasso 相同。\n其他参数与优化计算有关（详见优化求解部分）。\n\n**（2）ElasticNet 类属性**\n\n与 LinearRegression 相同。\n\n**（3）ElasticNet 类方法**\n\n与 LinearRegression 相同。\n\n当取 ρ = 0 时，正则项仅为 L2 正则，当取 ρ = 1 时，正则项仅为 L1 正则。弹性网络的正则项有如下效果：\n\n  - L2 正则使得线性回归系数 $W$ 收缩，模型稳定。\n\n当输入特征之间存在共线性时，使用 L2 正则。\n    \n  - L1 正则也会收缩回归系数 $W$。当正则参数取合适值时，L1 正则使得有些回归系数为 0，得到稀疏模型。\n\n当输入特征比较多，优先特征和目标便梁志坚相关性很弱时，L1 正则可能只选择强相关的特征，模型解释性较好。若 $\\lambda_{max}$ 为某临界值，当取 $\\lambda \\ge \\lambda_{max}$ 时，$W = 0$。\n\n**注意**：由于正则项中对不同维度的 $W_j$ 同等对待，对输入特征 $X$ 最好做去量纲（Scaling）处理，使得不同维度的特征取值范围大致相同（如标准化：``sklearn.preprocessiong.StandardScaler``）。\n\n※ 去量纲的常用方法：\n\n  - 归一化（Normalization）：例如 Min-Max Scaler\n  - 标准化（Standardization）：例如 Z-Score\n","tags":["AI","MachineLearning","人工智能","机器学习","线性回归"],"categories":["MachineLearning","LinearRegression"]},{"title":"ML入门——机器学习简介","url":"/post/machinelearning/ml-introduction/ml-introduction/","content":"<!-- more -->\n\n***\n\n# 1. 什么是机器学习\n\n机器学习是人工智能的一个分支，主要关于构造和研究可以从数据中学习的系统。\n\n这也说明，机器学习的本质是通过数据实现的，更进一步讲，是从大量无法手动推算出规律、分布、结构的数据中，利用 CPU 强大的计算能力、通过迭代等科学的计算方法来自动计算出某种类型数据的共性，并使用这些共性为新来的数据假设、模拟出其可能的结果。\n\n机器学习的数据通常包括训练数据和校验数据，其中：\n  - 训练数据用于建立机器学习模型，通常包括：①输入：特征 __X__ 和 ②输出：标签 y。  \n  注意：此处黑体 __X__ 表示矩阵，且有一些模型可以没有输出 y。\n  - 校验数据用于在模型初步建立完毕后检验模型的效果，常常从训练数据中分割一部分作为校验数据，与训练数据具有相同的分布和格式。\n\n***\n\n# 2. 机器学习的学习类型：\n1. 监督学习[Supervised Learning]：从带标签的数据中学习。例：房价预测、邮件识别等。\n2. 非监督学习[Unsupervised Learning]：从无标签的数据中学习蕴含的结构。例：文档聚类等。\n3. 强化学习[Reinforcement Learning]：通过曾经执行的动作及带来的奖惩进行学习，强化学习的标签 y 具有延迟性。例：AI 下棋等，当前棋子带来的影响需要经过一段时间才会表现出来。\n\n<br/>\n\n## 2.1 监督学习\n\n1. 两种任务类型：\n\n\t①回归任务[Regression]：输出 $y\\in R$ 为连续值。\n\t②分类任务[Classification]：输出 y 为离散值。\n\n2. 学习目的：学习到一个 __X__ 到 y 的映射 f，从而对新输入的 __X__ 预测其输出\n> $\\hat{y}=f(\\textbf{X})$。\n\n3. 监督学习的训练数据包含标签 y，即标签在训练数据中是可见变量。\n\n4. 数据样式：\n> $D=\\{\\textbf{X}_i, y_i\\}_{i=1}^N$\n其中 D 为数据集，__X<sub>i</sub>__ 与 y<sub>i</sub> 为第 i 个样本的输入与输出，N 为样本总数。\n\n5. Scikit-Learn 中监督学习的大致流程：\n\t①estimator.fit(X_train, y_train)\n\t②estimator.predict(X_test)\n\t③estimator.score(X_test, y_test)\n\n<br/>\n\n## 2.2 非监督学习\n\n（1）两种任务类型：\n > ①聚类[Clustering]\n > ②降维[Dimension Reduction]\n\n（2）学习目的：发现数据中的“有意义的模式”，亦称为“知识发现”。\n\n（3）非监督学习的训练数据不包含标签 y，即标签在训练数据中为隐含变量。\n\n（4）数据样式：\n> $D=\\{\\textbf{X}_i\\}_{i=1}^N$\n\n（5）Scikit-Learn 中非监督学习的大致流程：\n  - ①``transformer.fit(X_train)``\n  - ②``X_train_trans = transformer.transform(X_train)``\n  - ③``X_test_trans = transformer.transform(X_test)``\n\n<br/>\n\n## 2.3 增强学习\n\n（1）学习目的：从行为的反馈（奖励或惩罚）中学习，以找到一条回报值最大的路径。\n\n（2）步骤：设计一个回报函数[Reward Function]，若 Learning Agent 在执行一个动作后获得了较好的结果，则给予一些奖励（例如：回报函数为正），否则给予一些惩罚（例如：回报函数为负），驱使 Learning Agent 寻找出一条最终获得回报总和最高的学习路径。\n","tags":["AI","MachineLearning","人工智能","机器学习"],"categories":["MachineLearning"]},{"title":"AndroidStudio中使用CMake进行NDK开发","url":"/post/android/android-cmake/","content":"<!-- more -->\n\n前言：目前着手的一个项目需要使用JNI方法从USB读取数据，项目在建立之初并没有考虑添加原生的NDK支持，最初想用比较简便原始的方式：NDK-Build来完成，但Android Studio在3.2版本之后弃用了NDK-Build方式（其实还可以用，但是谷歌官方不推荐），因此改用 CMake 建立并记录于本文。\n\n***\n\n# 1. 官方Demo\n\n先解释一下 [什么是NDK](https://developer.android.google.cn/ndk/guides \"TOLINKS\") 以及 [什么是JNI](https://baike.baidu.com/item/JNI/9412164?fr=aladdin \"TOLINKS\") 。\n两者结合起来，用最粗略的话来讲，就是：在 Android 开发中调用 C/C++ 代码。早期 Android 版本通常使用 NDK-Build 方式构建，但由于不便于管理等原因在新版中被弃用。\n\n> 对JNI的详细介绍和进阶知识可以参考官方文档或附录\n\n先新建一个原生支持NDK的Android项目，即在新建项目的时候勾选 ``Include C++ support`` ，观察一下谷歌建议我们使用的CMake方式的样子。在官方的Demo中，调用和以前的方式并无区别：\n\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    // Used to load the 'native-lib' library on application startup.\n    static {\n        System.loadLibrary(\"native-lib\");\n    }\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // Example of a call to a native method\n        TextView tv = (TextView) findViewById(R.id.sample_text);\n        tv.setText(stringFromJNI());\n    }\n\n    /**\n     * A native method that is implemented by the 'native-lib' native library,\n     * which is packaged with this application.\n     */\n    public native String stringFromJNI();\n}\n```\n\n都是先用静态代码块 ``static{}`` 加载JNI模块，然后声明一个native方法并调用。当然，JNI方法的加载和调用不推荐在Activity中实现，应该放在数据处理类或工具类中按需调用，这里涉及到一些性能和安全性的问题，暂时不做多的展开。具体的JNI方法也很简单，只是返回了一个String字符串。重要的是Gradle和CMakeLists.txt文件里的代码，尤其是官方注释，需要注意的地方分别是：①C/C++文件的JNI方法；②项目Gradle；③CMakeLists.txt里的内容。先不急着对官方Demo解释，为了实现手动增加NDK支持，再创建一个不支持原生NDK的空项目，一边改一边对各个模块解释说明。\n\n在C++文件的函数头中，有这么一句：\n\n```c\nextern \"C\" JNIEXPORT jstring JNICALL\n```\n\n这一行代码其实可以分成两个部分：\n\n```c\n// 第一部分\nextern \"C\"\n// 第二部分\nJNIEXPORT jstring JNICALL\n```\n\n第一部分 ``extern \"C\"``表示对编译C的支持，第二部分 ``JNIEXPORT jstring JNICALL`` 可以看成定义了函数的返回值， ``jstring`` 可以理解为Java中的String。如果在JNI文件中有多个函数，可以用一个大的 ``extern \"C\"`` 将多个函数一次性括起来，但是C函数和C++函数不能混用，还是要分两个文件（好像是废话= =）：\n\n```c\n#include <jni.h>\n#include <string>\n\nextern \"C\" {\n    JNIEXPORT jstring JNICALL Java_com_demo_ndktest_MainActivity_helloFromCpp1(\n            JNIEnv *env,\n            jobject /* this */) {\n        std::string hello = \"Hello from C++1\";\n        return env->NewStringUTF(hello.c_str());\n    }\n\n    JNIEXPORT jstring JNICALL Java_com_demo_ndktest_MainActivity_helloFromCpp2(\n            JNIEnv *env,\n            jobject /* this */) {\n        std::string hello = \"Hello from C++2\";\n        return env->NewStringUTF(hello.c_str());\n    }\n}\n```\n\n***\n\n# 2. 为已有项目增加NDK支持\n\n既然是要给已有项目增加NDK支持，那就首先创建一个新的空项目模拟一个已存在的项目，然后再通过手动配置添加NDK。\n切换到 ``Project`` 视图，并在如下图所示的目录层级下创建一个文件夹用来存放C/C++代码：\n\n<center>\n\n![创建JNI文件夹](/post_files/android/android-cmake/create_jni_folder.png \"TOPICS\")\n\n</center>\n\n<br/>\n\n## 2.1 创建JNI文件\n\n接着在这个 **JNI** 文件夹里新建 **C/C++ Source File** ，先创建一个C文件，假设起名为 ``HelloC`` ，在下方的 **Type:** 下拉框中选择 **.c** ，同时勾选 **Create an associated header** 自动创建对应的头文件。\n\n<center>\n\n![创建C文件](/post_files/android/android-cmake/create_c_file.png \"TOPICS\")\n\n</center>\n\n点击OK，就会创建 ``HelloC.c`` 和 ``HelloC.h`` 并自动将头文件导入到C文件中。函数很简单，直接返回一个String： ``\"Hello from C\"``\n\n```java\n#include \"HelloC.h\"\n#include <jni.h>\n\nJNIEXPORT jstring JNICALL Java_com_demo_ndktest_MainActivity_helloFromC(\n        JNIEnv *env,\n        jobject obj /* this */) {\n    return (*env)->NewStringUTF(env, \"Hello from C\");\n}\n```\n\n这里要说明一点，代码中 ``Java_com_demo_ndktest_MainActivity_helloFromC`` 可以看成是一个方法名，但是这个方法名有严格的命名限制，先进行分解：首先命名必须以 ``Java_`` 开头，后面紧跟着的 ``com_demo`` 是项目的包名， ``ndktest`` 是项目名， ``MainActivity`` 是调用这个JNI方法的类名，最后 ``helloFromC`` 才是这个JNI方法的方法名。如果把 ``com_demo_ndktest_MainActivity`` 连在一起看，其实就是调用这个JNI方法的类的绝对路径，在本例中也即 ``MainActivity`` 的绝对路径，只不过把包的层级表示从点“**.**”换成了下划线“**_**”。\n另外， ``extern \"C\" `` 关键字通常在C/C++混合编程中用于 **指定使用C编译方式编译的代码块** ，但是这里本来就是在C文件中写C语言代码，所以没有必要也不允许使用这个关键字了。\n如果怕出错，可以在我们想要调用这个JNI方法的类的最上方找到绝对路径，再把点都替换成下划线即可：\n\n<center>\n\n![设置包名](/post_files/android/android-cmake/set_package_name.png \"TOPICS\")\n\n</center>\n\n<br/>\n\n## 2.2 创建CMakeLists.txt\n\n确定好JNI文件后，开始写 **CMakeLists.txt** ！在创建CMake文件时，理论上可以在任意位置创建，但是一方面为了便于项目管理，另一方面为了防止混淆，还是创建在当前Module根目录下比较好，对于只有一个Module的项目，也就是创建在 **app** 的根目录下。右键 **app** 目录，选择 **New File** ，输入文件名 ``CMakeLists.txt`` 。\n**对于这个文件，文件名必须是“CMakeLists.txt”而不能自定义**。\n\n<center>\n\n![创建CMakeLists.txt的位置](/post_files/android/android-cmake/cmake_file_path.png \"TOPICS\")\n\n</center>\n\n创建完成后向里面写构件库的内容。\n\n**（1）指定CMake的最低版本** 。这是第一条也是必要的一条：\n\n```c\ncmake_minimum_required(VERSION 3.4.1)\n```\n\n**（2）为项目增加一个lib库** 。也就是指定刚才写的 ``HelloC.c`` 文件，这里我们要指定出C文件的绝对路径： ``src/main/jni/HelloC.c``\n\n```c\nadd_library( # Sets the name of the library.\n        HelloC\n\n        # Sets the library as a shared library.\n        SHARED\n\n        # Provides a relative path to your source file(s).\n        src/main/jni/HelloC.c)\n```\n\n其中\n\n - ``HelloC`` 是创建这个库的命名，可以任意指定，这个名称将在Java中 **加载JNI** 时用到。\n - ``SHARED`` 代表这是个动态库，除了这个选项外还有 ``STATIC`` 可选\n\n**（3）使用原生log模块** 。因为要给项目添加NDK支持，所以需要用到NDK库，采用 ``find_library`` 使用原生的库和API：\n\n```c\nfind_library( # Sets the name of the path variable.\n        log-lib\n\n        # Specifies the name of the NDK library that\n        # you want CMake to locate.\n        log)\n```\n\n其中\n\n - ``log-lib`` 是给要使用的NDK库命名，可以自定义，在 **CMake关联指定库** 时会用到\n - ``log`` 是我们要使用的库： **log模块**\n\n**（4）CMake关联指定库** 。这一步将第（2）步中添加的库关联给CMake：\n\n```c\ntarget_link_libraries( # Specifies the target library.\n        HelloC\n\n        # Links the target library to the log library\n        # included in the NDK.\n        ${log-lib})\n```\n\n其中\n\n - ``HelloC`` 就是第（2）步新增库时给库的命名\n - ``${log-lib})`` 是引用第（3）步中定义的log模块\n\n\n完成之后整体的代码（从注释也基本可以看出每一行的用途）：\n\n```c\ncmake_minimum_required(VERSION 3.4.1)\n\nadd_library( # Sets the name of the library.\n        HelloC\n\n        # Sets the library as a shared library.\n        SHARED\n\n        # Provides a relative path to your source file(s).\n        src/main/jni/HelloC.c)\n\nfind_library( # Sets the name of the path variable.\n        log-lib\n\n        # Specifies the name of the NDK library that\n        # you want CMake to locate.\n        log)\n\ntarget_link_libraries( # Specifies the target library.\n        HelloC\n\n        # Links the target library to the log library\n        # included in the NDK.\n        ${log-lib})\n```\n\n此时CMakeLists.txt部分就已经完成！\n\n<br/>\n\n## 2.3 多JNI方法支持\n\n对于大部分时候，JNI和CMakeLIsts的配置就大概如此了，但是有时候可能会遇到需要多个JNI接口的时候，此时就需要在CMakeLists中添加多个库了。在本例中，再新增一个C++的JNI方法，并通过CMake增加到库中。\n\n### 2.3.1 创建第二个JNI方法（C++）\n\n同样在 **jni** 目录下新建一个C++文件 **HelloCPP.cpp** ，与之前创建 **HelloC.c** 时一样，勾选自动关联头文件，代码和官方Demo如出一辙，只不过把函数名改为 ``helloFromCPP`` ：\n\n```c\n#include <jni.h>\n#include <string>\n\nextern \"C\" JNIEXPORT jstring JNICALL\nJava_com_demo_ndkdemo_MainActivity_stringFromJNI(\n        JNIEnv *env,\n        jobject /* this */) {\n    std::string hello = \"Hello from C++\";\n    return env->NewStringUTF(hello.c_str());\n}\n```\n\n同样，既然要让这个JNI方法被编译，就需要在CMakeLists中进行添加和关联。\n\n### 2.3.2在CMake中添加和关联两个JNI接口\n\n步骤与C文件的步骤一模一样，只需要注意库命名和绝对路径正确即可，直接贴代码：\n\n```c\ncmake_minimum_required(VERSION 3.4.1)\n\n# 添加第一个JNI（HelloC）\nadd_library(\n        HelloC\n\n        SHARED\n\n        src/main/jni/HelloC.c)\n\n# 添加第二个JNI（HelloCPP）\nadd_library(\n        HelloCPP\n\n        SHARED\n\n        src/main/jni/HelloCPP.cpp\n)\n\nfind_library(\n        log-lib\n\n        log)\n\n# 连接到第一个库\ntarget_link_libraries(\n        HelloC\n\n        ${log-lib})\n\n# 连接到第二个库\ntarget_link_libraries(\n        HelloCPP\n\n        ${log-lib})\n```\n\n这样就把两个JNI方法都连接到CMake了，接下来就是Gradle的配置，使得系统可以调用JNI方法。\n\n<br/>\n\n## 2.4 修改Gradle配置\n\n修改模块的Gradle： **build.gradle (Module: app)** 。先在 ``defaultConfig`` 内部增加CMake的一些参数：预处理选项 ``cppFlags`` 和架构选择 ``abiFilters``，对于默认情况， ``cppFlags`` 为空即可， ``abiFilters`` 可以控制生成指定的abi，例如：\n\n```c\nexternalNativeBuild {\n\tcmake {\n\t\tcppFlags \"\"\n\t\tabiFilters 'armeabi','armeabi-v7a','x86'\n\t}\n}\n```\n\n或者删除 ``abiFilters`` 语句表示生成支持所有架构的so库。\n接着在与 ``buildTypes`` 同级的地方增加一个CMakeLists文件的连接：\n\n```c\nexternalNativeBuild {\n\tcmake {\n\t\tpath \"CMakeLists.txt\"\n\t}\n}\n```\n\n完成后整个Gradle的配置大致如下（省略非必要部分的内容，但保留了层级关系便于比对）：\n\n```java\napply plugin: 'com.android.application'\n\nandroid {\n    compileSdkVersion 28\n    defaultConfig {\n        ......\n        // 此处添加CMake参数\n        externalNativeBuild {\n            cmake {\n                cppFlags \"\"\n            }\n        }\n    }\n    buildTypes {\n        release {\n            ......\n        }\n    }\n    // 此处指定CMake文件\n    externalNativeBuild {\n        cmake {\n            path \"CMakeLists.txt\"\n        }\n    }\n}\n\ndependencies {\n    ......\n}\n```\n\nSync同步一下，再Rebuild一下项目确保没有问题后，就可以运行测试啦！\n\n***\n\n# 3. 完成效果\n\n布局很简单就不放代码了，一个 ``TextView`` 用来显示String返回值，和两个 ``Button`` 分别用来获取C和C++文件JNI方法的字符串并设置到TextView上。代码调用和JNI加载伪代码如下（省略点击监听和控件初始化等）：\n\n```java\npackage com.lsl.demo.ndktest;\n\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n\n\t// 通过静态初始化块加载两个编译库\n\t// 库名分别是在CMakeLists.txt文件中定义的两个库名\n    static{\n        System.loadLibrary(\"HelloC\");\n        System.loadLibrary(\"HelloCPP\");\n    }\n\n\t// btC：从C文件获取字符串并显示\n\t// btCpp：从C++文件获取字符串并显示\n    private TextView tvText;\n    private Button btC, btCpp;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        initView(); // 初始化控件\n    }\n\n\t// 定义JNI方法，方法名和对应的C/C++文件内的函数名相对应\n    public native String helloFromC();\n    public native String helloFromCPP();\n\n    // 在需要使用的地方调用上方两个方法即可\n    @Override\n    public void onClick(View v) {\n        switch (v.getId()) {\n            case R.id.btC: {\n                tvText.setText(helloFromC());\n                break;\n            }\n            case R.id.btCpp: {\n                tvText.setText(helloFromCPP());\n                break;\n            }\n            default: break;\n        }\n    }\n}\n\n```\n\n运行，分别点击两个按钮，可以看到确实成功运行了两个JNI方法并获取到了字符串返回值：\n\n<center>\n\n![运行效果](/post_files/android/android-cmake/run.gif \"TOPICS\")\n\n</center>\n\n***\n\n# 4. 总结备注\n\n对于Android项目的NDK支持基本上就是如此了，不难，但是容易出错，复杂的点通常在具体的函数实现上。最后再总结和强调一些注意事项。\n\n 1. 尽量不要在Activity中执行JNI的静态加载和调用\n 2. CMakeLists.txt文件中 ``add_library`` 设置的名称与下方 ``target_link_libraries`` 以及静态加载JNI的地方 ``static{System.loadLibrary(\"LibraryName\")}`` 中的 ``\"LibraryName\"`` 三者名称要一致\n 3. C/C++函数的函数名与声明该JNI方法处的方法名要一致\n 4. 具体的C/C++函数定义的名称前面的包名和调用函数的类名必须与实际包名和类名一致，并且用下划线 **\"_\"** 代替点 **\".\"** 表示层级关系\n\n以上。\n\n***\n\n# 5. 附录[参考指导]\n\n> - [【1】Android Studio 2.3使用CMake方式NDK入门（作者：狮村小孩）<sup>【注】</sup>](https://blog.csdn.net/aidesudi/article/details/68946918 \"TOLINKS\")\n> - [【2】小白初用Android studio的cMake编译生成.so库并调用（作者：lei_notes）<sup>【注】</sup>](https://blog.csdn.net/lei_notes/article/details/78548433 \"TOLINKS\")\n> - [【3】NDK开发笔记---CMake构建JNI（作者：xufei5789651）<sup>【注】</sup>](https://blog.csdn.net/xufei5789651/article/details/73694634 \"TOLINKS\")\n> - [【4】AndroidStudio2.3 NDk Cmake配置（作者：Android小屋）<sup>【注】</sup>](https://blog.csdn.net/pkandroid/article/details/67074346 \"TOLINKS\")\n> - [【5】AS2.2使用CMake方式进行JNI/NDK开发（作者：于连林520wcf）<sup>【注】</sup>](https://www.jianshu.com/p/cb3064450688 \"TOLINKS\")\n> - [【6】android ndk 调用C/C++函数（作者：至信）<sup>【注】</sup>](https://blog.csdn.net/qq_34329508/article/details/52330437 \"TOLINKS\")\n> - [【7】makefile中的CPPFLAGS LDFLAGS CFLAGS选项详解（作者：shenhuxi_yu）<sup>【注】</sup>](https://blog.csdn.net/shenhuxi_yu/article/details/79788760 \"TOLINKS\")\n","tags":["Android","CMake","NDK","JNI","CMakeList"],"categories":["Android"]},{"title":"Android五大存储——SharedPreference","url":"/post/android/android-sharedpreference/","content":"<!-- more -->\n\n***\n\nAndroid 中获取 SharedPreferences 的方式有 3 种：\n\n（1）Context 中的 ``getSharedPreferences(String name, int mode)``\n  \nname 用于指定 SharedPreference 的文件名，如果不存在则创建。mode 用于指定操作模式，有以下几种选择：\n\n  - Context.MODE_PRIVATE：只能被本应用程序读、写。\n  - Context.MODE_WORLD_READABLE：（Android 4.2 已弃用。）能被其他应用程序读，但不能写。\n  - Context.MODE_WORLD_WRITEABLE：（Android 4.2 已弃用。）能被其他应用程序读、写。\n  - Context.MODE_APPEND：检查文件是否存在，存在则追加内容，否则创建新文件。\n\n（2）Activity 中的 ``getPreferences(int mode)`` \n与 ``getSharedPreferences()`` 类似，但自动将当前活动的类名作为 SharedPreferences 的文件名。\n\n（3）PreferenceManager 中的 ``getDefaultSharedPreferences(Context context)``\n 这是一个静态方法，自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。","tags":["Android","五大存储","SharedPreference"],"categories":["Android"]},{"title":"Android四大组件——ContentProvider","url":"/post/android/android-contentprovider/","content":"<!-- more -->\n\n***\n\nContentProvider 使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过 ContentResolver 类从该内容提供者中获取或存入数据。\n\n只有需要在多个应用程序间共享数据是才需要内容提供者，且必须存储在一个内容提供者中。好处是可以统一数据访问方式。例如通讯录数据被多个应用程序使用。\n\nContentProvider 使用 URI（Universal Resource Identifier，统一资源定位符）来唯一标识其数据集，URI 以 ``content://`` 作为前缀。通常不会直接使用 ContentProvider 类的对象，大多数是通过 ContentResolver 对象实现对 ContentProvider 的操作。\n\n一个 ContentProvider 应该包括或重写如下方法：\n\n```java\npublic class DemoContentProvider extends ContentProvider {\n    private static final String AUTHORITY = \"lsl.demo.DemoContentProvider\";\n\n    // 匹配成功后返回的匹配码\n    private static final int MATCH_CODE = 100;\n\n    // 用于判断数据请求的 URI 是否匹配\n    private static UriMatcher uriMatcher;\n\n    // 该 APP 用于共享的数据集\n    private DemoData demoData;\n\n    // 数据改变后通知该 URI\n    private static final Uri NOTIFY_URI = Uri.parse(\"content://\" + AUTHORITY + \"/data\");\n\n    static {\n        // 若匹配不成功则返回 NO_MATCH == -1\n        uriMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n\n        //添加预留需要匹配的 URI\n        uriMatcher.addURI(AUTHORITY, \"data\", MATCH_CODE);\n    }\n\n    @Override\n    public boolean onCreate() {\n        demoData = DemoData.getInstance();\n        return false;\n    }\n\n    @Nullable\n    @Override\n    public Cursor query(@NonNull Uri uri, @Nullable String[] projection,\n                        @Nullable String selection, @Nullable String[] selectionArgs,\n                        @Nullable String sortOrder) {\n        // 执行数据的增删改查前先验证请求的 URI 和预留的 URI 是否匹配\n        if (uriMatcher.match(uri) == MATCH_CODE){\n            Cursor cursor = demoData.queryData();\n            return cursor;\n        }\n        return null;\n    }\n\n    @Nullable\n    @Override\n    public String getType(@NonNull Uri uri) { return null; }\n\n    @Nullable\n    @Override\n    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {\n        if (uriMatcher.match(uri) == MATCH_CODE){\n            demoData.insertData(values);\n            notifyChange();\n        }\n        return null;\n    }\n\n    @Override\n    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {\n        if (uriMatcher.match(uri) == MATCH_CODE){\n            int deleteCount = demoData.deleteData();\n            notifyChange();\n            return deleteCount;\n        }\n        return 0;\n    }\n\n    @Override\n    public int update(@NonNull Uri uri, @Nullable ContentValues values,\n                      @Nullable String selection, @Nullable String[] selectionArgs) {\n        if (uriMatcher.match(uri) == MATCH_CODE){\n            int updateCount = demoData.updateData();\n            notifyChange();\n            return updateCount;\n        }\n        return 0;\n    }\n\n    private void notifyChange(){\n        getContext().getContentResolver().notifyChange(NOTIFY_URI, null);\n    }\n}\n```\n\n在其他应用中使用 ContentResolver 获取数据：\n\n```java\nContentResolver contentResolver = getContentObserver();\n```\n\n非必须的可选功能：如果需要对 URI 指向的数据监听变化，则需要重写并注册 ContentObserver，并传入一个 Handler 以在数据发生变化时通过 Handler 通知主线程更新 UI：\n\n```java\npublic class DemoContentProvider {\n    private Handler Handler;\n    public MyContentObserver(Handler handler) {\n        super(handler);\n        this.Handler = handler;\n    }\n\n    @Override\n    public void onChange(boolean selfChange) {\n        super.onChange(selfChange);\n    }\n\n    @Override\n    public void onChange(boolean selfChange, Uri uri) {\n        super.onChange(selfChange, uri);\n        Message message = Message.obtain();\n        message.obj = uri;\n        Handler.sendMessage(message);\n    }\n}\n```\n\n并且在需要接收数据的 ContentResolver 中注册该 ContentObserver：\n\n```java\nprivate static final String AUTHORITY = \"lsl.demo.DemoContentProvider\";\nprivate static final Uri DATA_URI = Uri.parse(\"content://\" + AUTHORITY + \"/data\");\ncontentResolver.registerContentObserver(DATA_URI, true, new DemoContentObserver(handler));\n```\n\n当需要对某个 ContentProvider 提供的数据增删改查时：\n\n```java\n// 查询\nCursor cursor = contentResolver.query(DATA_URI, null, null, null, null, null);\nif (cursor != null && cursor.getCount() > 0) {\n    while (cursor.moveToNext()) {\n        dataValue1 = cursor.getXXX(cursor.getColumnIndex(\"column1\"));\n        dataValue2 = cursor.getXXX(cursor.getColumnIndex(\"column2\"));\n        ......\n    }\n\n// 插入\nContentValues contentValues = new ContentValues();\ncontentValues.put(\"culumn1\", dataValue1);\ncontentValues.put(\"culumn2\", dataValue2);\n......\ncontentResolver.insert(DATA_URI, contentValues);\n\n// 删除\ncontentResolver.delete(DATA_URI, null, null);\n```\n\n可以看出，对一个 App 共享的数据集，通常是通过 ContentResolver 处理的，而 ContentProvider 更像是提供了一个可以处理数据的接口，其定义了入口 URI，调用增删改查时的具体逻辑，并返回数据处理的结果。","tags":["Android","四大组件","ContentProvider"],"categories":["Android"]},{"title":"Android四大组件——BroadcastReceiver","url":"/post/android/android-broadcastreceiver/","content":"<!-- more -->\n\n***\n\nBroadcastReceiver 本质上通过设置过滤来有选择地响应某些事件，例如网络状态的变化、锁屏的变化等等，其本身没有用户界面，但可以启动 Activity 或 Service，或使用 NotificationManager 通知用户。\n\nBroadcastReceiver 有两种注册方式：在 Manifest 中静态注册、在代码中通过 ``registerReceiver()`` 动态注册。在 Manifest 中静态注册的广播接收会随系统的启动而保持活跃，即便 App 未运行，只要接收到指定广播均会触发响应。\n\n广播按照类型分为两种：全局广播和本地广播\n\n  - 全局广播：发出的广播可以被其他任意的应用程序接收，或者可以接收来自其他任意应用程序的广播。\n  - 本地广播：只能在应用程序的内部进行传递的广播，广播接收器也只能接收内部的广播，不能接受其他应用程序的广播。\n\n按照广播机制也可以分为两种：标准广播和有序广播\n\n  - 标准广播：所有的接收者都会接收事件，不可以被拦截，不可以被修改。\n  - 有序广播：按照优先级，逐级向下传递，接收者可以修改广播数据，也可以终止广播事件。\n\n自定义广播接收需要重写 ``onReceive()`` 方法以在接收到广播后响应。由于广播接收不允许开启多线程，因此不应在此处做耗时操作，耗时较长会导致 Crash。广播接收通常作为一个通知者，在接收到特定的消息后通知 Activity 或 Service 进行处理，或是显示地直接通知用户。\n\n创建一个自定义的广播接收器：\n\n```java\npublic class DemoBroadcastReceiver extends BroadcastReceiver {\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        // 接收广播后的响应\n    }\n}\n```\n\n<br/>\n\n## 4.1 全局广播和全局广播接收器\n\n全局广播发送的广播可以被所有全局广播接收器接收，即使注册接收器的 App 并未启动。同样，全局广播接收器能接收到所有全局广播，即使这些广播接收器的 App 并未启动。\n\n若使用动态注册，则需要监听广播的地方设置过滤，且广播接收器跟随组件的生命周期，在组件结束前必须手动销毁广播接收器：\n\n```java\nDemoBroadcastReceiver demoBroadcaseReceiver = new DemoBroadcaseReceiver();\nIntentFilter intentFilter = new IntentFilter();\n// 监听网络变化\nintentFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\");\n\n// 动态注册\nregisterReceiver(demoBroadcaseReceiver, intentFilter);\n// 销毁广播接收器，通常可以放进 onDestroy() 中处理\nunregisterReceiver(demoBroadcaseReceiver);\n```\n\n若使用 Manifest 静态注册则如下声明：\n\n```java\n<receiver\n    android:name=\".DemoBroadcastReceiver\"\n    android:exported=\"true\"\n    android:enabled=\"true\">\n    <intent-filter>\n        <action android:name=\"broadcast.action.DEMO_NOTIFY\">\n    </intent-filter>\n</receiver>\n```\n\n当然，也可以监听自定义的广播，只需要将广播过滤内容存进 Intent 内并发送即可：\n\n```java\n// 直接构造\nIntent intent = new Intent(\"broadcast.action.DEMO_NOTIFY\");\n\n// 设置 action\nIntent intent = new Intent();\nintent.setAction(\"broadcast.action.DEMO_NOTIFY\")\n\n// 发送标准广播\nsendBroadcast(intent);\n```\n\n当需要发送有序广播时，则需要设置广播的优先级。广播会优先发送给优先级更高的接收器，然后逐级发送给更低优先级的接收器，优先级的范围为：-1000 ~ 1000。\n\n  - 静态注册全局广播的优先级只需给全局接收器的 intent-filter 添加优先级属性：\n\n```java\n<intent-filter android:priority=\"100\">\n```\n\n  - 或使用动态注册设置全局接收器优先级：\n\n```java\nintentFilter.setPriority(100);\n\n// 动态注册\nregisterReceiver(demoBroadcaseReceiver, intentFilter);\n// 销毁广播接收器\nunregisterReceiver(demoBroadcaseReceiver);\n```\n\n  - 在发送有序全局广播的地方：\n\n```java\nsendOrderedBroadcast(intent, null);\n```\n\n如果想要发送的广播只被特定的接收器接收，可以设置权限，则只有具有对应权限的接收器才能接收到广播。\n\n  - 静态注册全局广播设置权限：\n\n```java\n// 自定义权限需要先在 Manifest 顶层声明\n<permission android:name = \"broadcast.permission.DEMO_PERMISSION\"/>\n\n<receiver\n    android:name=\".DemoBroadcastReceiver\"\n    android:permission=\"broadcast.permission.DEMO_PERMISSION\">\n</receiver>\n```\n\n  - 动态注册全局接收器设置权限：\n\n```java\nregisterReceiver(demoBroadcaseReceiver, intentFilter, \"broadcast.permission.DEMO_PERMISSION\", null);\n```\n\n  - 发送全局广播时加上权限即可：\n\n```java\n// 发送带权限的标准广播\nsendBroadcast(intent, \"broadcast.permission.DEMO_PERMISSION\");\n// 发送带权限的有序广播\nsendOrderedBroadcast(intent, \"broadcast.permission.DEMO_PERMISSION\");\n```\n\n<br/>\n\n## 4.2 本地广播和本地广播接收器\n\n本地广播发送的广播只能被当前 App 中注册的本地广播接收器接收，同样，本地广播接收器也只能接收当前 App\n 发送的本地广播。\n\n发送本地广播和接收本地广播与全局的非常类似，只有使用的类和方法有些许区别。需要注意的是，由于静态注册主要是为了能在 App 不启动时也能响应广播，而本地广播接收器仅能接收本地广播，因此只能通过动态注册。\n\n  - 动态注册本地广播接收器：\n\n```java\nDemoBroadcastReceiver demoBroadcaseReceiver = new DemoBroadcaseReceiver();\nIntentFilter intentFilter = new IntentFilter();\n// 监听网络变化\nintentFilter.addAction(\"broadcast.action.DEMO_NOTIFY\");\n\nLocalBroadcastManager localBroadcastManager = new LocalBroadcastManager.getInstance(context);\n\nlocalBroadcastManager.registerReceiver(demoBroadcaseReceiver, intentFilter);\n// 销毁广播接收器，通常可以放进 onDestroy() 中处理\nlocalBroadcastManager.unregisterReceiver(demoBroadcaseReceiver);\n```\n\n  - 发送本地广播：\n\n```java\nIntent intent = new Intent(\"broadcast.action.DEMO_NOTIFY\")\n// 发送本地标准广播\nlocalBroadcastManager.sendBroadcast(intent);\n// 发送本地有序广播\nlocalBroadcastManager.sendBroadcastSync(intent);\n```\n\n本地广播不支持权限过滤，因此无法设置 Permission。","tags":["Android","四大组件","BroadcastReceiver"],"categories":["Android"]},{"title":"Android四大组件——Service","url":"/post/android/android-service/","content":"<!-- more -->\n\n***\n\nService 可以在后台执行长时间而无界面的操作，且存在于主线程中。可以通过 startService() 和 bindService() 两种方法启动。全部 Service 都要在 Manifest 内声明。\n\nstartService() 后该 Service 即变为 stared 状态，处于后台运行中，与启动它的 Activity 生命周期无关，除非手动 ``stopService()`` 终止或被 Android 系统回收。bindService() 后该 Service 为 bound 状态，生命周期与 Activity 绑定，Activity 销毁则 Service 也被销毁。\n\nService 有 3 类：\n\n  - Foreground Service：执行一些用户可感知的操作，使用 ``startService()`` 启动。如 Audio播放。\n  - BackGround Service：用户不可感知的后台操作，使用 ``startForegroundService()`` 启动。如监控、轮询拉取等。\n  - Bound Service：主要提供 C / S 接口，允许组件与 Service 通信或跨进程通信，使用 ``bindService()`` 启动。\n\n必须在 Manifest 中注册：\n\n```java\n<service android:name=\".DemoService\">\n    <intent-filter>\n        <action android:name=\"service.DemoService\"/>\n    </intent-filter>\n</service>\n```\n\n以 start 方式启动 Service：\n\n```java\nIntent intent = new Intent(context, DemoService.class);\nstartService(intent);\nstopService(intent);\n```\n\n如果要通过 bind 方式绑定 Service，需要在 Service 中返回 Binder 类的实例：\n\n```java\n// 自定义 Service 类\npublic class DemoService extends Service {\n    \n    public class BinderInstance extends Binder {\n        public DemoService getServiceInstance() {\n            return DemoService.this;\n        }\n    }\n\n    // 通过 Binder 实现 Client 和 Service 之间的通信\n    private BinderInstance binderInstance = new BinderInstance();\n\n    @Override\n    public void onCreate() { super.onCreate(); }\n \n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) { return START_NOT_STICKY; }\n \n    // 在 Service 被绑定时返回 Binder 的实例对象，并通过 Binder 的实例对象进一步返回 Service 的实例对象，从而直接调用 Service 中的方法进行通信。\n    @Nullable\n    @Override\n    public IBinder onBind(Intent intent) {return binderInstance; }\n \n    @Override\n    public boolean onUnbind(Intent intent) { return false; }\n \n    @Override\n    public void onDestroy() { super.onDestroy(); }\n\n    // 可以由外部调用的方法\n    public void setMission() { }\n}\n```\n\n然后在 Actiivty 中获取 Binder 和 Service 的实例对象：\n\n```java\n// 绑定 Service 的 Actiivty\npublic class ClientActivity extends AppCompatActivity {\n\n    private DemoService demoService = null;\n\n    private ServiceConnection serviceConnection = new ServiceConnection() {\n        @Override\n        public void onServiceConnected(ComponentName name, IBinder binder) {\n            // 获取 Binder 实例对象\n            DemoService.BinderInstance binderInstance = (DemoService.BinderInstance) binder;\n            \n            // 获取 Service 实例对象\n            DemoService.BinderInstance = binderInstance.getServiceInstance();\n        }\n\n        @Override\n        public void onServiceDisconnected(ComponentName name) { }\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // 直接指定 Service\n        Intent intent = new Intent(this, DemoService.class);\n        // 或使用 action 过滤\n        intent.setAction(\"service.DemoService\");\n        bindService(intent, serviceConnection, BIND_AUTO_CREATE);\n        unbindService(serviceConnection);\n    }\n}\n```\n\n除了使用 Binder 方式以外，Activity 与 Service 之间的通信还能通过 BroadCastReceiver 以及 EventBus 的方式实现。","tags":["Android","四大组件","Service","前台服务","后台服务"],"categories":["Android"]},{"title":"Android四大组件——Activity","url":"/post/android/android-activity/","content":"<!-- more -->\n\n***\n\n# 1. Activity\n\n<br/>\n\n## 1.1 Activity生命周期\n\nActivity 即一个用户界面，可以理解成一个视图容器，容器内可以包裹和展示各类控件。全部 Activity 都需要在 Manifest 内声明。\n\nActivity 的生命周期为：``onCreate()`` - ``onStart()`` - ``onResume()`` - ``onPause()`` - ``onStop()`` - ``onDestroy()``【或 ``onRestart()`` - ``onStart()``...】。\n\n需要注意的是：``onStop()`` 在 Activity 不可见时才调用，例如 AActivity 启动 BActivity，若 BActivity 是透明或弹窗形式（``android:theme=\"@android:style/Theme.Dialog\"``），则 AActiivty 不会调用 ``onStop()``。\n\nActivity 的 ``onSaveInstanceState()`` 和 ``onRestoreInstanceState()`` 并不是生命周期方法，不同于生命周期方法，它们并不一定会被触发。当用户按 Home 键返回桌面、\b从多任务切换应用、锁屏、屏幕方向变化、启动新的 Activity时，或者当应用遇到意外情况（如内存不足）且 Activity 由系统销毁时，则 ``onSaveInstanceState()`` 会被调用。但是当用户主动销毁一个 Activity（例如在应用中按返回键）时，``onSaveInstanceState()`` 就不会被调用。通常 ``onSaveInstanceState()`` 只适合用于保存一些临时性的状态，而 ``onPause()`` 适合用于数据的持久化保存。\n\n如果一个 Activity 被打开过，然后被置入任务栈顶端（例如切换到另一个 Activity 且没有再次切换新 Activity），且此时处于 ``onPause()``、``onStop`` 状态，则当有一个 Intent 启动该 Activity，会先调用 ``onNewIntent()``，然后才调用 ``onRestart()`` - ``onStart()`` - ``onResume()``。\n\nActivity 必须在 Manifest 中注册：\n\n```java\n// Manifest 中声明\n<activity\n    android:name=\"lsl.demo.OtherModuleActivity\">\n    <intent-filter>\n        <action android:name=\"module.demo.OtherModuleActivity\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n    </intent-filter>\n</activity>\n```\n\n<br/>\n\n## 1.2 Context\n\nActivity、Application 都是 Context 的子类，而 Context 是抽象类 ContextImpl 的实现。context 维护当前 Activity 的生命周期，而 Application 维护整个应用的生命周期，因此一些全局变量可以放在 Application 中。\n\n***\n\n# 2. Activity的启动和退出\n\n<br/>\n\n## 2.1 启动Activity\n\n直接启动 Actiivty：\n\n```java\nIntent intent = new Intent(context, DemoActivity.class);\n// 直接插入数据\nintent.putExtra(\"key1\", value)\nintent.putExtra(\"key2\", value)\n// 通过 Bundle\nBundle bundle = new Bundle();\nbundle.putXXX(String key1, XXX value);\nbundle.putXXX(String key2, XXX value);\nintent.putExtra(bundle);\n\nstartActivity(intent);\n```\n\n启动跨 Module 的 Activity，需要先在目标 Activity 注册的 Manifest 文件中设置一个 Action：\n\n```javascript\n<activity android:name=\"demo.DemoActivity\">\n    <intent-filter>\n        <action android:name=\"demo.customActionName\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n    </intent-filter>\n</activity>\n```\n\n然后利用 Manifest 中设置的 ``demo.customActionName`` 来启动：\n\n```java\nIntent intent = new Intent();\nintent.setAction(\"demo.customActionName\");\nstartActivity(intent)\n```\n\n需要注意的是：默认情况下，假如这里设置的 ``demo.customActionName`` 和别的 App 某个 Activity 设置的一样，则通过 ``setAction`` 启动时只会启动本 App 中的 Activity。如果想要让 Activity 可以被别的 App 唤起，则需要添加一个 ``export`` 属性（不显式设置该属性时默认为 false）：\n\n```javascript\n<activity\n    android:name=\"demo.DemoActivity\"\n    android:exported=\"true\"\n    >\n    ......\n</activity>\n```\n\n<br/>\n\n# 2.2 退出Activity\n\n  - 当一个 Application 已开启了多个 Activity，则在安全退出时，可以发送预定义的广播，在所有被开启的 Activity 中注册广播监听，监听到广播后各自调用 ``finish()`` 即可。\n\n  - 当一个应用有层叠 Activity（即 AActivity 启动 BActivity，BActivity 启动 CActivity...）时，可在每个 Activity 启动新 Activity 时，使用 ``startActivityForResult()`` 替代 ``startActivity()``，并在 ``onActivityResult()`` 中将自己 ``finish()``。\n\n  - 用 List 等记录每个启动的 Activity，并在需要时分别关闭。需要注意的是，使用 List 存放 Activity 有内存泄露的风险，当 Activity 关闭后，要及时清掉对应 List 中的引用。\n\n  - 在启动 Activity 时，给 Intent 设置 Flag：``intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)``，则系统会在新 Activity 启动后将其上的所有 Activity 销毁，效果等效于给新 Activity 配置 SingleTop 启动模式。\n\n***\n\n# 3. Activity启动模式\n\nActivity 有 4 种启动模式：\n\n  - 1. ``standard``\n  - 2. ``singleTop``\n  - 3. ``singleTask``\n  - 4. ``singleInstance``\n\n需要先了解到，Android 中 Activity 是存在堆栈（任务栈）中的，启动一个 Activity 时会将其压栈，销毁时弹出，当然不同启动模式会导致 Activity 任务栈产生不同的行为。同时一个 App 进程也可以拥有多个 Activity 任务栈，例如 ``singleInstance`` 模式。\n\n<br/>\n\n## 3.1 Standard模式\n\nStandard 就是标准默认模式，启动一个 Activity 时，不论 Activity 在任务栈中是否已经有实例，都新建一个实例并压入往当前任务栈。当前 Activity 在当前任务栈可以有多个实例，每个实例也可以在不同任务栈。\n\n简单来说，也就是每次启动一个 Activity 都当做一个新的 Actviity 创建实例并压进对应的任务栈。需要注意的是，Standard 模式并不会创建任务栈，这也是为什么使用 ApplicationContext 启动，或在 Service 中以 Standard 方式启动 Activity 时会报错：\n\n```java\nandroid.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?\n```\n\n因为 ApplicationContext 和 Service 并没有任务栈。\n\nStandard 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“>” 表示 <font color=red>栈顶</font>）：\n\n| 当前任务栈 | 如果返回 | 执行任务 |\n| :------  | :------ | :-----: |\n| /A> | 退出 | Standard Start B |\n| /AB> | /A> | Standard Start B |\n| /ABB> | /AB> | Standard Start A |\n| /ABBA> | /ABB> | - |\n\n<br/>\n\n## 3.2 SingleTop模式\n\nSingleTop 即栈顶唯一模式，启动一个 Activity 时，如果该 Activity 已在栈顶则不会新建一个 Activity 实例而是复用它，否则其行为和 Standard 模式一致。\n\nSingleTop 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“>” 表示 <font color=red>栈顶</font>）：\n\n|   | 当前任务栈 | 如果返回 | 执行任务 |\n| - | :------  | :------ | :-----: |\n| 1 | /A> | 退出 | SingleTop Start B |\n| 2 | /AB> | /A> | SingleTop Start B |\n| 3 | /AB> | /A> | SingleTop Start A |\n| 4 | /ABA> | /AB> | SingleTop Start B |\n| 5 | /ABAB> | /ABA> | - |\n\n<br/>\n\n## 3.3 SingleTask模式\n\nSingleTask 即任务栈唯一模式，启动一个 Activity 时，如果任务栈中存在该 Activity 实例，则复用它，否则才创建一个新的 Activity 实例。SingleTask 和 SingleTop 的区别在于，SingleTop 只在栈顶 Activity 和要启动的 Activity 相同时才复用，而 SingleTask 是每个 Activity 在当前整个任务栈中都只有一个实例。\n\nSingleTask 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“>” 表示 <font color=red>栈顶</font>）：\n\n|   | 当前任务栈 | 如果返回 | 执行任务 |\n| - | :------  | :------ | :-----: |\n| 1 | /A> | 退出 | SingleTask Start B |\n| 2 | /AB> | /A> | SingleTask Start B |\n| 3 | /AB> | /A> | SingleTask Start A |\n| 4 | /BA> | /B> | Standard Start B |\n| 5 | /BAB> | /BA> | - |\n\n<br/>\n\n## 3.4 SingleInstance模式\n\nSingleInstance 即唯一实例模式），启动一个 Activity 时，寻找所有的任务栈，如果某个任务栈中存在该 Activity 实例，则切换到该任务栈，否则新建一个任务栈并创建该 Activity 实例。\n\n重点在于：任务栈不是唯一的，一个 App 可以有多个任务栈，就像 Android 系统的后台应用列表一样，里面包括了多个应用，而每个应用又管理自己的多个任务栈（可以理解为<font color=#EB6D39>任务栈的总栈</font>），每个任务栈又分别管理包含的 Activity。\n\nSingleInstance 启动方式任务栈的行为实例如下（其中 “/” 表示 <font color=red>栈底</font>，“>” 表示 <font color=red>栈顶</font>，任务栈之间用 “-” 连接，右侧的任务栈为最新任务栈，M 为最开始以 Standard 启动的 Activity）：\n\n|   | 当前任务栈 | 如果返回 | 执行任务 |\n| - | :------  | :------ | :-----: |\n| 1 | /M> | 退出 | SingleInstance Start A |\n| 2 | /M> - /A> | /M> | SingleInstance Start B |\n| 3 | /M> - /A> - /B> | /M> - /A> | SingleInstance Start A |\n| 4 | /M> - /B> - /A> | /M> - /B> | Standard Start C |\n| 5 | /B> - /A> - /MC> | /B> - /A> - /M> | 返回 |\n| 6 | /B> - /A> - /M> | /B> - /A> | 返回 |\n| 7 | /B> - /A> | /B> | 返回 |\n| 8 | /B> | 退出 | - |\n\n前 3 步都比较好理解，反正就是整个 App 所有任务栈都只允许有一个实例。重点在从第 4 步开始，由于最开始的 M 是 Standard 模式启动的，而第 4 步中 C 也是 Standard 模式，也就导致本来在最底下的任务栈 ``/M>`` 被移到了 “任务栈的总栈” 的栈顶，并将 C 压入了 ``/M>`` 所在的这个栈顶，因此从 C 返回的时候会先返回到 M，然后才是按顺序下来的 A → B。","tags":["Android","四大组件","Activty","启动模式","生命周期"],"categories":["Android"]},{"title":"JVM内存模型","url":"/post/java/java-jvm/","content":"<!-- more -->\n\n前言：Java 和 Android 面试中，堆、栈、JVM 内存模型等几乎是必问题，但其实平时口头上，对堆、栈、堆栈、堆区、栈区等等的概念是混淆的，因此专门用一篇文章来记录总结。\n\n***\n\n# 1. 堆、栈和队列\n\n首先需要明确的是，堆、栈、队列是数据结构，堆是一种优先队列，可以采用二叉树实现；栈是一种线性表，其特点是：后进先出（Last In First Out，LIFO）；队列也是一种线性表，其特点是：先进先出（First In First Out，FIFO）。\n\n<br/>\n\n## 1.1 堆（Heap）\n\n堆（Heap）总是一颗完全二叉树，且某个节点的值总是不大于或不小于父节点的值。若某节点总是不大于父节点的值（即父节点大于等于子节点），称为最大堆或大根堆（Max Heap）；反之称为最小堆或小根堆（Min Heap）。常见的堆有：二叉堆、斐波那契堆等。\n\n※ | 注：完全二叉树可以这么理解：如果有一棵二叉树，只有最末端的节点可以有 0、1、2 个子节点，倒数第二层的节点要么没有子节点，要么必须有 2 个子节点，并且末端的节点都集中在左侧若干位置上，则该树称为完全二叉树。完全二叉树如下图所示：\n\n<center>\n\n![完全二叉树图示](/post_files/java/java-jvm/complete_binary_tree.jpg \"TOPICS\")\n\n</center>\n\n完全二叉树的详细解释可参考：[《百度百科——完全二叉树》](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin \"TOLINKS\") 或 [《完美二叉树, 完全二叉树和完满二叉树》](https://blog.csdn.net/qq_22642239/article/details/80774013 \"TOLINKS\")。\n\n<br/>\n\n## 1.2 栈（Stack）\n\n栈（Stack）是一种运算受限的线性表，其限制在于：仅允许从表的一端进行插入和删除操作。插入到栈中（入栈）的操作叫压栈（Push），从栈中删除（出栈）的操作叫弹出（Pop）。后入栈的数据先出栈（LIFO），类似于枪械弹匣，最后一颗压进弹匣的子弹在最上面，是第一发被打出去的。\n\n<br/>\n\n## 1.3 队列（Queue）\n\n队列（Queue）和栈类似，都是线性表，不同的是数据存取的顺序。队列中插入数据和取出数据分别在表的两端，且先插入的数据最先被取出。\n\n***\n\n# 2. JVM中的5个区\n\n在 JDK 1.8（不含）之前，JVM 的内存模型分为 5 个区：堆区、栈区、方法区、本地方法区、程序计数器。\n\n堆区（Heap）和栈区（Stack）是内存模型，虽然英文一样，而且也常常被简称为堆和栈，但实际上他们和数据结构中的堆、栈是完全不一样的概念，底层也并不是直接使用数据结构中的堆和栈的存储方式来实现，只是比较类似。\n\n堆区是存储的单位，而栈区是运行时的单位。通俗地说：堆区解决程序数据存储的问题，负责管理数据怎么放、放在哪；而栈区解决程序运行的问题，负责管理程序怎么运行、怎么处理堆中的数据。\n\n<br/>\n\n## 2.1 堆区（Heap Area）\n\n堆区通常和进程相关，进程建立初始化时会分配默认堆区，运行过程中也可以申请额外的堆区空间，但在需要手动释放，否则会导致内存泄漏，未释放的内存在进程结束时由 OS 回收。堆区分为全局堆和局部堆，全局堆就是所有未分配的堆区空间，局部堆则是用户分配的堆区空间。多个线程可以访问同一个堆区，当然也可以申请额外的堆区空间。\n\n在 Android 中，堆是 Dalvik 的内存数据区，用于存储：对象实例数据、方法内部的复杂类型变量、动态属性。\n  - （1）对象实例数据：包括对象实例的属性、属性类型、对象本身的类型标记等，但是并不会保存对象实例的方法（类方法），实例方法属于数据指令，保存在方法区中。\n  - （2）方法内部的复杂类型变量：例如方法内使用了自定义类的实例对象等。\n  - （3）动态属性：没有使用 ``static`` 修饰的类成员属性，因为这些属性可能是自定义类的实例对象，这些对象的内存大小是不可预估、动态变化的。需要注意的是，类成员的基本数据类型，也是存放在堆中。\n\n<font color=#EB6D39>\n\n堆区的内存是不连续且无序的，分配和释放内存的成本都比较高。例如在分配堆内存时，可能需要在堆区搜索多个空间，如果内存碎片（多次分配和释放后，会造成占用内存和可用内存互相掺杂）太多，则会消耗较长时间来搜索可用内存区，甚至需要向 OS 申请分配新的堆区空间，因此堆区的效率较低，但是内存分配更加自由，内存的分配和释放可以手动控制。\n\n※ | 注：实际上，如果 JVM 开启了 **逃逸分析（Escape Analysis）**，会在满足一定条件时，将本应存在堆区中的变量存在栈区，便于内存的释放。例如：\n\n```java\npublic void demoFun() {\n    DemoClass demoClass = new DemoClass();\n    demoClass.demoData = 5;  // int 型\n    System.out.println(\"Demo data is : \" + demoClass.demoData);\n}\n```\n\n本来，``demoClass.demoData`` 虽然是基本数据类型 int，但由于它是一个类成员动态属性，因此随所属对象 ``demoClass`` 被分配在堆区。如果 JVM 开启了逃逸分析，则优化后会将该段代码转换为如下的形式运行：\n\n```java\npublic void demoFun() {\n    int demoData = 5;\n    System.out.println(\"Demo data is : \" + demoData);\n}\n```\n\n这样就将 ``demoData`` 存在了栈区，提高了内存分配和回收的效率。但是逃逸分析优化有一定的前提：原本存在堆区的对象，仅在方法体内部有效。如果该对象与方法体外部有交互（即逃逸），则不会优化。例如：\n\n```java\npublic int demoFun() {\n    DemoClass demoClass = new DemoClass();\n    demoClass.demoData = 5;  // int 型\n    System.out.println(\"Demo data is : \" + demoClass.demoData);\n    return demoClass.demoData;  // 逃逸到外部\n}\n```\n\n</font>\n\n另外，堆区本身又有 3 个区域划分：新生代（Young Generation）、老年代（Old Generation）、永久代（Permanent Generation）。\n\n（1）新生代：所有新生成的对象都在新生代，新生代的目标就是尽可能快速的收集生命周期短的对象。新生代又分为三个区（通常是两个 Survivor 区，但也可以增加）：Eden 区，Survivor 1 区，Survivor 2 区。\n\n  - Eden 区：大部分对象在 Eden 区生成，当 Eden 区满了 GC 后存活下来的对象将随机复制到其中一个 Survivor 区。\n  - Survivor区：当一个 Survivor 区满了 GC 后存活下来的对象，如果是来自 Eden 区，则复制到另一个 Survivor 区，如果是来自另一个 Survivor 区，则复制到老年代。\n\n通俗地说，如果一个对象首先在 Eden 区中被创建，Eden 经过 GC 后存活，则被复制到其中一个 Survivor 区，如果这个 Survivor 经过 GC 后还存活，则被复制到另一个 Survivor 区，如果另一个 Survivor 区经过 GC 后仍然存活，则复制到老年代。需要注意的是：两个 Survivor 区是平等的，没有优先级高低、顺序前后之分，都有可能接收来自 Eden 或另一个 Survivor 区传来的对象。Survivor 区可以手动配置为多于 2 个，即可增加对象在新生代中的时间，减小被复制到老年代的可能性。\n\n（2）老年代：在新生代中经过 N 次（N 即为新生代中区的数量）GC 后仍然存活的对象将进入老年代，通常都是生命周期比较长的对象。\n\n（3）永久代：一般用来存放类的信息（包括类名、类方法、字段信息等）、静态变量、常量池等不会改变的数据，但在 JDK 1.8 开始就使用元数据区取代了了永久代。\n\n<br/>\n\n## 2.2 栈区（Stack Area）\n\n栈区和线程相关，每个线程有自己独立的栈区且不共享，因此栈区是线程安全的。OS 在切换线程时会自动切换栈区（即切换 SS / ESP 寄存器）。栈区内存不需要手动分配和释放。\n\n在 Android 中，栈是 Dalvik 的内存指令区，用于存储：基本数据类型、方法内部的简单类型变量、对象地址。\n\n  - （1）基本数据类型：包括 byte，short，int，long，float，double，char，boolean，需要注意的是，直接在类成员变量中声明的基本数据类型属性，依然随对象实例一起存放在堆中。\n  - （2）方法内部的简单类型变量：例如基本数据类型。\n  - （3）对象地址：通常大多数对象都会存在堆区中，而把对象的引用（即对应在堆中的地址）存在栈区，当调用一个对象时，就可以快速地从栈区找到该对象的引用，并通过引用找到堆区中的实例。\n\n栈区存放的是多个栈帧，每个栈帧对应了可以被线程调用的一个方法，栈帧中包括：局部变量表（Local Variables）、操作数栈（Operand Stack）、指向当前方法所属类的运行时常量池的引用（Reference to Runtime Constant Pool，当方法内有 String 类型变量时，用于查询常量池中是否已经存在常量）、方法返回地址（Return Address）、以及一些额外的附加信息。当线程执行一个方法时，就会创建对应的栈帧，并将其压栈。方法执行完毕后即弹出。因此，线程当前执行的方法一定在栈区的顶部，而递归方法时，也相对更容易出现栈区内存溢出的情况。\n\n<font color=#EB6D39>\n\n由于栈区中存储的都是内存占用较小，且固定长度的变量，例如基本数据类型、对象的引用（仅仅只是一个地址，通常为 4 位，指向堆区或常量池中实际存放的对象），因此栈区的内存是连续、且在创建栈帧时就提前分配好的，所以栈区的内存不需要也无法手动管理，当调用所需变量时，仅需将指针按预定义的长度移动即可，因此分配和释放内存的效率都比堆区快得多。\n\n※ | 注：Java 中，对于 byte、short、char 这些基本数据类型，本来比 int 占用的内存更少，对一些标志位、临时变量等，使用这些代替 int 似乎应该效率更高，实际上 JVM 中，在处理这些数据的加法操作时，会先隐式转换成 int 类型再操作。例如以下代码会编译报错：\n\n```java\nbyte a = 1;\nbyte b = 2;\nbyte c = a + b;  // 编译报错：Type mismatch: cannot convert from int to byte\n```\n\n这么做的意义其实是在于，Java 中 int 和 float 是 4 字节 32 位，long 和 double 是 8 字节 64 位，这些类型都能以 4 字节为单位，位移 1 倍或 2 倍得到，而 byte、short、char 分别只有 1、2、2 字节，如果先统一转为 4 字节 int 类型，寻址的时候就能极大提高效率。当然选择 int 作为标准的原因主要也是因为 int 的长度在中间，如果选择 8 字节的 long 或 double，则会大量浪费内存空间，选择 2 字节的 char 或 short，则很多变量都需要不止一个内存块来存储，降低效率。\n\n</font>\n\n<br/>\n\n## 2.3 方法区（Method Area）\n\n方法区和堆一样，是线程间共享的。方法区用于存放：类的信息、静态成员变量、运行时常量池等。\n\n  - （1）类的信息：包括类名、方法信息、字段信息等，调用 ``Class.getName()`` 和 ``Class.isInterface`` 等方法时返回的数据都是来自方法区。\n  - （2）静态成员变量：Java 局部变量没有静态的概念，只有成员变量、成员方法可以设置为静态。\n  - （3）运行时常量池：类和接口被记载到 JVM 时，就会创建对应的运行时常量池。\n\n<font color=#EB6D39>\n\n不论是否静态，方法都存放在方法区，非静态的方法，Dalvik 会将其对象实例在 Stack 中的引用地址（指向了 Heap 中存储的实例），作为隐含的参数传入，这样在非静态方法在需要调用其实例对象的其他数据时，可以确保总能找到在 Heap 中存放的实例数据。因此，调用一个非静态方法，必须首先 new 一个实例对象，也即创建一个实例对象在 Stack 中的引用地址，然后再调用。而静态方法不需要传入隐含参数，因为方法区是线程间公开共享的，而且存放的都是相对唯一、不变的数据，因此静态方法可以直接通过 ``Class.method()`` 的形式调用。当然，由于没有传入隐含的 Stack 引用地址，也就无法找到 Heap 中存放的实例数据，静态方法内部是无法获取到实例对象的其他非静态数据的，这也是为什么静态方法中不能调用非静态方法、非静态成员变量，而非静态方法可以直接调用静态方法、静态成员变量的原因。\n\n静态成员变量只在 JVM 第一次载入类时加载，也因此内存中只会保留一份数据，因此也是存放在方法区中的，这也是为什么作用域比较小、使用频率比较低的一些标志位等等不建议设置成 ``public static`` 的形式，因为这会导致很多临时才使用的变量被加载进了方法区而不释放（JDK 1.7 之后在满足一定条件下，方法区也会 GC，但是相比栈区和堆区，方法区 GC 的频率很低，因此仍然不建议大量使用静态成员变量）。\n\n运行时常量池并不一定质保函 Class 文件常量池中的内容，也即并非只有代码中显示定义了 ``final`` 的成员变量才会进入常量池。例如 ``String.intern()`` 方法，其作用就是：如果一个字符串存在常量池中，则直接返回常量池中的引用，否则将该字符串存入常量池，再返回其引用。\n\n常量池的意义非常重要，之所以 String 内部都要做成常量，主要是因为字符串的重复率特别高，因此如果字符串不可变，常量池才便于管理。而且由于 String 的不可变性，HashMap、HashTable 等使用 String 作为 Key 时，JVM 可以在缓存 String 对象时缓存其 HashCode，极大提高执行效率。\n\n</font>\n\n<br/>\n\n## 2.4 本地方法栈（Native Method Stack）\n\n本地方法区和方法栈（也即栈区）比较类似，区别在于栈区是针对普通方法的，而本地方法栈是针对 Native 方法的。JVM 规范中没有强行规定本地方法栈的实现方式和数据结构，虚拟机可以自由实现，HotSpot 虚拟机就直接把栈区和本地方法栈合二为一。\n\n<br/>\n\n## 2.5 程序计数器（Program Counter Register）\n\nJVM 中的程序计数器和汇编中的程序计数器（CPU 中的寄存器）概念类似，都是用于指示下一条需要执行的指令，只不过 JVM 中的程序计数器并不是指向物理意义上的真实 CPU 内存地址。JVM 中的程序计数器是线程独有的，指向的是当前线程正在执行的字节码代码的行号，如果当前线程执行的是 Native 方法，则值为 ``null``。\n\n***\n\n# 3. JVM中的4个Segment\n\n如果在网上查阅 JVM 分区的内容，会出现两种回答：\n\n  - （1）JVM 内存模型分为 4 个区：Heap、Stack、Data Segment、Code Segment\n  - （2）JVM 内存模型分为 5 个区：Heap、Stack、Method、Native Method、Program Counter Register\n\n其实这两种分法都对，只不过是针对不同的场景分的，个人认为分为 5 个区的更加全面一些。两种分类中，Heap 和 Stack 都是一一对应的，关键是其他部分，方法区是一个特例。在 HotSpot 虚拟机中，由于早期（JDK 1.8（不含）之前）是直接将方法区设置为永久代（Permanent Generation），也即方法区内的所有数据都不会被 GC，因此方法区也被习惯称为永久代。而方法区同时对应了 Data Segment 和 Code Segment，方法区中存储字节码的位置称为 代码段（Code Segment），存储静态常量和字符串常量的位置称为数据段（Data Segment）。\n\n***\n\n# 4. JDK8内存模型的变化\n\n在 JDK 1.8 中，对之前 5 个内存区的划分做了一些改变。\n\n首先是使用 <font color=#EB6D39>元数据区 </font> 取代了方法区，但实际上元数据区的作用和原来方法区的作用是几乎一样的，只不过不再是永久代（针对 HotSpot 虚拟机，其他虚拟机例如 Oracle 的 JRockit 和 IDM 的 J9 本来就没有永久代）。\n\n其次，元数据区不再存放在虚拟机内存中了，而是直接使用本地内存（由 OS 管理的内存）。\n\n另外，原来的字符串常量池存放在方法区中，新版 JDK 放到了堆区。","tags":["Java","数据结构","内存模型","JVM内存区"],"categories":["Java"]},{"title":"Hexo博客DIY（X）其他DIY收录","url":"/post/blogdiy/blogdiy-x-others/","content":"<!-- more -->\n\n前言：收录了一些有趣、实用的 DIY。这些收录大部分是我的博客没有用上的，所以不太好给出明确的展示效果。引文原文大多数都有配图、或已部署到他们的博客上了，因此引出原文链接给各位读者查看，为保护版权就不作转载了，建议放到系列文章的最后再研究。\n\n***\n\n大部分我的博客用到过、或曾用到过的 DIY 都已记录在了 [博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\") 中，还有一些虽然我的博客没有用上，但看起来还是比较实用的功能、文章，都记录在这里供可能需要的读者查阅。\n\n# 1. MarkDown格式\n\n详情参考：\n\n  - [Markdown通用的常用语法说明（作者：seay）](https://www.jianshu.com/p/e989689a331d \"TOLINKS\")\n  - [简书 Markdown 常用数学符号汇总（作者：拓季）](https://www.jianshu.com/p/d60b844d3ba5 \"TOLINKS\")\n  - [【Markdown】markdown 输入数学符号（作者：xingxinmanong）](https://blog.csdn.net/xingxinmanong/article/details/78528791 \"TOLINKS\")\n\n包括基本 MarkDown 语法，和数学公式的语法。经常需要写数学公式的话，还是需要多看看多背背。\n\n***\n\n# 2. 文章加密\n\n详情参考：[hexo博文加密（作者：crazy_scott）](https://blog.csdn.net/crazy_scott/article/details/80996427 \"TOLINKS\")\n\n不过我本人比较拥抱开源，所以估计是用不上了。\n\n***\n\n# 3. 点击爱心特效\n\n详情参考：[Hexo NexT主题添加点击爱心效果（作者：asdfv1929）](https://asdfv1929.github.io/2018/01/26/click-love/ \"TOLINKS\")\n\n不过这个特效会导致双击选中、三击选中整行失效，所以没有引入。\n\n***\n\n# 4. 博客加载进度条\n\n详情参考：[Hexo博客NexT主题美化之顶部加载进度条（作者：潘高）](https://blog.csdn.net/u011236348/article/details/88146947 \"TOLINKS\")\n\n效果有很多种，而且作者很有心为每种效果都配了动图，我的博客为了协调性把进度条去掉了所以没有使用。\n\n***\n\n# 5. 自定义右上角GitHub标志\n\n详情参考：[GitHub Corners](http://tholman.com/github-corners/ \"TOLINKS\")\n\n这个随便找一个下载下来，都可以通过里面的颜色配置实现更高的自定义效果，Anyway，默认的黑白配就挺适合我这个码畜哈哈。\n\n***\n\n# 6. 侧栏添加“系列”标签\n\n详情参考：[给hexo博客添加系列文章功能（作者：hojun）](http://baijiahao.baidu.com/s?id=1604123889806467436&wfr=spider&for=pc \"TOLINKS\")\n\n或者比较简单的做法：[hexo下新建页面下如何放多个文章？（答主：匿名用户）](https://www.zhihu.com/question/33324071/answer/58775540 \"TOLINKS\")\n\n前者是通过增加一个自定义文章头部标签，然后在生成的时候添加一个遍历所有文章识别来实现的，需要对 JS 做修改，后者是直接通过“分类”功能实现的，更简单一些。前者稍微更符合要求一点，不过显示效果都没有太大差别，可以自由选择。\n\n***\n\n# 7. HexoEditor\n\n详情参考：[HexoEditor](https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md \"TOLINKS\")\n\nHexoEditor 是 GitHub 上一款专门为 Hexo 优化的开源 MarkDown 编辑器，基本上可以实现“所看即所得”，编写时的预览效果和最终博客上的展示效果几乎一致\n\n***\n\n# 8. MathJax公式支持\n\n详情参考：\n  - [Hexo 安装 LaTeX](https://www.jianshu.com/p/d95a4795f3a8 \"TOLINKS\")\n  - [MathJax语法](https://ihaoming.top/archives/171023e7.html#more \"TOLINKS\")\n  - [MathJax 语法参考](https://qianwenma.cn/2018/05/17/mathjax-yu-fa-can-kao/ \"TOLINKS\")\n  - [基本数学公式语法(of MathJax)](https://blog.csdn.net/ethmery/article/details/50670297 \"TOLINKS\")\n\n包括安装部署 MathJax，以及 LaTeX 公式的语法合集。\n\n还有一篇专门针对 Hexo 和 MathJax 不兼容问题的文章写得非常详细：\n\n  - [Hexo下mathjax的转义问题](https://segmentfault.com/a/1190000007261752 \"TOLINKS\")\n\n另外补充一点，目前网上普遍的做法是更换渲染引擎，老版本的 Hexo 尚不清楚，不过目前我使用的 ``hexo: 3.9.0`` ``hexo-cli: 2.0.0`` 原生渲染引擎 ``hexo-renderer-marked`` 已经支持 LaTeX 了，如果更换为 ``hexo-renderer-kramed``，会遇到的一个很 X 蛋的事是和各种 Html 标签冲突，比如 ``<center>`` 之类的，甚至 MarkDown 的原生图片语法 ``![]()`` 都会被转义，通常还会建议修改渲染的语法，跳过指定的符号，但总体就我个人的体验下来，似乎现在的 ``kramed`` 并没有原生 ``marked`` 好用，也可能我没有把 ``kramed`` 的语法改正确，不过为此找到了一个折中的方式：直接使用默认的 ``marked`` 引擎，但同样修改 marked 的语法文件，默认在：``Blog/node_modules/marked/lib/marked.js``，如果有手动另外安装过 marked，则修改：``Blog/node_modules/hexo-renderer-marked/node_modules/marked/lib/marked.js``：\n\n```javascript\nvar inline = {\n  // 删掉下面这行\n  //escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n  // ↓↓↓替换成下面这行↓↓↓\n  escape: /^\\\\([`*\\[\\]()#$+\\-.!_>])/,\n  // ↑↑↑替换成上面这行↑↑↑\n\n  ......\n  \n  // 删掉下面这行\n  //em: /^_([^\\s_])_(?!_)|^\\*([^\\s*<\\[])\\*(?!\\*)|^_([^\\s<][\\s\\S]*?[^\\s_])_(?!_|[^\\spunctuation])|^_([^\\s_<][\\s\\S]*?[^\\s])_(?!_|[^\\spunctuation])|^\\*([^\\s<\"][\\s\\S]*?[^\\s\\*])\\*(?!\\*|[^\\spunctuation])|^\\*([^\\s*\"<\\[][\\s\\S]*?[^\\s])\\*(?!\\*)/,\n  // ↓↓↓替换成下面这行↓↓↓\n  em: /^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  // ↑↑↑替换成上面这行↑↑↑\n\n  ......\n\n};\n```\n\n即可达到同样的效果，同时也不会导致标签冲突。详细的准备再另写一文。\n\n***\n\n# 9. 自定义域名\n\n详情参考：[Setting up an apex domain](https://help.github.com/en/articles/setting-up-an-apex-domain#configuring-a-records-with-your-dns-provider \"TOLINKS\")\n\n自定义域名也是蛮有意思的，也考虑专门拿一篇来写。\n\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（16）SEO描述作为简介并添加LaTeX提示","url":"/post/blogdiy/blogdiy-16-description/","content":"<!-- more -->\n\n***\n\n# 1. 文首显示文章描述\n在给博客做 SEO 优化时，通常会给每一篇文章都加一个描述 description 属性，这样能更方便地使得文章被搜索引擎检索到。不过 description 会和正文的 ``ReadMore`` 冲突，也就是不论正文在哪里划分 ``<!-- more -->`` 标签，只要设置了 description 就会导致首页显示的文章缩略内容是 description，并且点击阅读全文后，这个 description 会作为一个文章信息的形式展示而非正文：\n\n<center>\n\n![文章信息中的描述](/post_files/blogdiy/blogdiy-16-description/description_in_post_meta.png \"TOPICS\")\n\n</center>\n\n这就使得本就信息栏更加复杂，而且如果文章确实需要一个简介，在正文处又要再写一次，不仅重复而且不美观。所以可以想办法把 description 从信息栏移到正文开头，恰好作为简介使用，而且还能优化 SEO，一举两得。调整 description 的位置需要修改 ``next/layout/_macro/post.swig``：\n\n```javascript\n{#################}\n{## POST HEADER ##}\n{#################}\n{% if not headlessPost %}\n  <header class=\"post-header\">\n\n  {### 中间隔了很长一大段 ###}\n\n  ......\n\n  {### 一直到 Post Header 的最下面 ###}\n\n  {#################}\n  {## Description ##}\n  {#################}\n  {% if post.description and (not theme.excerpt_description or not is_index) %}\n    <div class=\"post-description\">{#\n      #}{{ post.description }}{#\n    #}</div>\n  {% endif %}\n\n  </header>\n{% endif %}\n\n{#################}\n{### POST BODY ###}\n{#################}\n\n......\n\n```\n\n把这段 Description 的代码复制下来，然后把这里删掉，找到下面 __Post Body__ 部分：\n\n```javascript\n{#################}\n{### POST BODY ###}\n{#################}\n<div class=\"post-body{% if theme.han %} han-init-context{% endif %}{% if post.direction && post.direction.toLowerCase() === 'rtl' %} rtl{% endif %}\" itemprop=\"articleBody\">\n\n  ......\n\n  {% if is_index %}\n    {% if post.description and theme.excerpt_description %}\n\n      {### 这里是首页文章列表的描述 ###}\n      {### 在描述前面加一个高亮的“简介：”开头 ###}\n      <span style=\"color: #EB6D39\">简介：</span>{{ post.description }}\n\n      ......\n\n    {% endif %}\n\n    ......\n\n  {% else %}\n\n    {### 这里是正文内的描述 ###}\n    {### 在描述前面加一个高亮的“简介：”开头 ###}\n\n    {#################}\n    {## Description ##}\n    {#################}\n    {### 把 Description 显示在正文内 ###}\n    {% if post.description and (not theme.excerpt_description or not is_index) %}\n      <div class=\"post-description\">{#\n        #}<span style=\"color: #EB6D39\">简介：</span>{{ post.description }}{#\n      #}</div>\n    {% endif %}\n\n    {### 下面就是正文内容 ###}\n    {{ post.content }}\n  {% endif %}\n</div>\n\n```\n\n这样，首页的描述前就会自动加上高亮的“简介：”开头了：\n\n<center>\n\n![首页文章列表的描述](/post_files/blogdiy/blogdiy-16-description/description_in_home_with_title.png \"TOPICS\")\n\n</center>\n\n正文内的描述也会有同样效果：\n\n<center>\n\n![正文内的描述](/post_files/blogdiy/blogdiy-16-description/description_in_post_with_title.png \"TOPICS\")\n\n</center>\n\n***\n\n# 2. 自动切换“简介”和“未完待续”\n\n如果一篇文章尚未完成，想要在文首提示一些信息，可能会这么做：\n\n<center>\n\n![简介后加入“未完待续”](/post_files/blogdiy/blogdiy-16-description/description_and_unfinished.png \"TOPICS\")\n\n</center>\n\n但是显得不够简洁，简介就应该是针对一篇已完成的文章。因此，可以利用自定义文章头部属性的方式进行适配。首先在未完成的文章头部属性中增加一个自定义属性 ``unfinished: true``，当然也可以按自己的喜好来：\n\n```yml\ntitle: 例文\nauthor: SLLiu\nunfinished: true\ndescription: 简介 / 未完待续\n```\n\n然后修改 ``next/layout/_macro/post.swig``：\n\n```javascript\n{% if is_index %}\n\n  {####################################}\n  {### 首页文章列表中显示的简介/未完待续 ###}\n  {####################################}\n  {% if post.description and theme.excerpt_description %}\n    <span style=\"color: #EB6D39\">{#\n        #}{% if post.unfinished %}\n            未完待续：\n          {% else %}\n            简介：\n          {% endif %}{#\n      #}</span>{{ post.description }}\n  \n  ......\n\n{% else %}\n\n  {#################################}\n  {### 正文文首中显示的简介/未完待续 ###}\n  {#################################}\n  {% if post.description and (not theme.excerpt_description or not is_index) %}\n    <div class=\"post-description\">{#\n      #}<span style=\"color: #EB6D39\">{#\n        #}{% if post.unfinished %}\n            未完待续：\n          {% else %}\n            简介：\n          {% endif %}{#\n      #}</span>{{ post.description }}{#\n    #}</div>\n  {% endif %}\n  \n  ......\n\n{% endif %}\n```\n\n这样，如果文章具有 ``unfinished: true`` 属性，则会显示“未完待续”，完成文章后删掉这个属性，即可正常显示“简介”了。\n\n未完成文章显示：\n\n<center>\n\n![未完成的文章](/post_files/blogdiy/blogdiy-16-description/post_unfinished.png \"TOPICS\")\n\n</center>\n\n已完成文章显示：\n\n<center>\n\n![已完成的文章](/post_files/blogdiy/blogdiy-16-description/post_finished.png \"TOPICS\")\n\n</center>\n\n***\n\n# 3. 增加LaTeX公式提示\n\n由于 Safari 浏览器对 LaTeX 的支持不是特别好，会导致某些情况下 LaTeX 的公式显示错位或异常，例如：\n\n<center>\n\n![Safari 显示 LaTeX 异常](/post_files/blogdiy/blogdiy-16-description/latex_error_in_safari.png \"TOPICS\")\n\n</center>\n\n可以看到这个向量图标错了，正常情况下（基于 Chrome 和 FireFox 的浏览器）显示效果应该是这样的：\n\n<center>\n\n![LaTeX 正常显示效果](/post_files/blogdiy/blogdiy-16-description/latex_right_in_chrome.png \"TOPICS\")\n\n</center>\n\n为此，可以在文首增加一条提示，用于提醒读者切换浏览器。如果每一篇添加了的文章都手动增加提示，效率太低，不符合程序猿的习惯，况且如果是后面增加公式的文章，还容易忘记添加提示，因此把这个提示也添加到自动生成中去！\n\n显示效果可以查看文章：[机器学习简介](/post/AI/AI-Introduction/ \"TOLINKS\")，图片效果如下：\n\n<center>\n\n![文首自动添加 LaTeX 提示](/post_files/blogdiy/blogdiy-16-description/latex_tips_in_post.png \"TOPICS\")\n\n</center>\n\n为了能在比较显眼的地方提示，就把它放在描述的上方好了！增加的方法是一样一样的，因为 Hexo 如果要使用 LaTeX 渲染，除了在配置文件中开启 MathJax 之外，还需要在每篇文章的头部属性中增加\n\n```yml\nmathjax: true\n```\n\n那么就判断每篇文章是否使用了这个属性即可！还是修改刚才添加正文描述的地方 ``next/layout/_macro/post.swig``：\n\n```javascript\n{### 这里是正文内LaTeX提示 ###}\n{### 在正文描述的上方添加提示，并居中显示 ###}\n\n{#################}\n{## LaTeX Tips ###}\n{#################}\n{% if post.mathjax %}\n<div style=\"color: #EB6D39; text-align: center\">Tips : Safari 浏览器对 LaTeX 的支持不太好。&emsp;LaTeX not supported well in Safari.</div>\n<br/>\n{% endif %}\n\n{### 这里是正文内的描述 ###}\n{### 在描述前面加一个高亮的“简介：”开头 ###}\n\n{#################}\n{## Description ##}\n{#################}\n{### 把 Description 显示在正文内 ###}\n\n......\n\n```\n\n这里我只是在正文的描述上方添加提示语，在首页文章列表是不会显示的，以保持首页的简洁性。当然如果想要在首页也显示，复制下来粘贴到对应位置即可。并且没有开启 LaTeX 功能的文章是不会显示的，比如本文：\n\n<center>\n\n![无 LaTeX 功能文章不显示提示](/post_files/blogdiy/blogdiy-16-description/latex_no_tips_in_post.png \"TOPICS\")\n\n</center>\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（15）首页及正文的标题高亮、加粗","url":"/post/blogdiy/blogdiy-15-titlestyle/","content":"<!-- more -->\n\n***\n\n可能是我自己的喜好问题，我总觉得 Next 默认的标题不够突出，要么颜色可以更突出一些，要么文字可以再加粗一些，总之感觉上没有高亮感。为此我想修改一下标题的样式，换个更具有视觉冲击的颜色！\n\n# 1. 首页文章列表标题高亮\n\n首先是首页文章列表显示的文章标题，修改 ``next/source/css/_common/components/post/post-title.styl``：\n\n```javascript\n.posts-expand .post-title-link {\n  display: inline-block;\n  position: relative;\n  color: #EB6D39;  // 这里修改颜色，按照个人喜好自定义\n  border-bottom: none;\n  line-height: 1.2;\n  vertical-align: top;\n\n  ......\n\n}\n```\n\n设置完之后的效果如下：\n\n<center>\n\n![首页标题高亮](/post_files/blogdiy/blogdiy-15-titlestyle/title_highlight_in_home.png \"TOPICS\")\n\n</center>\n\n***\n\n# 2. 正文标题高亮\n\n为了风格统一，再把正文内的标题颜色也改为相同的高亮色，因为和下面的很多信息放在一块，顺便再加个粗凸显一下，修改 ``next/source/css/_schemes/Gemini/index.styl``：\n\n```javascript\n.posts-expand .post-title {\n  font-size: 1.7em;\n  color: #EB6D39;  // 这里修改颜色，按照个人喜好自定义\n  font-weight: bold;  // 这里选择加粗，可选：100~900，整 100 取值\n}\n```\n\n修改完之后的效果如下：\n\n<center>\n\n![正文标题高亮加粗](/post_files/blogdiy/blogdiy-15-titlestyle/title_highlight_in_post.png \"TOPICS\")\n\n</center>\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（14）自动为每篇文章增加结束语","url":"/post/blogdiy/blogdiy-14-autoend/","content":"<!-- more -->\n\n***\n\n# 1. 增加结束词\n\n作为一名码畜，“体验感”是一个很重要的东西，如果能让读者在看完每篇文章的时候都显示一个感谢词，也是作为技术人非常看重的一点：鼓励宣传。当然，我们可以自己手动在每篇文章末端内添加一段话，也可以在模板文件 ``blog/scaffolds/post.md`` 增加结束词，这样每次通过 ``hexo new \"[title]\"`` 创建文章时都会自动添加，但是说到底这个方式说白了还是有点费心思。\n\n话不多说，来看看如何实现！这个功能的实现逻辑主要是先创建一个样式文件，在里面定义好结束词的样式，然后再在文章内的结尾加载这个文件。首先是创建样式文件，在 ``next/layout/_macro/`` 下创建一个 __swig__ 文件 ``passage_end_tag.swig``，命名必须是这个，里面按照自己的喜好输入想要的结束语样式，我自己的结束语样式是：\n\n```javascript\n<div>\n    {% if not is_index %}\n\t<br /> <br /> <br />\n\t<div style=\"text-align:center;color: #678;font-size:18px;\">======================</div>\n        <div style=\"text-align:center;color: #678;font-size:18px;\">全 文 结 束&ensp;&ensp;<i class=\"fa fa-leanpub\"></i>&ensp;&ensp;感 谢 阅 读</div>\n\t<div style=\"text-align:center;color: #678;font-size:18px;\">======================</div>\n    {% endif %}\n</div>\n```\n\n然后在 ``next/layout/_macro/post.swig`` 中，在 ``POST BODY`` 的下面有很多文章底部内容模块：\n\n```javascript\n{#####################}\n{##### License #######}\n{#####################}\n{% if theme.creative_commons.license and theme.creative_commons.post and not is_index %}\n  <div>\n    {% include '../_partials/post/post-copyright.swig' with { post: post } %}\n  </div>\n{% endif %}\n\n{#####################}\n{# Wechat Subscriber #}\n{#####################}\n{% if theme.wechat_subscriber.enable and not is_index %}\n  {% include '../_partials/post/wechat-subscriber.swig' %}\n{% endif %}\n\n{#####################}\n{##### Donation ######}\n{#####################}\n{% if page.reward === undefined and theme.reward_settings.enable %}\n  {% set reward_able = true %}\n{% else %}\n  {% set reward_able = page.reward %}\n{% endif %}\n{% if reward_able and not is_index %}\n  <div>\n    {% include '../_partials/post/reward.swig' %}\n  </div>\n{% endif %}\n\n{#####################}\n{#### POST FOOTER ####}\n{#####################}\n<footer class=\"post-footer\">\n\n  ......\n\n</footer>\n```\n\n按照个人喜好在对应位置插入以下代码：\n\n```javascript\n{#####################}\n{## Passage End Tag ##}\n{#####################}\n<div>\n  {% if not is_index %}\n    {% include 'passage_end_tag.swig' %}\n  {% endif %}\n</div>\n```\n\n我是放在 ``License`` 的上面了，接着再去主题配置文件中开启 ``passage_end_tag``：\n\n```yml\n# End Title\npassage_end_tag:\n  enabled: true\n```\n\n可以参考我博客的显示效果：\n\n<center>\n\n![自动增加结束语](/post_files/blogdiy/blogdiy-14-autoend/auto_end_tag.png \"TOPICS\")\n\n</center>\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n\n***\n\n# 2. 附录[参考指导]\n\n> - [【1】Hexo NexT主题内给每篇文章后添加结束标语（作者：asdfv1929）<sup>【注】</sup>](https://asdfv1929.github.io/2018/01/28/add-the-end/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（13）隐藏修改时间信息和时间下滑虚线","url":"/post/blogdiy/blogdiy-13-hidetime/","content":"<!-- more -->\n\n***\n\n# 1. 隐藏修改时间信息\n\n默认情况下，一篇文章会具有“创建时间”和“更新时间”两个信息：\n\n<center>\n\n![文章列表显示更新时间](/post_files/blogdiy/blogdiy-13-hidetime/update_time_show.png \"TOPICS\")\n\n</center>\n\n不过两个时间标签放在一起，如果是正文内显示，会觉得特别繁杂，很多信息都挤在一块：\n\n<center>\n\n![文章正文显示更新时间](/post_files/blogdiy/blogdiy-13-hidetime/update_time_show_in_post.png \"TOPICS\")\n\n</center>\n\n不论是出于简约美观、还是出于隐私性，可能有时会不希望显示这个信息，比如我只希望在明确会更新的文章或者经过讨论后认为有改进部分的文章内显示，从而给合作者、读者一个更明确地更新信号，在 Next 主题的主题配置文件中倒是有一个“更新时间”的开关：\n\n```yml\n# Post meta display settings\npost_meta:\n  item_text: true\n  created_at: true\n  updated_at:  # 这里可以开关“更新时间”\n    enable: true\n    another_day: true\n  categories: true\n```\n\n但这个开关是全局性的，要么所有文章都显示，要么所有文章都隐藏，而我只需要某些文章显示其他的隐藏，还是一样从代码入手。修改 ``next/layout/_macro/post.swig``：\n\n```javascript\n{% if theme.post_meta.updated_at.enable %}\n  {% set display_updated = !theme.post_meta.updated_at.another_day || theme.post_meta.updated_at.another_day && date_diff %}\n\n  {% if display_updated or !theme.post_meta.created_at %}\n    {% if theme.post_meta.created_at and theme.post_meta.updated_at.enable %}\n    <span class=\"post-meta-divider\">|</span>\n    {% endif %}\n\n    <span class=\"post-meta-item-icon\">\n      <i class=\"fa fa-calendar-check-o\"></i>\n    </span>\n    {% if theme.post_meta.item_text %}\n      <span class=\"post-meta-item-text\">{{ __('post.edited') }}</span>\n    {% endif %}\n    <time title=\"{{ __('post.modified') + __('symbol.colon') + full_date(post.updated) }}\" itemprop=\"dateModified\" datetime=\"{{ moment(post.updated).format() }}\">{#\n    #}{{ date(post.updated) -}}\n    </time>\n  {% endif %}\n{% endif %}\n```\n\n把这段代码的第一行改一下：\n\n```javascript\n{### 根据文章是否有 modify 字段判断是否显示修改时间 ###}\n{% if theme.post_meta.updated_at.enable && post.modify %}\n\n  ......\n\n{% endif %}\n```\n\n然后默认情况下，所有文章都不会显示“更新时间”了，如果某些文章需要显示，只需要在文章的头部信息栏增加一个属性 ``modify: true`` 即可：\n\n```yml\n---\ntitle: Hexo博客DIY（13）隐藏修改时间信息和时间下滑虚线\nmodify: true\ndate: 2019-01-11 09:12:49\n---\n```\n\n隐藏“修改时间”后看起来清爽的多：\n\n<center>\n\n![文章列表隐藏更新时间](/post_files/blogdiy/blogdiy-13-hidetime/update_time_hide.png \"TOPICS\")\n\n</center>\n\n文章正文内显示效果：\n\n<center>\n\n![文章列表隐藏更新时间](/post_files/blogdiy/blogdiy-13-hidetime/update_time_hide_in_post.png \"TOPICS\")\n\n</center>\n\n***\n\n# 2. 隐藏时间信息下滑虚线\n\n默认情况下，时间信息（包括创建时间和修改时间）的底部还有一个下滑虚线：\n\n<center>\n\n![显示时间信息下滑虚线](/post_files/blogdiy/blogdiy-13-hidetime/time_underline_show.png \"TOPICS\")\n\n</center>\n\n不过后面的各个信息都没有下划线，看起来总觉得不太统一。去掉这个下滑虚线修改 ``next/source/css/_common/components/post/post-meta.styl``：\n\n```javascript\n.posts-expand .post-meta\n\n  ......\n\n  time {\n    // 删除下面一行\n    // border-bottom: 1px dashed $grey-dark;\n    cursor: help;\n  }\n}\n```\n\n按照注释，删掉 ``border-bottom`` 一行即可。修改完效果：\n\n<center>\n\n![隐藏时间信息下滑虚线](/post_files/blogdiy/blogdiy-13-hidetime/time_underline_hide.png \"TOPICS\")\n\n</center>\n\n当然，如果想保留，也可以按照自己的需求 DIY，这个文件内还有各个其他信息的样式，都可以自定义。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（12）文章顶部显示上一篇/下一篇","url":"/post/blogdiy/blogdiy-12-prevnext/","content":"<!-- more -->\n\n***\n\n一般在阅读文章的时候，如果恰好在阅读一个系列，或者想要找到某一部分内容却又记不清到底在哪篇文章的时候，通常会使用“上一篇/下一篇”来切换阅读，但默认情况下这个导航在文章的最底下，如果仅仅只是为了快速切换，每次都拉到最底下就太麻烦了，为此可以在文章顶部也增加一个导航栏，首先在 ``next/layout/_macro/post.swig`` 中找到底部导航栏的代码部分：\n\n```javascript\n{#####################}\n{### Prev and Last ###}\n{#####################}\n{% if not is_index and (post.prev or post.next) %}\n  <div class=\"post-nav\">\n    <div class=\"post-nav-next post-nav-item\">\n      {% if post.next %}\n        <a href=\"{{ url_for(post.next.path) }}\" rel=\"next\" title=\"{{ post.next.title }}\">\n          <i class=\"fa fa-chevron-left\"></i> {{ post.next.title }}\n        </a>\n      {% endif %}\n    </div>\n\n    <span class=\"post-nav-divider\"></span>\n\n    <div class=\"post-nav-prev post-nav-item\">\n      {### 在系列第（7）篇中记录的，对置顶栏的优化 ###}\n      {% if post.prev and not post.prev.topic %}\n        <a href=\"{{ url_for(post.prev.path) }}\" rel=\"prev\" title=\"{{ post.prev.title }}\">\n          {{ post.prev.title }} <i class=\"fa fa-chevron-right\"></i>\n        </a>\n      {% endif %}\n    </div>\n  </div>\n{% endif %}\n\n{% set isLast = loop.index % page.per_page === 0 %}\n{% if is_index and not isLast %}\n  <div class=\"post-eof\"></div>\n{% endif %}\n```\n\n把这一段复制一份到上面文章块 ``POST BLOCK`` 内的最顶上：\n\n```javascript\n<article class=\"{{ post_class }}\" itemscope itemtype=\"http://schema.org/Article\">\n\n{##################}\n{### POST BLOCK ###}\n{##################}\n<div class=\"post-block\">\n\n  {### 复制插入到这里 ###}\n\n  ......\n\n</div>\n</article>\n```\n\n不过单单这么添加完，显示的效果比较一般：\n\n<center>\n\n![文章页首导航栏默认样式](/post_files/blogdiy/blogdiy-12-prev-next/post_header_prev_next_default.png \"TOPICS\")\n\n</center>\n\n对比一下原来底部的导航栏：\n\n<center>\n\n![文章页尾导航栏默认样式](/post_files/blogdiy/blogdiy-12-prev-next/post_footer_prev_next_default.png \"TOPICS\")\n\n</center>\n\n发现原来把样式也复制过来了，底部的导航栏分割线在上面，顶部的导航栏应该让分割线在下面才好，那么就自己写一个吧！把顶部的导航栏代码稍作更改，里面添加进自定义的样式——底下分割线，并且和文章标题间隔一段距离：\n\n```javascript\n<article class=\"{{ post_class }}\" itemscope itemtype=\"http://schema.org/Article\">\n\n{##################}\n{### POST BLOCK ###}\n{##################}\n<div class=\"post-block\">\n\n  {#####################}\n  {### Prev and Last ###}\n  {#####################}\n  {% if not is_index and (post.prev or post.next) %}\n    <div class=\"bottom-divider\">\n      <style>\n        .bottom-divider {\n          display: table;\n          padding-bottom: 10px;\n          margin-bottom: 50px;\n          width: 100%;\n          border-bottom: 1px solid #eee;\n        }\n      </style>\n      <div class=\"post-nav-next post-nav-item\">\n        {% if post.next %}\n          <a href=\"{{ url_for(post.next.path) }}\" rel=\"next\" title=\"{{ post.next.title }}\">\n            <i class=\"fa fa-chevron-left\"></i> {{ post.next.title }}\n          </a>\n        {% endif %}\n      </div>\n\n      <span class=\"post-nav-divider\"></span>\n\n      <div class=\"post-nav-prev post-nav-item\">\n        {% if post.prev and not post.prev.topic %}\n          <a href=\"{{ url_for(post.prev.path) }}\" rel=\"prev\" title=\"{{ post.prev.title }}\">\n            {{ post.prev.title }} <i class=\"fa fa-chevron-right\"></i>\n          </a>\n        {% endif %}\n      </div>\n    </div>\n  {% endif %}\n\n  {% set isLast = loop.index % page.per_page === 0 %}\n  {% if is_index and not isLast %}\n    <div class=\"post-eof\"></div>\n  {% endif %}\n  {#####################}\n  {# END Prev and Last #}\n  {#####################}\n\n  ......\n\n</div>\n</article>\n```\n\n把分割线的颜色也修改为和底部导航栏分割线的颜色一致，同时分割线和导航栏文字内距大约是 ``10px``，分割线和标题外距大约 ``50px``，看起来好多了！\n\n<center>\n\n![文章页首导航栏自定义样式](/post_files/blogdiy/blogdiy-12-prev-next/post_header_prev_next_custom.png \"TOPICS\")\n\n</center>\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（11）修改文章类别位置、文章顶部显示标签","url":"/post/blogdiy/blogdiy-11-post-cate-tags/","content":"<!-- more -->\n\n***\n\n# 1. 首页文章列表分类位置调整\n\n让文章的分类在首页与其他信息显示在同一行，而在进入具体某篇文章后，分类则与标签单独显示在下一行内。首先解决分类的部分，修改 ``next/layout/_macro/post.swig``：\n\n```javascript\n{### 调整文章列表分类的位置 ###}\n{### 个人喜欢把分类放在最后 ###}\n{### 在分类上面添加以下内容 ###}\n{### 文章列表分类前加分隔符 ###}\n{### 正文显示分类前加换行符 ###}\n{% if post.categories and post.categories.length and theme.post_meta.categories %}\n  {% if is_index %}\n    <span class=\"post-meta-divider\">|</span>\n  {% endif %}\n  {% if post.tags and post.tags.length and not is_index %}\n    <div><br/></div>\n  {% endif %}\n{% endif %}\n\n\n{### 以下是分类的部分 ###}\n\n{#################}\n{## Categories ###}\n{#################}\n{% if post.categories and post.categories.length and theme.post_meta.categories %}\n\n......\n\n{% endif %}\n```\n\n返回首页可以看到文章列表的文章信息末尾已经有分类了，点进去某篇文章，分类和标签则是另起一行显示：\n\n<center>\n\n![自定义链接功能](/post_files/blogdiy/blogdiy-11-poststyle/post_list_show_categories.png \"TOPICS\")\n\n</center>\n\n不过，如果文章的分类多于两个，在中文模式下，Next 主题会使用中文逗号“，”来分隔，个人觉得并不是那么好看，或许可以也改一改，在分类的代码里面找到：\n\n```javascript\n{% for cat in post.categories %}\n  \n  ......\n\n  {% if cat_length > 1 and loop.index !== cat_length %}\n    {{ __('symbol.comma') }}\n  {% endif %}\n{% endfor %}\n```\n\n代码中的：\n\n```javascript\n{{ __('symbol.comma') }}\n```\n\n对应了语言配置文件中的 ``comma``，在中文模式中，``comma`` 对应的就是中文逗号，由于只想改掉这一个地方，所以直接把这行替换一下就好了，我用的就是一个半角空格 ``&ensp;``，和标签的分隔保持统一风格。效果如下：\n\n<center>\n\n![多分类自定义分隔](/post_files/blogdiy/blogdiy-11-poststyle/multiple_categories_split.png \"TOPICS\")\n\n</center>\n\n***\n\n# 2. 文首显示标签并与分类对齐\n\n在 Next 主题中所有的文章称为 __Post__，默认情况下 Post 的标签是在文章底部的，不够我个人觉得这样并不适合读者在阅读文章前了解文章的大致方向，或许应该像论文一样，把标签放在文首更好。关于文章内的各个控件、内容的布局都在：``next/layout/_macro/post.swig`` 文件中。先找到文章标签对应的代码：\n\n```javascript\n<footer class=\"post-footer\">\n  {### ↓↓↓以下就是标签代码↓↓↓ ###}\n  {% if post.tags and post.tags.length and not is_index %}\n    {% if theme.tag_icon %}\n      {% set tag_indicate = '<i class=\"fa fa-tag\"></i>' %}\n    {% else %}\n      {% set tag_indicate = '#' %}\n    {% endif %}\n    <div class=\"post-tags\">\n      {% for tag in post.tags %}\n        <a href=\"{{ url_for(tag.path) }}\" rel=\"tag\">{{ tag_indicate }} {{ tag.name }}</a>\n      {% endfor %}\n    </div>\n  {% endif %}\n  {### ↑↑↑以上就是标签代码↑↑↑ ###}\n\n  ......\n\n</footer>\n```\n\n这段就是标签的代码了。直接把这段剪切到上面和分类代码同级的地方：\n\n```javascript\n{### 分类代码 ###}\n{% if post.categories and post.categories.length and theme.post_meta.categories %}\n\n  ......\n\n{% endif %}\n\n{### 标签代码 ###}\n{% if post.tags and post.tags.length and not is_index %}\n\n  ......\n\n{% endif %}\n```\n\n不过这样移完会发现分类和标签的大小、高度都不一致，有点参差不齐的感觉，甚是不爽。修改细节就不详细介绍了，直接给出我目前在用的代码：\n\n```javascript\n{#################}\n{## Categories ###}\n{#################}\n{% if post.categories and post.categories.length and theme.post_meta.categories %}\n  <span class=\"post-category\">\n    <span class=\"post-meta-item-icon\" style=\"text-align:center;font-size:12px;vertical-align:middle;display:inline-block;\">\n        <i class=\"fa fa-th\"></i>\n    </span>\n    {% if theme.post_meta.item_text %}\n      <span class=\"post-meta-item-text\" style=\"text-align:center;font-size:12px;vertical-align:middle;display:inline-block;\">\n        {{ __('post.in') }}:&ensp;\n      </span>\n    {% endif %}\n    {% for cat in post.categories %}\n      <span itemprop=\"about\" itemscope itemtype=\"http://schema.org/Thing\">{#\n      #}<a style=\"vertical-align:middle;display:inline-block;\" href=\"{{ url_for(cat.path) }}\" itemprop=\"url\" rel=\"index\">{#\n        #}<span itemprop=\"name\" style=\"text-decoration: none; font-size:12px\">{{ cat.name }}</span>{#\n      #}</a>{#\n    #}</span>\n\n      {% set cat_length = post.categories.length %}\n      {% if cat_length > 1 and loop.index !== cat_length %}\n        {{ __('symbol.comma') }}\n      {% endif %}\n    {% endfor %}\n  </span>\n{% endif %}\n\n\n{#################}\n{##### Tags ######}\n{#################}\n{% if post.tags and post.tags.length and not is_index %}\n\n  {% if post.categories and post.categories.length and theme.post_meta.categories %}\n    <span class=\"post-meta-divider\" style=\"vertical-align: middle;display:inline-block;\">|</span>\n  {% endif %}\n\n  <div class=\"post-tags\" style=\"display: inline\">\n\n    <div style=\"text-align:center;vertical-align: middle;display:inline-block;font-size:12px;\">\n      <i class=\"fa fa-tags\"></i>&ensp;Tags:&ensp;\n    </div>\n    {% for tag in post.tags %}\n      <span style=\"display:inline-block;vertical-align: middle;\" itemscope itemtype=\"http://schema.org/Thing\">{#\n      #}<a href=\"{{ url_for(tag.path) }}\" rel=\"tag\"># {{ tag.name }}&ensp;</a>{#\n      #}</span>\n    {% endfor %}\n  </div>\n{% endif %}\n```\n\n还需要对 __Tags__ 的显示样式文件 ``next/source/css/_common/components/post/post-tags.styl`` 做一些修改：\n\n```javascript\n.posts-expand .post-tags {\n  margin-top: 20px;\n  text-align: center;\n  text-decoration: none;\n\n  a {\n    display: inline-block;\n    margin-right: 10px;\n    font-size: 12px;\n    text-decoration: none;\n  }\n}\n```\n\n效果如下：\n\n<center>\n\n![自定义链接功能](/post_files/blogdiy/blogdiy-11-poststyle/categories_tags_same_line.png \"TOPICS\")\n\n</center>\n\n大致来说我做的修改就是：调整了文字、连接的大小，使分类和标签一致，调整了链接和文字的位置为垂直居中，使得链接看起来不会下面拖了一个很不美观的下划线。\n\n***\n\n# 3. 文首增加原创声明\n\n首先可以看到，我的文章顶部属性以及分类和标签的中间有这么一行小字：\n\n<center>\n\n![文首的原创声明](/post_files/blogdiy/blogdiy-11-poststyle/originalStatement.png \"TOPICS\")\n\n</center>\n\n声明一个原创标识还是有必要的，但是这么多文章，如果每个都手动写在正文内太麻烦，虽然可以通过 ``blog/scaffolds/post.md`` 文件定义好声明语句，在新文章生成时自动添加，但是这种方式只能添加到正文中，而这种声明感觉更偏向于文章属性，所以还是添加到文首比较好。\n\n首先在 ``next/languages/`` 目录下找到需要动态修改语言的对应语言文件，在 ``post`` 字段下添加如下属性：\n\n```yml\n# 英文对应 en.yml\npost:\n  ......\n  originalStatement: 【Note】This is an original post, nothing plagiarism. The reference link is for reference only, and the authors can require deletion.\n\n# 简体中文对应 zh-CN.yml\npost:\n  ......\n  originalStatement: 【注】本文全部内容均为原创，引用链接仅做学习指导，内容无任何摘抄及复制，原作可随时联系要求删除\n```\n\n具体的声明内容就看自己喜好了。然后在文章内的头部属性栏添加一个自定义布尔类型属性 ``originalStatement``：\n\n```yml\n---\ntitle: Hexo博客DIY（11）修改文章类别位置、文章顶部显示标签\nauthor: SLLiu\noriginalStatement: true\n---\n```\n\n再修改 ``next/layout/_macro/post.swig``：\n\n```javascript\n<div class=\"post-meta\">\n  \n  ......\n\n  {####################}\n  {##### 原创声明 ######}\n  {####################}\n  {% if post.originalStatement and not is_index %}\n    <p>\n      <font size=1 color=\"#999999\">\n        <sup>{{ __('post.originalStatement') }}</sup>\n      </font>\n    </p>\n  {% endif %}\n\n</div>\n```\n\n以上代码可以添加到自己想放的位置，文字显示的样式也可以随意调整。由于我的博客基本全部都是原创文章，为了方便，在模板文件 ``blog/scaffolds/post.md`` 内设置每篇文章自动增加原创声明的属性：\n\n```yml\n---\ntitle: {{ title }}\nauthor: SLLiu\noriginalStatement: true\n......\n```\n\n用相同的思路，还可以添加例如“转载声明”，“引用声明”等等。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（10）一键转到页首、页尾、主页","url":"/post/blogdiy/blogdiy-10-jumplinks/","content":"<!-- more -->\n\n***\n\n# 1. 增加跳转链接\n\n默认情况下，想象一下这几个场景：\n\n  1. 看一篇比较长的文章，前半部分看完之后有个疑问，想评论一下，结果发现评论在最底下\n  2. 看一篇比较长的文章，看到一半了，发现后面是看过的或者打算再返回主页看看别的，结果发现主侧栏上的“首页”按钮在最顶上\n  3. 看一篇比较长的文章，想看看最新的评论都有哪些，结果发现评论在最底下，看完评论想返回首页，结果首页又在最顶上\n\n  ......\n\n虽说滚几下滚轮，点一下滚动栏也没什么大不了的，但毕竟还是影响到了阅读体验，总觉得有种跳出当前专注的事情一样。Next 主题为此提供了一键返回顶部的功能，还能显示阅读进度，这都是不错的，不过毕竟只能一键返回顶部，一键下滑到底部和一键返回主页还是要自己加上去。\n\n我考虑了一下，如果把这三个都单独做成一个控件，似乎有点繁杂，最后感觉集成到悬浮侧栏是最好的，理由有四：\n\n  1. 不突兀，没有多余的控件\n  2. 阅读文章时大概率会浏览目录，不需要专门引导读者就能知道有这个功能，使用起来比较沉浸\n  3. 浮动侧栏不论文章怎么滑动、滑动到哪，位置都相对固定，不会因为文章的不同导致这三个功能的位置发生变化而使得读者找不到在哪\n  4. 不论文章是否有目录，浮动侧栏都显示这些功能，避免了某些情况下，文章没有任何目录标题（全部文字都是正文格式的长文），导致目录栏不显示，进而导致这三个功能不显示。\n\n具体的功能效果大家可以在阅读本文时先试试我的博客浮动侧栏最上面的“页首 | 主页 | 评论”这三个功能（动图加载较慢）：\n\n<center>\n\n![自定义链接功能](/post_files/blogdiy/blogdiy-10-jumplinks/custom_jump_links.gif \"TOPICS\")\n\n</center>\n\n既然是加到浮动侧栏上，那就从浮动侧栏的样式文件入手，修改 ``next/layout/_macro/sidebar.swig``：\n\n```javascript\n<aside id=\"sidebar\" class=\"sidebar\">\n  <div class=\"sidebar-inner\">\n\n    {% set display_toc = is_post and theme.toc.enable or is_page and theme.toc.enable %}\n\n    {############## ↓↓↓在这里插入以下代码↓↓↓ ##############}\n    {## 所有文章都显示快捷栏，其他界面如果目录不为空也显示 ##}\n    {% if is_post || toc(page.content).length > 0 %}\n      {## 用<p></p>标签包裹的控件会在下方空出一行而不只是换行 ##}\n      <div class=\"underline\" style=\"width: 100%; display: inline-block\">\n        <style>\n        .underline{ padding-bottom:1px; border-bottom:1px solid #EB6D39}\n        </style>\n        <span style=\"width: 100%; font-size: 13px; color: #EB6D39;\">\n          {### Top Link ###}\n          <div style=\"cursor: pointer; font-size: 13px; color: #EB6D39; display: inline-block\" onclick=\"window.location='#';\">\n          页首\n          </div>\n          &ensp;|&ensp;\n          {### Home Link ###}\n          <div style=\"cursor: pointer; font-size: 13px; color: #EB6D39; display: inline-block\" onclick=\"window.location='/';\">\n          主页\n          </div>\n          &ensp;|&ensp;\n          {### Bottom Link ###}\n          <div style=\"cursor: pointer; font-size: 13px; color: #EB6D39; display: inline-block\" onclick=\"window.scrollBy(0, document.getElementsByTagName('BODY')[0].scrollHeight);\">\n          评论\n          </div>\n        </span>\n      </div>\n    {% endif %}\n    {############## ↑↑↑在这里插入以上代码↑↑↑ ##############}\n\n    {% if display_toc and toc(page.content).length > 1 %}\n      <ul class=\"sidebar-nav motion-element\">\n        <li class=\"sidebar-nav-toc sidebar-nav-active\" data-target=\"post-toc-wrap\">\n          {{ __('sidebar.toc') }}\n        </li>\n        <li class=\"sidebar-nav-overview\" data-target=\"site-overview-wrap\">\n          {{ __('sidebar.overview') }}\n        </li>\n      </ul>\n    {% endif %}\n\n    ......\n\n  </div>\n\n  ......\n\n</aside>\n```\n\n这样就能随时随地跳转到页首、页尾和首页了。当然，也可以把这段代码按照自己的喜好进一步修改、或放到自己想要的位置。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n\n***\n\n# 2. 附录[参考指导]\n\n> - [【1】css样式中的class，style与id的优先级问题（作者：白太白QAQ）<sup>【注】</sup>](https://blog.csdn.net/baitaibai/article/details/54561918 \"ToLinks\")\n> - [【2】div和span显示在同一行（作者：适AT）<sup>【注】</sup>](https://www.cnblogs.com/kuoAT/p/6706327.html?utm_source=itdadao&utm_medium=referral \"ToLinks\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（9）侧栏个人链接居中","url":"/post/blogdiy/blogdiy-9-sidebar/","content":"<!-- more -->\n\n***\n\n# 1. 浮动侧栏个人链接居中\n\n默认情况下，侧栏中个人信息的链接是这样的：\n\n<center>\n\n![默认背景](/post_files/blogdiy/blogdiy-9-sidebar/sidebar_author_links_default.png \"TOPICS\")\n\n</center>\n\n上下都是中心对称，偏偏只有个人链接这块是左对齐的，强迫症简直不能忍啊！这里的链接其实是每行两个，倒是可以直接设置为居中显示，不过因为每个链接的长度都不一样，如果直接设置居中会导致每行的图标的位置很可能是错开的。所以其实我想要的 __居中__ 只是把现在这样整体往右移一点，这块对应的样式文件在：``next/source/css/_common/components/sidebar/sidebar-author-links.styl``，可以这么修改：\n\n```javascript\n.links-of-author {\n  margin-top: 20px;\n\n  a, span.exturl {\n    display: inline-block;\n    vertical-align: middle;\n\n    // 删除下面的两行：\n    // margin-right: 10px;\n    // margin-bottom: 10px;\n\n    // 插入下面两行：\n    position: relative;\n    left: 18%\n\n    border-bottom-color: $black-light;\n    font-size: 13px;\n    if hexo-config('social_icons.transition') { the-transition(); }\n\n    ......\n\n  }\n}\n```\n\n这里的 ``left: 18%`` 表示左侧位移 18%，这个值只是我自己肉眼看出来的大致值，应当根据自己的链接的长度手动调整。修改后的效果如下：\n\n<center>\n\n![默认背景](/post_files/blogdiy/blogdiy-9-sidebar/sidebar_author_links_custom.png \"TOPICS\")\n\n</center>\n\n确实是笨方法，不过目前还没找到用什么更好的办法去实现，留着以后有更好的办法时再更新。\n\n***\n\n# 2. 修改标签页词云样式\n\n标签词云样式在之前的文章：[Hexo博客DIY（2）内置的小功能扩展](/post/BlogDIY/blogdiy-2-extension/ \"TOLINKS\")中的第 2 条有介绍，不过那篇主要是介绍如何给词云显示出更丰富的效果。这里小小的记录一下，标签页词云的布局修改，比如不同标签之间的间隔之类的，样式文件在 ``next/source/css/_common/components/pages/tag-cloud.styl``：\n\n```javascript\n.tag-cloud {\n  text-align: center;\n\n  a {\n    display: inline-block;\n    margin: 10px 0 20px 20px;  // 修改间距\n  }\n\n  a:hover {\n    color: $link-hover-color !important;\n  }\n}\n```\n\n这里的边距顺序是：上、右、下、左，除了边距外，其他样式也可以按照需要自行修改。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（8）博客各部分背景设置","url":"/post/blogdiy/blogdiy-8-background/","content":"<!-- more -->\n\n***\n\n# 1. 站点背景图\n\n先从最容易看到的开始，站点背景是内置支持的一个功能，只需要修改：``/next/source/css/_custom/custom.styl`` 并增加代码：\n\n```javascript\n// Custom styles.\nbody {\n  background: url(/images/site-back.jpg);\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 100% 25%;\n  background-size: cover;\n}\n```\n\n然后在 ``next/source/images/`` 下放入自己的图片（具体路径和图片名称可以自定义，但这里的路径是从主体根目录开始的）即可。\n\n  1. ``no-repeat`` 是当你的图片小于显示大小时，是否通过重复图片铺满\n  2. ``position`` 可以自行指定背景图片的左右、上下位移距离\n  3. ``size`` 选择 ``cover`` 也即按比例拉伸铺满背景\n\n效果参考我的博客背景，更多详细设置可以参考 Next 的文档。\n\n***\n\n# 2. 修改博客内容背景色\n\n默认情况下，博客显示文章、文章列表、分类、标签、归档等等页面时，文字的底色就是白色，这其实不仅不美观，看久了还觉得累眼睛：\n\n<center>\n\n![默认背景](/post_files/blogdiy/blogdiy-8-background/background_default.png \"TOPICS\")\n\n</center>\n\n为了避免这种白底黑字的视觉效果，可以在 ``/next/source/css/_schemes/Gemini/index.styl`` 内找到：\n\n```javascript\n// Post & Comments blocks.\n.post-block {\n  padding: $content-desktop-padding;\n  background: #ddd;  // 修改这里的颜色\n  box-shadow: $box-shadow-inner;\n  border-radius: $border-radius-inner;\n}\n```\n\n把 ``background`` 默认的白色 white 修改为自定义颜色即可，我自己用的是 ``#ddd``。此外，通常还会选择加一点透明度，网上比较大众的做法就是在 ``/next/source/css/_custom/custom.styl`` 内增加一段：\n\n```javascript\n.main-inner {\n  opacity: 0.8;\n}\n```\n\n这样加上了透明效果，看起来好多了！不会再像白底黑字一样过于刺眼，效果如下：\n\n<center>\n\n![优化主体背景](/post_files/blogdiy/blogdiy-8-background/main_background_custom.png \"TOPICS\")\n\n</center>\n\n***\n\n# 3. 修改侧栏背景\n\n<br/>\n\n## 3.1 修改主侧栏背景\n前两部分别自定义了背景和主体背景/透明度之后，会发现对显示“首页、分类、标签...”的这个侧栏并不生效，原因是这个侧栏属于单独的控件 ``header-inner``，所以只需要在 ``/next/source/css/_custom/custom.styl`` 内加上这么一段即可：\n\n```javascript\n.header-inner {\n  // 也可以同时定义背景色\n  // background: #ddd\n\n  opacity: 0.8;\n}\n```\n\n确实，可以改变主侧栏的显示透明度，不过这也会带来一个问题：搜索框不显示，或者只能透出一点点但无法输入也无法获取焦点，这个问题以及解决方案在：[Hexo博客DIY（5）博客站内本地搜索及相关问题](/post/BlogDIY/blogdiy-5-search/ \"TOLINKS\")中的第 4 点有详细介绍，可以参考一下。简单来说就是把这个透明度改为单独的带有透明效果的 RGB 主体底色：\n\n```javascript\n.header-inner {\n  // 颜色可自定义\n  background: #ddddddcc\n\n  // 直接设置透明度会导致搜索窗弹不出来\n  // opacity: 0.8;\n}\n```\n\n效果如下：\n\n<center>\n\n![默认高亮菜单背景](/post_files/blogdiy/blogdiy-8-background/activate_menu_default.png \"TOPICS\")\n\n</center>\n\n颜色的选择可以和主体底色一致，看起来比较和谐。不过还有一个地方就是主侧栏上的不同菜单，已被选定的、鼠标悬停的高亮菜单颜色还是白底，修改的文件在 ``themes/next/source/css/_schemes/Pisces/_menu.styl``：\n\n```javascript\n.menu-item-active a {\n  background: #ddddddcc;  // 修改这里\n  border-bottom-color: white;\n\n  ......\n\n}\n```\n\n修改完的效果：\n\n<center>\n\n![自定义高亮菜单背景](/post_files/blogdiy/blogdiy-8-background/activate_menu_custom.png \"TOPICS\")\n\n</center>\n\n<br/>\n\n## 3.2 修改浮动侧栏背景\n\n同样，浮动侧栏（阅读文章时显示目录的侧栏）的背景色默认也是白色：\n\n<center>\n\n![浮动侧栏默认背景](/post_files/blogdiy/blogdiy-8-background/sidebar_background_default.png \"TOPICS\")\n\n</center>\n\n可在 ``/next/source/css/_schemes/Pisces/_sidebar.styl`` 中修改：\n\n```javascript\n.sidebar-inner {\n  //padding: 20px 10px 0;\n  box-sizing: border-box;\n  width: $sidebar-desktop;\n  color: $text-color;\n  background: #ddd;  // 修改这里\n  box-shadow: $box-shadow;\n  border-radius: $border-radius;\n\n  ......\n\n}\n```\n\n我把 ``background`` 默认的 white 同样改为了 ``#ddd``，理论上也可以直接在 custom.styl 内修改，不过还没尝试过，效果如下：\n\n<center>\n\n![浮动侧栏自定义背景](/post_files/blogdiy/blogdiy-8-background/sidebar_background_custom.png \"TOPICS\")\n\n</center>\n\n***\n\n# 4. 修改“阅读全文”按钮背景\n\n在修改完前面几个背景之后，还有一个问题，就是“阅读全文”这个按钮的颜色还是原来的白底黑字，和文章底色相比显得有些突兀：\n\n<center>\n\n![“阅读全文”按钮默认背景](/post_files/blogdiy/blogdiy-8-background/button_background_default.png \"TOPICS\")\n\n</center>\n\n修改这个按钮在 ``/next/source/css/_common/components/buttons.styl``：\n\n```javascript\n.btn {\n  display: inline-block;\n  padding: 0 20px;\n  font-size: $btn-default-font-size;\n  color: $btn-default-color;\n  background: #ddd;  // 修改这里\n\n  ......\n\n}\n```\n\n同样改为了 ``#ddd``，同理下面的代码还可以修改鼠标覆盖时的效果、大小、表框、内距外距等，修改效果如下：\n\n<center>\n\n![阅读全文按钮自定义背景](/post_files/blogdiy/blogdiy-8-background/button_background_custom.png \"TOPICS\")\n\n</center>\n\n。如果想要修改全局颜色，可以在 ``/next/source/css/_variables/base.styl`` 中查找到对应全局颜色并修改。当然这个文件里面除了颜色外，还有一些角度、尺寸等等都是全局性的。\n\n***\n\n# 5. 修改评论区背景\n\n评论区和博客文章、主体区是两个部分，评论区的背景需要单独设置，在 ``/next/source/css/_schemes/Gemini/index.styl`` 中修改：\n\n```javascript\n// Comments blocks.\n.comments {\n  padding: $content-desktop-padding;\n  margin: auto;\n  margin-top: $sidebar-offset;\n  background: #ddd;  // 修改这里\n  box-shadow: $box-shadow;\n  border-radius: $border-radius;\n}\n```\n\n修改成和文章主体同样的 ``#ddd``，效果如下：\n\n<center>\n\n![评论区自定义背景](/post_files/blogdiy/blogdiy-8-background/comment_background_custom.png \"TOPICS\")\n\n</center>\n\n看起来舒服多了！\n\n***\n\n# 6. 修改博客顶部横条背景\n\n在默认情况下，站点的顶端其实有一个横条，横条默认是和菜单颜色一致的，平时可能看不出来，但是如果把页面拉到顶端再往上拉一点（可能用鼠标滚轮无法显示，用笔记本的触控板可以）就会看到有这么一个条：\n\n<center>\n\n![顶部横条](/post_files/blogdiy/blogdiy-8-background/header_ban_default.png \"TOPICS\")\n\n</center>\n\n在普通情况下，当页面拉到顶端时，这个条使得主侧栏和主体部分和页面顶端有一个连接的感觉，会导致感觉上顶部的圆角有点违和：\n\n<center>\n\n![顶部横条默认样式](/post_files/blogdiy/blogdiy-8-background/header_band_not_fit.png \"TOPICS\")\n\n</center>\n\n为了去掉这个条，但又使得顶部能空出一小段距离，可以在 ``next/source/css/_common/components/header/headerband.styl`` 中修改：\n\n```javascript\n.headband {\n  height: 10px;  // 宽度\n  background: transparent;  // 颜色\n}\n```\n\n默认情况下，主页文章之间的间隔大概在 10 ~ 15 左右，因此我把宽度设置为 10，并且把颜色设置为透明，效果如下：\n\n<center>\n\n![顶部横条自定义样式](/post_files/blogdiy/blogdiy-8-background/header_band_fit.png \"TOPICS\")\n\n</center>\n\n***\n\n# 7. 修改过渡动画速度\n\n默认的过渡动画其实挺慢的，每次载入的时候都觉得等了很久，尤其是有时候找文章或者需要来回切换页面的时候，每次都要等一会儿页面才加载进来的感觉特别不爽，于是找了一下源码，发现动画速度是由这个文件控制的：``next/source/js/motion.js``，打开并修改其中 ``duration`` 字段的值，根据自己的喜好修改即可，我自己用的方案如下：\n\n```javascript\nshowSidebar: function() {\n  \n  ......\n\n  this.sidebarEl.velocity('stop').velocity({\n        width: SIDEBAR_WIDTH\n      }, {\n\n        // 这里维持原状\n        duration: SIDEBAR_DISPLAY_DURATION,\n\n        ......\n\n      }\n\n  ......\n\n}\n\n......\n\nfunction getMistLineSettings(element, translateX) {\n        return {\n          e: $(element),\n          p: {translateX: translateX},\n          o: {\n            // 这里修改为 200\n            duration     : 200,\n            sequenceQueue: false\n          }\n        };\n      }\n\n......\n\nmenu: function(integrator) {\n\n      ......\n\n      $('.menu-item').velocity('transition.slideDownIn', {\n        display : null,\n        // 这里也维持原状\n        duration: 200,\n      });\n    },\n```\n\n除了以上标明的三处之外，其他的 ``duration`` 字段都设置成 80。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（7）文章置顶和引用式文章","url":"/post/blogdiy/blogdiy-7-top/","content":"<!-- more -->\n\n***\n\n# 1. 文章置顶\n\nHexo 本身并没有内置文章置顶功能，因此需要自行安装。不过 Hexo 本身有一个对文章排序的组件，也就是在站点配置文件内的 ``index_generator`` 选项，置顶功能其实就是每次排序的时候，把其中的置顶文章排在最前，本质上是一个排序组件，Hexo 默认的是 ``hexo-generator-index``，所以先卸载再重新安装一个可以置顶的排序组件：\n\n```shell\n# 先卸载\nnpm uninstall --save hexo-generator-index\n\n# 再安装\nnpm install --save hexo-generator-index-pin-top\n```\n\n从插件名字上就能看得出来支持置顶了。该插件的 GitHub 地址：[hexo-generator-index-pin-top](https://github.com/netcan/hexo-generator-index-pin-top \"TOLINKS\")。插件安装完之后，只需要在文章头部信息栏内设置 ``top`` 属性即可：\n\n```yml\n---\ntitle: Hexo博客DIY（7）文章置顶和引用式文章\ndate: 2019-01-10 07:31:04\ntop: true\n---\n```\n\n这样这篇文章就具有置顶效果了。不过，仅仅只是这么做，文章虽然确实置顶了，但是从文章列表上来看，和普通的文章没什么不同。如果不特意去对比文章发布时间，可能会以为只是最新的文章而已。例如一些说明、通知之类的，为了能有个比较突出的标志，可以在 ``next/layout/_macro/post.swig`` 文件中找到以下位置并添加代码：\n\n```javascript\n<div class=\"post-meta\">\n  // 加在这里\n  {% if post.top %}\n    <i class=\"fa fa-thumb-tack\" style=\"color: #EB6D39\"></i>\n    <font color=EB6D39>置顶</font>\n    <span class=\"post-meta-divider\">|</span>\n  {% endif %}\n  <span class=\"post-time\">\n    ...\n    ...\n```\n\n这里的图标、文字、以及各自对应的颜色都可以自定义。完成后的效果就是：\n\n<center>\n\n![文章置顶效果](/post_files/blogdiy/blogdiy-7-top/top_with_icon.png \"TOPICS\")\n\n</center>\n\n***\n\n# 2. 引用式文章\n\n现在文章置顶已经成功实现了，但是还有个问题，比如像我的博客，文章置顶是类似于一个窗格的形式，更符合“置顶消息”这么一个设定，没有标题、没有分类和标签、没有日期等等，但是如果不填写 title 栏，仍然会显示一个默认的“未命名”标题：\n\n<center>\n\n![无标题文章](/post_files/blogdiy/blogdiy-7-top/untitle_post.png \"TOPICS\")\n\n</center>\n\n而且会导致搜索无法使用，因此如果想实现这种：\n\n<center>\n\n![引用式文章](/post_files/blogdiy/blogdiy-7-top/quote_post.png \"TOPICS\")\n\n</center>\n\n就需要在文章的头部信息栏加入一个 ``type`` 属性：\n\n```yml\n---\ntitle: Hexo博客DIY（7）文章置顶和引用式文章\ndate: 2019-01-10 07:31:04\ntype: \"quote\"\ncategories:\ntags:\n---\n```\n\n并且取值为 \"quote\"，这样文章就会变成一个完全没有标题和各种属性的引用块了。\n\n***\n\n# 3. 增加版本记录\n\n目前主流的两个博客部署平台就是 GitHub Page 和 Coding 了，Coding 的部署速度还算比较快，GitHub 因为某些特殊原因，部署完之后实际内容生效时间的间隔有些长，表现为从本地 Hexo 部署到 Page 后，需要过几分钟网络上的内容才生效。有时做了一些小改变，也不知道到底是延迟未生效，还是改动本身没有作用。因此可以增加一个版本标志，每次部署的时候手动 +1，并显示在博客内，这样即可通过版本号是否一致来判断当前网络上的是否最新版本了。\n\n首先在站点配置文件 ``blog/_config.yml`` 中增加一个字段：\n\n```yml\n# Update Version\n## Custom tag for last update recording\nlatestVersion: 627\n```\n\n然后在需要显示的地方使用以下代码：\n\n```javascript\n<span style=\"color: #666666;font-size:10px;\">V{{ config.latestVersion }}</span>\n```\n\n具体的显示信息可以自己 DIY，如果想使用局部变量来获取这个数值，可以在 ``themes/next/layout/_layout.swig`` 中找到如下位置添加变量：\n\n```javascript\n{# Language & Config #}\n{% set title = __('title') !== 'title' && __('title') || config.title %}\n{% set subtitle = __('subtitle') !== 'subtitle' && __('subtitle') || config.subtitle %}\n{% set author = __('author') !== 'author' && __('author') || config.author %}\n{% set description = __('description') !== 'description' && __('description') || config.description %}\n{% set latestVersion = __('latestVersion') !== 'latestVersion' && __('latestVersion') || config.latestVersion %}\n```\n\n然后在需要使用的地方直接使用：\n\n```javascript\n{{ latestVersion }}\n```\n\n引用即可，当然，使用类似的方法也可以显示在侧栏、标题栏等位置，由于我的博客使用了一个置顶的引用式文章，出于这个主题手机版不会显示侧栏，因此选择同时显示在悬浮侧栏和置顶文章的最顶处。\n\n（1）在置顶文章处显示的效果如下图所示：\n\n<center>\n\n![置顶文章显示博客版本](/post_files/blogdiy/blogdiy-7-top/latest_version.png \"TOPICS\")\n\n</center>\n\n这个效果是通过判断文章是否是”置顶引用文“来设置的，可以先给置顶的引用文增加一个自定义属性：``topic``，然后在 ``next/layout/_macro/post.swig`` 文件中找到 ``Post Body`` 部分：\n\n```javascript\n<div class=\"post-body{% if theme.han %} han-init-context{% endif %}{% if post.direction && post.direction.toLowerCase() === 'rtl' %} rtl{% endif %}\" itemprop=\"articleBody\">\n  {# Gallery support #}\n  {% if post.photos and post.photos.length %}\n    ......\n  {% endif %}\n\n  {############### ↓↓↓↓↓ 在悬浮置顶文中添加版本标识 ↓↓↓↓↓ ###############}\n  {## 显示版本标识 ##}\n  {% if post.latestVersion %}\n    <span style=\"color: #666666;font-size:10px;\">V{{ config.latestVersion }}</span>\n  {% endif %}\n  {############### ↑↑↑↑↑ 在悬浮置顶文中添加版本标识 ↑↑↑↑↑ ###############}\n\n  {% if is_index %}\n    ......\n  {% endif %}\n\n  ......\n</div>\n```\n\n（2）悬浮侧栏的显示效果如下图所示：\n\n<center>\n\n![悬浮侧栏显示博客版本](/post_files/blogdiy/blogdiy-7-top/latest_version_in_sidebar.png \"TOPICS\")\n\n</center>\n\n这个效果需要在文件 ``next/layout/_macro/sidebar.swig`` 里找到 ``if theme.site_state`` 并修改：\n\n```javascript\n{% if theme.site_state %}\n  <nav class=\"site-state motion-element\">\n\n\n\n    {############### ↓↓↓↓↓ 在侧栏中添加版本标识 ↓↓↓↓↓ ###############}\n    <div class=\"site-state-item\">\n      {########## 显示版本标识 ##########}\n      <span class=\"site-state-item-count\">{{ config.latestVersion }}</span>\n      <span class=\"site-state-item-name\">{{ __('state.latestVersion') }}</span>\n    </div>\n    {############### ↑↑↑↑↑ 在侧栏中添加版本标识 ↑↑↑↑↑ ###############}\n\n\n\n    {% if config.archive_dir != '/' and site.posts.length > 0 %}\n      ......\n    {% endif %}\n\n    {% if site.categories.length > 0 %}\n      ......\n    {% endif %}\n\n    {% if site.tags.length > 0 %}\n      ......\n    {% endif %}\n  </nav>\n{% endif %}\n```\n\n并且在 ``next/languages/`` 目录下，找到 ``en.yml`` 和 ``zh-CN.yml`` 这两个语言文件（根据自己的博客语言需求修改对应的文件即可），分别在里面找到 ``state`` 字段并增加一个 ``latestVersion`` 属性：\n\n```yml\n# 中文语言文件修改如下\nstate:\n  latestVersion: 版本\n  posts: 文章\n  pages: 页面\n  tags: 标签\n  categories: 分类\n\n# 英文语言文件修改如下\nstate:\n  latestVersion: Version\n  posts: posts\n  pages: pages\n  tags: tags\n  categories: categories\n```\n\n***\n\n# 4. 从侧栏去掉文章计数\n\n正常情况下，Next 主题侧栏会有一个显示文章、分类、标签的计数，但是如果我们创建了一个上文所示的“引用式文章”，而只是用来做一些通知、信息展示等功能，可能就并不想把这些文章算进去。想要减掉这部分的文章数量，可以在 ``next/layout/_macro/sidebar.swig`` 文件里找到 ``if theme.site_state`` 的部分并修改：\n\n```javascript\n{% if theme.site_state %}\n\n    ......\n\n    {########## 去掉侧栏中对博客置顶条的文章计数 ##########}\n    <span class=\"site-state-item-count\">{{ site.posts.length - 1 }}</span>\n    <span class=\"site-state-item-name\">{{ __('state.posts') }}</span>\n\n    ......\n\n{% endif %}\n```\n\n其实就是直接把 ``site.posts.length`` 减掉了 1 而已，方法是笨方法，因为如果删掉了那篇文章，或者新增了一篇，还要再改一次源码，不过这是个备用方法，看看有没有办法能找到 ``site.posts`` 统计的地方然后直接不读取指定属性的文章。\n\n***\n\n# 5. 从“归档”去掉文章\n\n如果选择从侧栏的文章计数中去掉了某篇文章，可能也会希望“归档”里同样不记录，同样，归档里也有一个文章计数，还另有一个所有文章的列表，可以看到我的归档里并不包括置顶那个“信息栏”的文章，修改的方式也很类似，找到 ``next/layout/archive.swig`` 文件中 ``ARCHIVE BLOCK`` 部分并修改：\n\n```javascript\n{#####################}\n{### ARCHIVE BLOCK ###}\n{#####################}\n<div class=\"post-block archive\">\n\n  ......\n\n  {% if theme.cheers %}\n\n    ......\n\n  {% else %}\n\n    <span class=\"archive-page-counter\">\n      {% set posts_length = site.posts.length %}\n      {########## 设置 post_length 以修改归档页上方的文章计数 ##########}\n      {{ _p(\"counter.archive_posts\", site.posts.length - 1) }}\n    </span>\n\n  {% endif %}\n```\n\n同样，直接把 ``site.posts.length`` 减掉了 1 来去掉计数。\n\n同样在 ``ARCHIVE BLOCK`` 部分，再在刚才的代码下面找到循环遍历所有文章的部分并修改：\n\n```javascript\n{% for post in page.posts %}\n  {########## 增加 if 判断文章是否设置字段 topic: true ##########}\n  {% if not post.topic %}\n\n    {########## 把原本 for 循环里面的代码放进这个 if 里面来 ##########}\n    ......\n\n  {% endif %}\n{% endfor %}\n```\n\n这样，只要我们在文章的头部信息栏内增加一个 ``topic`` 标签（可以自定义，只要代码里和文章里一致即可），就能从“归档”的列表中去掉这篇文章！同理，也可以增加任意约束，比如去掉日期早于某个时候的文章、去掉带有某个标签的文章等等，只要把约束全部加进 ``if`` 里去即可。不过这里的修改只影响到“归档”中的列表，博客首页的所有文章还是会显示的，想要博客不加载某篇文章会在以后介绍。\n\n***\n\n# 6. 禁止通过“下一篇”进入\n\n通过上文的修改，这篇置顶的引用式文章已经无法从“归档”和文件列表里进入了，但是还有一个方法可以进入，就是先点击进入这篇置顶文章的前一篇文章，然后通过“下一篇”的链接进入：\n\n<center>\n\n![点击“下一篇”进入](/post_files/blogdiy/blogdiy-7-top/topic_from_next_post.png \"TOPICS\")\n\n</center>\n\n这样就能以普通文章的形式查看了：\n\n<center>\n\n![查看置顶引用式文章](/post_files/blogdiy/blogdiy-7-top/topic_post.png \"TOPICS\")\n\n</center>\n\n但其实因为这篇文章只是用来作为置顶栏使用，既没有标题又没有什么有价值的内容，这么显示出来挺不美观的，因此可能不希望让读者不经意间进入这篇文章的详细内容，为此可以修改 ``themes/next-711/layout/_macro/post.swig``：\n\n```javascript\n{#####################}\n{### Prev and Last ###}\n{#####################}\n{% if not is_index and (post.prev or post.next) %}\n  <div class=\"post-nav\">\n\n    {### 后一篇 ###}\n\n    <div class=\"post-nav-next post-nav-item\">\n      {### ↓↓↓重点修改下面这行↓↓↓ ###}\n      {% if post.next and not post.next.topic %}\n      {### ↑↑↑重点修改上面这行↑↑↑ ###}\n        <a href=\"{{ url_for(post.next.path) }}\" rel=\"next\" title=\"{{ post.next.title }}\">\n          <i class=\"fa fa-chevron-left\"></i> {{ post.next.title }}\n        </a>\n      {% endif %}\n    </div>\n\n    <span class=\"post-nav-divider\"></span>\n\n    {### 前一篇 ###}\n\n    <div class=\"post-nav-prev post-nav-item\">\n      {### ↓↓↓重点修改下面这行↓↓↓ ###}\n      {% if post.prev and not post.prev.topic %}\n      {### ↑↑↑重点修改上面这行↑↑↑ ###}\n        <a href=\"{{ url_for(post.prev.path) }}\" rel=\"prev\" title=\"{{ post.prev.title }}\">\n          {{ post.prev.title }} <i class=\"fa fa-chevron-right\"></i>\n        </a>\n      {% endif %}\n    </div>\n  </div>\n{% endif %}\n\n{% set isLast = loop.index % page.per_page === 0 %}\n{% if is_index and not isLast %}\n  <div class=\"post-eof\"></div>\n{% endif %}\n```\n\n在上面第 4 条中，去掉“归档”内的置顶栏文章，用到了文章内的自定义属性 ``topic``，这里也同样适用。在 ``if`` 判断上一篇和下一篇文章是否为空的地方，加一个 `` and not post.prev.topic``，表示 ``当 上一篇 / 下一篇 文章不为空，并且 上一篇 / 下一篇 文章的 topic 不为 true 时``，这样只要置顶栏文章设置了 ``topic: true`` 就能同时从“归档”和“上一篇 / 下一篇”里消失了！不过这里有一个小小的坑，代码里面的 ``prev`` 直译过来应该是“前一个”，但在文章的“上一篇/下一篇”中对应的是右边那个，也是时间上更晚的一个，从直觉的角度来看或许更应该叫“下一个”。而 ``next`` 直译过来是“下一个”，但在文章的“上一篇/下一篇”中对应的是左边那个，时间上是更早的一个，从直觉上来看反倒应该是“前一个”才对，不知道是不是开发人员搞混了哈哈，记录一下以防踩坑。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（6）动态头像与动态浏览器标题","url":"/post/blogdiy/blogdiy-6-avatar-title/","content":"<!-- more -->\n\n***\n\n# 1. 侧栏头像动画\n\n先从简单的开始吧！修改头像其实很简单，直接把头像放进 ``next/source/images/`` 下，然后再主题配置文件中，找到以下部分：\n\n```yml\n# Sidebar Avatar\navatar:\n  # In theme directory (source/images): /images/avatar.gif\n  # In site directory (source/uploads): /uploads/avatar.gif\n  # You can also use other linking images.\n  url: /images/avatar.jpg\n  # If true, the avatar would be dispalyed in circle.\n  rounded: true\n  # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar.\n  opacity: 1\n  # If true, the avatar would be rotated with the cursor.\n  rotated: true\n```\n\n在 ``url`` 处指定头像文件即可，头像可以是网络图片，只需要把本地路径替换为网络图片的网址即可。另外，当打开了 ``rotated`` 后，鼠标移到头像处会逆时针旋转半圈，鼠标移开又转回来，不过这个效果看起来好像也比较普通，如果你想让鼠标一过去头像就控记不住记几鬼畜疯狂旋转，就像这样：\n\n<center>\n\n![鼠标覆盖头像鬼畜式旋转](/post_files/blogdiy/blogdiy-6-avatar-title/avatar_rotate_hover.gif \"TOPICS\")\n\n</center>\n\n请找到这个文件并愤怒地打开它：``/next/source/css/_common/components/sidebar/sidebar-author.styl``，然后找到如下部分修改：\n\n```javascript\nif hexo-config('avatar.rotated') {\n  .site-author-image {\n    transition: transform 1.0s ease-out;\n    /*animation: rotate 5s linear infinite;*/\n  }\n  /*@keyframes rotate{from{transform: rotate(0deg)}\n  to{transform: rotate(360deg)}\n  }*/\n\n  /* 原本只是简单地逆时针旋转 180°\n  .site-author-image:hover {\n    transform: rotateZ(-180deg);\n  }\n  */\n  .site-author-image:hover {\n    animation: rotate 0.15s linear infinite;\n  }\n  @keyframes rotate{from{transform: rotate(0deg)}\n  to{transform: rotate(360deg)}\n  }\n}\n```\n\n``.site-author-image:hover`` 就是鼠标覆盖上去时的代码，代码的意思就是：动画是 rotate，时间是 0.15 秒（也即 0.15 秒转一圈），动画速度是线性，动画重复无限次，在下方定义了旋转的角度是从 0 ~ 360°，其中正数是顺时针旋转，负数是逆时针旋转。设置完了以后别忘了 Hexo 三连一下试试效果。如果你不想这么鬼畜，想走文艺路线，就换一下注释并且让它转的缓慢一点唱片式旋转，变成：\n\n```javascript\nif hexo-config('avatar.rotated') {\n  .site-author-image {\n    transition: transform 1.0s ease-out;\n    animation: rotate 5s linear infinite;\n  }\n  @keyframes rotate{from{transform: rotate(0deg)}\n  to{transform: rotate(360deg)}\n  }\n\n  .site-author-image:hover {\n    /*animation: rotate 0.15s linear infinite;*/\n  }\n  /*@keyframes rotate{from{transform: rotate(0deg)}\n  to{transform: rotate(360deg)}\n  }*/\n}\n```\n\n<center>\n\n![文艺风头像唱片式旋转](/post_files/blogdiy/blogdiy-6-avatar-title/avatar_rotate_normal.gif \"TOPICS\")\n\n</center>\n\n***\n\n# 2. 浏览器标签页动态标题\n\n先看看效果：\n\n<center>\n\n![浏览器标签页动态标题](/post_files/blogdiy/blogdiy-6-avatar-title/animate_browser_title.gif \"TOPICS\")\n\n</center>\n\n首先在 ``next/source/custom/`` 下找一个地方新建一个 animator_title.js 文件（路径和文件名均可自定义），输入以下内容：\n\n```javascript\n<!--动态浏览器标签-->\n var OriginTitle = document.title;\n var titleTime;\n var titleTime2;\n var titleTime3;\n document.addEventListener('visibilitychange', function () {\n     if (document.hidden) {\n         $('[rel=\"icon\"]').attr('href', \"/images/favicon-32x32-next.png\");\n         document.title = \"Waiting...\";\n         clearTimeout(titleTime);\n         clearTimeout(titleTime2);\n         clearTimeout(titleTime3);\n     }\n     else {\n         document.title = \"Welcome\";\n         titleTime = setTimeout(function () {\n             document.title = \"Back\";\n             titleTime2 = setTimeout(function () {\n                 document.title = \"Welcome Back !\";\n                 titleTime3 = setTimeout(function () {\n                     document.title = OriginTitle;\n                 }, 800);\n             }, 500);\n         }, 500);\n     }\n });\n```\n\n然后打开 ``next/layout/_layout.swig`` ，在最底下定格加入如下代码：\n\n```javascript\n<script type=\"text/javascript\" src=\"/custom/animator_title.js\"></script>\n```\n\n具体的文件名和路径请按照自己的实际情况修改。其实我这个效果做的太 Low 了，从别的网页切回来就是三个定时器的嵌套，不知道有没有办法可以重用定时器，还望大佬指明。\n\n另外，``icon`` 处可以自定义一个小图像，可以是本地图像也可以是网络图片。不过需要注意的是，这里如果选择本地图片，“/”表示的就不是博客根目录了，而是主题根目录，所以“/images/”其实和“blog/themes/next/images/”是等价的。同理，在主题配置文件中的 ``favicon`` 选项设置的也是浏览器标签页小图标，指定的路径也是以主题根目录为起始路径的。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n\n***\n\n# 3. 附录[参考指导]\n\n> - [【1】Hexo NexT主题中添加网页标题崩溃欺骗搞怪特效（作者：asdfv1929）<sup>【注】</sup>](https://asdfv1929.github.io/2018/01/25/crash-cheat/ \"ToLinks\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（5）博客站内本地搜索及相关问题","url":"/post/blogdiy/blogdiy-5-search/","content":"<!-- more -->\n\n***\n\n# 1. 启用博客搜索\n\n搜索功能基本在 Next 主题内就有介绍，一个是在线搜索，一个是本地搜索。我个人选择了本地搜索功能，引入也很简单，执行命令：\n\n```shell\nnpm install hexo-generator-search --save\n```\n\n并在主题配置文件内找到：\n\n```yml\n# Local search\n# Dependencies: https://github.com/theme-next/hexo-generator-searchdb\nlocal_search:\n  enable: true\n  # If auto, trigger search by changing input.\n  # If manual, trigger search by pressing enter key or search button.\n  trigger: auto\n  # Show top n results per article, show all results by setting to -1\n  top_n_per_article: 1\n  # Unescape html strings to the readable one.\n  unescape: false\n```\n\n将 ``enable`` 设置为 true 即可。\n\n***\n\n# 2. 搜索无法使用\n\n在使用搜索功能时，有时可能会遇到：点击搜索后，一直处于加载中的状态，无法正确显示搜索框。其原因可能是以下几点之一导致的：\n\n  1. 如果你是最近才开始建立的这个博客，但在网上查看别人介绍的关于如何开启搜索的文章时间又比较久远，那么可能你照着创建好了以后是搜不到结果的。如果按照之前版本的做法，即使完全照做，建立好本地搜索后，直接从网址进入博客搜索内容载体：``xxx.github.io/search.xml`` 还是会出现 404 页面不存在的情况。\n\n  按照当时的版本，网上的文章可能会告诉你这代表你的搜索模块没有装成功，让你完全去掉搜索后重新安装再试，不过这个现象很可能是因为以前版本的本地搜索，搜索内容存放载体是 ``search.xml``，而现在的存放载体已经变成了 ``search.json``，可以在站点配置文件内查看到：\n\n  ```yml\n  # The following content is not recommended to modify\n  # 搜索数据文件路径设置，不建议改动：\n  search:\n    path: search.json\n    field: post\n  ```\n\n  同样，你也可以在 Hexo 命令三连之后，在博客根目录下的 public 文件夹内找到这个文件：search.json\n  3. 如果上面的没有做错，还是出现了无法搜索的情况，那就有可能是因为特殊字符的原因了，对于这个特殊字符：``\\u8``，会导致本地搜索无法正确读取并编码，如何确定这种问题？就是直接在你的博客首页网址后面接上 ``/search.json`` 跳转到搜索载体，如果页面上显示的是很多文字，那就说明你的文章内没有特殊字符：\n\n  <center>\n\n  ![正常的 search.json 样式](/post_files/blogdiy/blogdiy-5-search/search_json_normal.png \"TOPICS\")\n\n  </center>\n\n  否则会出现报错，由于我无法重现，因此从 [这篇文章（作者：国光）](https://www.sqlsec.com/2017/12/hexosearch.html \"TOLINKS\")内找了一个图片：\n\n  <center>\n\n  ![有特殊字符的 search.json 样式](/post_files/blogdiy/blogdiy-5-search/search_json_error.png \"TOPICS\")\n\n  </center>\n\n  Sublime Text3 和 VS Code 都可以看到这个字符，因此可以使用这两个编辑器查看并删除字符。\n\n***\n\n# 3. 搜索没有结果\n\n还有一种情况，就是已经开启搜索功能，直接进入搜索内容文件 ``xxx.github.io/search.json`` 也能打开并且没有异常，搜索框可以正确弹出，但是无论你搜索什么内容，下面的搜索结果栏都是空白的：\n\n<center>\n\n![搜索没有结果](/post_files/blogdiy/blogdiy-5-search/search_error_no_result.png \"TOPICS\")\n\n</center>\n\n这种情况很可能是因为你有某一篇文章没有标题，比如我的博客置顶的文章，我设置的文章类型是“quote”，这就使得这篇文章不会显示标题，但在这篇文章的文件内，title 属性还是必须要写的，因为不会显示所以随便写即可，否则就会导致无法搜索。\n\n***\n\n# 4. 搜索框无法显示\n\n有些个性化比较多的博客，应用了大量视觉效果，结果突然发现点击搜索后，博客页面有变暗的效果，但搜索框根本显示不出来（Safari 浏览器），也没有加载中的图标，即使能显示出来（Chrome 浏览器），也无法获取焦点、无法输入文字，就像这样：\n\n<center>\n\n![无法显示搜索框](/post_files/blogdiy/blogdiy-5-search/search_error_not_show.png \"TOPICS\")\n\n</center>\n\n出现这个情况的，很可能博客个性化比较丰富，如果目前还没遇到可以跳过，在系列后面一篇关于背景 DIY 的文章会再讲到这个问题。\n\n先说原因：很大可能是因为自己调整了博客整体的透明度，也就是修改了这个文件：``next/source/css/_custom/custom.styl`` 添加这一段：\n\n```javascript\n// 修改主体透明度\n.main-inner {\n  opacity: 0.8;\n}\n\n// 修改侧栏透明度\n.header-inner {\n  opacity: 0.8;\n}\n```\n\n网上有不少 DIY 的文章里面都有提到，给博客加了一个自定义的背景图片以后，为了让博客具有一定的半透明效果给整体设置一个透明度，这么设置其实没有什么错，但是！由于 Next 主题中，搜索是基于固定侧栏（也就是 header-inner）的一个弹窗 Popup，而 ``opacity`` 这个属性设置的是整个界面控件的不透明度，所以会导致弹窗的绘制在后，使得弹窗被覆盖在了博客显示界面的底下。要解决这个问题，无非就是去掉 ``opacity`` 属性（或者把值设为1）或者禁用搜索，但如果既想保留搜索功能还想要带点不透明度（比如我目前这个博客）怎么办？其实也很简单，曲线救国：\n\n```javascript\n// 注意修改的是 header-inner 部分\n.header-inner {\n  background: #ddddddcc\n}\n```\n\n把设置改成这样即可！单独调整博客界面控件的填充背景，其中这个 RGB 颜色值的前六位 ``#dddddd`` 表示的是背景颜色（也就是整个博客主体背景包括文章的底色），这个可以随便自定义，后面的两位 ``cc`` 代表的是不透明度，也可以随便定义。由于这个 RGB 色是 16 进制色，所以颜色和不透明度都要用 16 进制来表示，完全不透明是 ``ff``，完全透明是 ``00``，不透明度 0.8 也就是 16 进制里面的 ``cc``。这么设置以后，就能同时保留搜索和背景半透明了。如果想调整透明度又不太熟悉 16 进制的，可以这么计算：``ff`` 对应的 10 进制数值为 255，想要多少透明度（比如 0.8），就用 ``255 x 0.8 = 204``，再从 10 进制转换为 16 进制（网上很多工具）即可得到：``204(x10) = cc(x16)``。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（4）在线聊天和文章评论","url":"/post/blogdiy/blogdiy-4-chat-comment/","content":"<!-- more -->\n\n***\n\n# 1. DaoVoice免登陆聊天功能\n\n在我博客的右下角有一个悬浮聊天窗，点击即可直接发起会话，当我不在线时，后台会将消息发送到我的邮箱，这是基于 [DaoVoice](http://www.daovoice.io \"TOLINKS\") 的实现方案。\n\n开启 DaoVoice 也比较简单，首先去[官网](http://www.daovoice.io \"TOLINKS\")注册一个账号然后登录，进入控制台，点击左侧“应用设置”，并在子菜单选择“安装到网站”：\n\n<center>\n\n![DaoVoice 安装到网站](/post_files/blogdiy/blogdiy-4-chat-comment/daovoice_apply_to_web.png \"TOPICS\")\n\n</center>\n\n在图里中间那个红框处标记了一个 app_id，把它记下来，接着到主题配置文件中，随表找一个地方顶格添加以下配置：\n\n```yml\n# Daovoice\ndaovoice:\n  enable: true\n  app_id: xxxxxxxx\n```\n\n``daovoice_app_id`` 就填写刚才控制台获得的那个。接下来，将图中上下两个红框那里的代码整体复制下来，找到并打开 ``next/layout/_partials/head/head.swig``，在里面随便找一个顶格的空位粘贴进去，不过需要修改一点，在外层加一个 ``if`` 判断是否开启，然后在 app_id 处将固定的你的 id 改为从配置文件中读取，这样以后想要临时关闭 DaoVoice 时只需要把配置文件中 DaoVoice 的 ``enable`` 设置为 ``false`` 即可，更换了 DaoVoice 账号也只需要更新一下配置文件中 DaoVoice 的 ``app_id`` 即可。也可以直接复制我下面的代码：\n\n```javascript\n{% if theme.daovoice.enable %}\n  <script>\n  (function(i,s,o,g,r,a,m){i[\"DaoVoiceObject\"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=\"utf-8\";m.parentNode.insertBefore(a,m)})(window,document,\"script\",('https:' == document.location.protocol ? 'https:' : 'http:') + \"//widget.daovoice.io/widget/0f81ff2f.js\",\"daovoice\")\n  daovoice('init', {\n      app_id: \"{{theme.daovoice.app_id}}\"\n    });\n  daovoice('update');\n  </script>\n{% endif %}\n```\n\n配置完成后，在 DaoVoice 控制台的 应用设置 - 聊天设置 中可以自定义欢迎语以及按钮的位置、颜色等。\n\n***\n\n# 2. Gitalk评论\n\n文章评论也有多种方案，Disqus、友言、畅言、Valine（基于 Leancloud）、Gitment、Gitalk 等，不过 Disqus 是韩国的，虽说国内是能有的不过有时候还是会莫名其妙像被墙起来了一样，友言和畅言已经停止维护，[最新版的 Next](https://github.com/theme-next/hexo-theme-next/releases/tag/v7.2.0 \"TOLINKS\") 也把 Gitment 移除支持了，不过 Gitalk 和 Gitment 比较类似，都是基于 GitHub 的 Issue 实现的，我个人认为，使用 GitHub 托管的博客，使用 GitHub 自己的 Issue 服务来实现也相当契合，何况 GitHub 不仅免费的已经相当够用，而且还没有流量限制。\n\nNext 主题本身是支持 Gitalk 的，所以引入 Gitalk 只需要像 LeanCloud 和 DaoVoice 一样申请一个 app_id 即可。而由于 Gitalk 本身是基于 GitHub 实现的，所以我们甚至都不需要再另行注册一个账号！\n\n首先在 GitHub 新建一个仓库，用于存储评论的 Issue，当然如果你愿意也可以直接使用博客的仓库。然后在 GitHub 的设置里面，进入最下面的 __Developer settings__，然后再选择 __OAuth Apps__，然后点击右上角 “New OAuth App” 新建一个应用：\n\n<center>\n\n![GitHub OAuth Apps](/post_files/blogdiy/blogdiy-4-chat-comment/github_oauth_apps.png \"TOPICS\")\n\n</center>\n\n在接下来的界面里，输入应用名和博客地址：\n\n<center>\n\n![Add a GitHub OAuth Apps](/post_files/blogdiy/blogdiy-4-chat-comment/github_new_oauth_app.png \"TOPICS\")\n\n</center>\n\n这里需要注意：<font color=#EB6D39>博客地址是你访问时的真实地址，也就是进入自己的博客首页之后地址栏里的 URL，需要带上 https（或 https，根据自己的实际情况），如果购买绑定了自定义域名，需要填写自定义域名</font>。比如，我的博客绑定了域名为：``www.liushulun.cn``，由于我开启了强制 HTTPS，因此这里两个需要填写地址的地方，我都需要输入：``https://www.liushulun.cn``。\n\n新建好了应用后，在应用信息界面就能找到 ``client_id`` 和 ``client_secret``：\n\n<center>\n\n![GitHub OAuth Apps Info](/post_files/blogdiy/blogdiy-4-chat-comment/github_oauth_app_info.png \"TOPICS\")\n\n</center>\n\n复制下来，然后在主题配置文件中找到 Gitalk 相关的配置部分：\n\n```yml\n# Gitalk\n# Demo: https://gitalk.github.io\ngitalk:\n  enable: true\n  github_id:  # Github repo owner\n  repo:  # Repository name to store issues\n  client_id:  # Github Application Client ID\n  client_secret:  # Github Application Client Secret\n  admin_user:  # GitHub repo owner and collaborators, only these guys can initialize github issues\n  distraction_free_mode: true # Facebook-like distraction free mode\n  per_page: 5\n  # Gitalk's display language depends on user's browser or system environment\n  # If you want everyone visiting your site to see a uniform language, you can set a force language value\n  # Available values: en, es-ES, fr, ru, zh-CN, zh-TW\n  language:\n```\n\n  - ``enable``：是否打开 Gitalk 评论功能\n  - ``github_id``：刚才申请 OAuth App 时所用的 GitHub 用户名，注意是用户名而不是地址，用来验证 OAuth App 密钥\n  - ``repo``：刚才新建的（或是已有的）用于保存评论 Issue 的仓库名，注意是仓库名而不是地址，用于指定评论保存在哪个仓库内\n  - ``client_id``：新建的 OAuth App 里面的 client_id 复制过来\n  - ``client_secret``：新建的 OAuth App 里面的 client_secret 复制过来\n  - ``admin_user``：<font color=#EB6D39>重要：这里填你自己的 GitHub 用户名（不是地址），默认情况下新发表的文章 Gitalk 评论是未初始化的状态，需要这里指定的 GitHub 用户才能初始化开启</font>\n  - ``per_page``：评论列表一页显示几条评论\n\n由于是基于 GitHub Issue 的实现，Gitalk 评论支持使用 MarkDown 格式，交流代码会方便很多。不过缺点就是，任何人想要评论则必须使用 GitHub 账号登陆才行。\n\n***\n\n# 3. Valine评论\n\n<br/>\n\n## 3.1 开启Valine\n\nGitalk 评论虽然最符合程序员的喜好，毕竟基于 GitHub 的 Issue，可以自由改动、打 Tag等，但是缺点就是必须登录 GitHub 账号，有时候有些小问题就显得麻烦了，后来发现 LeanCloud 除了可以实现文章阅读统计外，还支持 Valine 评论功能，最关键的是免登陆，而且免费（目前）！于是我的博客最终选择了 Valine 作为评论引擎。\n\n首先 Valine 评论和 LeanCloud 阅读统计同时开启会有冲突（2019-12-04 无意间发现已经不会冲突了），解决方案是关掉 LeanCloud 独立的阅读统计，并在 Valine 设置项中开启统计功能即可，Valine 相关设置如下：\n\n```yml\n# Valine\n# You can get your appid and appkey from https://leancloud.cn\n# More info available at https://valine.js.org\nvaline:\n  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.\n  appid: 输入自己在 LeanCloud 处创建的应用中申请的 AppID\n  appkey: 输入自己在 LeanCloud 处创建的应用中申请的 AppKey\n  notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki\n  verify: false # Verification code\n  placeholder: Nice ! # comment box placeholder\n  # avatar: mm # gravatar style\n  avatar: retro\n  guest_info: nick,mail,link # custom comment header\n  pageSize: 5 # pagination size\n  language: # language, available values: en, zh-cn\n  visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same asleancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html\n  comment_count: false # if false, comment count will only be displayed in post page, not in home page\n```\n\n``appid``、``appkey`` 的设置可以参照系列第三篇中 LeanCloud 阅读统计部分：《[访客与阅读量统计](/post/blogdiy/blogdiy-3-counter/#2-访客与阅读量统计 \"TOLINKS\")》，其他各个字段的含义在 Valine 官网配置详解（[点此直达](https://valine.js.org/quickstart.html, \"TOLINKS\")）中都有说明了，很详细。\n\n但是当开启了 Valine 并部署后，会发现评论处只支持用户输入昵称评论，不能自己输入邮箱、网址等等，效果如下：\n\n<center>\n\n![Valine 只能输入昵称](/post_files/blogdiy/blogdiy-4-chat-comment/valine_only_nick.png \"TOPICS\")\n\n</center>\n\n而官网提供的评论框可以同时输入昵称、邮箱、链接：\n\n<center>\n\n![官网 Valine 可输入全部信息](/post_files/blogdiy/blogdiy-4-chat-comment/valine_nick_email_link.png \"TOPICS\")\n\n</center>\n\n这样当需要使用邮件沟通时，就比较麻烦了。后来通过查看官网的配置信息，以及查看了 Next 主题源码之后发现，原来是 Next 源码直接限制了只能输入昵称，找到 ``next/layout/_third-party/comments/valine.swig``，可以发现源码里面有这么一段：\n\n```javascript\n<script>\n  var GUEST = ['nick', 'mail', 'link'];\n  var guest = '{{ theme.valine.guest_info }}';\n  guest = guest.split(',').filter(function(item) {\n    return GUEST.indexOf(item) > -1;\n  });\n  new Valine({\n    el: '#comments',\n    verify: {{ theme.valine.verify }},\n    notify: {{ theme.valine.notify }},\n    appId: '{{ theme.valine.appid }}',\n    appKey: '{{ theme.valine.appkey }}',\n    placeholder: '{{ theme.valine.placeholder }}',\n    avatar: '{{ theme.valine.avatar }}',\n    guest_info:['nick'] ,  //评论者只需要提供评论的昵称即可\n    meta: guest,\n    pageSize: '{{ theme.valine.pageSize }}' || 10,\n    visitor: {{ theme.valine.visitor }},\n    lang: '{{ theme.valine.language }}' || 'zh-cn'\n  });\n```\n\n重点：\n\n```javascript\nguest_info:['nick'] ,  //评论者只需要提供评论的昵称即可\n```\n\n也就是这里写死了只能输入昵称，其实作者的本意应该是，怕游客以为要全部输入才能评论，所以只开放一个昵称栏，这里到底是否需要设置其他信息可以自行决定，我是为了方便起见使用了昵称 + 邮箱的方式，首先看到 主题配置文件 ``next/_config.yml`` 中 Valine 的设置部分有这么个属性：\n\n```yml\nguest_info: nick,mail,link # custom comment header\n```\n\n这个属性对应在源码 ``next/layout/_third-party/comments/valine.swig`` 中传递给了：\n\n```javascript\nvar guest = '{{ theme.valine.guest_info }}';\nguest = guest.split(',').filter(function(item) {\n  return GUEST.indexOf(item) > -1;\n});\n\n......\n\nmeta: guest,\n```\n\n这段代码的作用也就是从主体配置文件中获取 ``guest_info`` 属性，然后以 ',' 分隔开，再从 ``['nick', 'mail', 'link']`` 中分别获取对应的字符串并组成数组，然后传给 ``meta``。查看 Valine 官网资料可知，这个 ``meta`` 属性是 LeanCloud 存储评论的头部信息，方案 ① 就是输入框直接使用相同的属性：\n\n```javascript\nguest_info: guest,\nmeta: guest,\n```\n\n但是可能我希望所有的评论，在存储到 LeanCloud 中时都带有全部 3 个属性，但用户评论时只可以输入 1 或 2 个信息（比如我），总之就是用户可以输入的信息和 LeanCloud 存储的信息不一致，那么就需要自定义一个属性了。\n\n首先在主题配置文件 ``next/_config.yml`` 的 Valine 设置部分添加一个自定义属性（命名可自定义）：\n\n```yml\n# Valine\n# You can get your appid and appkey from https://leancloud.cn\n# More info available at https://valine.js.org\nvaline:\n  enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version.\n  appid: 5s8VV1vNdnt4bKoTcocYcY0U-gzGzoHsz\n  appkey: YRRibTsHhmelPnfq41YO6B1r\n  notify: false # mail notifier, See: https://github.com/xCss/Valine/wiki\n  verify: false # Verification code\n  placeholder: Nice ! # comment box placeholder\n  # avatar: mm # gravatar style\n  avatar: retro\n  guest_header: nick,mail # 用户可以自定义输入的信息\n  guest_info: nick,mail,link # custom comment header\n  pageSize: 5 # pagination size\n  language: # language, available values: en, zh-cn\n  visitor: true # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html\n  comment_count: false # if false, comment count will only be displayed in post page, not in home page\n```\n\n重点：\n\n```yml\nguest_header: nick,mail # 用户可以自定义输入的信息\n```\n\n然后在 Next 的 Valine 部署源码 ``next/layout/_third-party/comments/valine.swig`` 中修改这一部分：\n\n```javascript\nvar GUEST = ['nick', 'mail', 'link'];\nvar guest = '{{ theme.valine.guest_info }}';\nguest = guest.split(',').filter(function(item) {\n  return GUEST.indexOf(item) > -1;\n});\n\n// ↓↓↓↓↓ 重点是以下这部分 ↓↓↓↓↓\nvar guest_header = '{{ theme.valine.guest_header }}';\nguest_header = guest_header.split(',').filter(function(item) {\n  return GUEST.indexOf(item) > -1;\n});\n// ↑↑↑↑↑ 重点是以上这部分 ↑↑↑↑↑\n\nnew Valine({\n  el: '#comments',\n  verify: {{ theme.valine.verify }},\n  notify: {{ theme.valine.notify }},\n  appId: '{{ theme.valine.appid }}',\n  appKey: '{{ theme.valine.appkey }}',\n  placeholder: '{{ theme.valine.placeholder }}',\n  avatar: '{{ theme.valine.avatar }}',\n\n  // ↓↓↓↓↓ 重点是以下这部分 ↓↓↓↓↓\n  guest_info: guest_header,\n  // ↑↑↑↑↑ 重点是以上这部分 ↑↑↑↑↑\n\n  meta: guest,\n  pageSize: '{{ theme.valine.pageSize }}' || 10,\n  visitor: {{ theme.valine.visitor }},\n  lang: '{{ theme.valine.language }}' || 'zh-cn'\n});\n```\n\n主要就是获取主题配置文件中设置的 ``guest_header`` 然后组合成数组再传给 ``guest_info`` 即可。重新部署，效果如下：\n\n<center>\n\n![Valine 自定义用户可输入信息](/post_files/blogdiy/blogdiy-4-chat-comment/valine_guest_info_custom.png \"TOPICS\")\n\n</center>\n\n<br/>\n\n## 3.2 隐藏Valine系统信息\n\n常规配置好 Valine 后，会发现评论时自动读取了用户的系统信息等，不仅不美观而且暴露隐私，非常不友好：\n\n<center>\n\n![Valine 显示系统信息](/post_files/blogdiy/blogdiy-4-chat-comment/valine_show_system_info.png \"TOPICS\")\n\n</center>\n\n想要隐藏系统信息可修改 ``next/source/css/_custom/custom.styl``，在末尾添加如下代码：\n\n```javascript\n// Valine 隐藏系统信息\n.vsys{\n  display:none !important;\n}\n```\n\n注：``custom.styl`` 这个文件会在 ``next/source/css/main.styl`` 中被引入：\n\n```javascript\n// Custom Layer\n// --------------------------------------------------\n@import \"_custom/\" + $custom_styles;\n```\n\n隐藏后的效果：\n\n<center>\n\n![Valine 隐藏系统信息](/post_files/blogdiy/blogdiy-4-chat-comment/valine_hide_system_info.png \"TOPICS\")\n\n</center>\n\n<br/>\n\n## 3.3 文首增加留言区跳转\n\n附加一个小记录，当文章未开启评论功能时，在文首显示一条跳转留言区的功能。我个人是放在了显示 Description 的下方，直接放进一个链接即可：\n\n```javascript\n{% if not post.comments and not is_index %}\n  <p>\n    <style type=\"text/css\">\n      .toContact {\n          color: #EB6D39;\n          font-size: 10px;\n          border-bottom-color: #EB6D39;\n      }\n      .toContact:hover {\n        color: #FFFFFF;\n        border-bottom-color: #FFFFFF;\n      }\n    </style>\n    <a href=\"/about/\" class=\"toContact\">本文未开启评论，点击前往留言区</a>\n  </p>\n{% endif %}\n```\n\n***\n\n# 4. 二级标题替换为留言链接\n\nNext 主题的博客二级标题其实就是正标题下面的这一小段文字：\n\n<center>\n\n![Next 主题二级标题](/post_files/blogdiy/blogdiy-4-chat-comment/blog_subtitle.png \"TOPICS\")\n\n</center>\n\n但是像我的博客其实并没有二级标题的必要，所以如图所示设置的和博客描述是一样的。但是这个标题区作为一个信息展示栏可以起到置顶的作用，根绝我的个人需求，将二级标题改成了“留言区”的引导链接。\n\n首先需要注意的地方是，通常为了使得博客能被搜索到，都会在主题配置文件 ``next/_config.yml`` 中开启 SEO：\n\n```yml\n# Change headers hierarchy on site-subtitle (will be main site description) and on all post / page titles for better SEO-optimization.\nseo: true\n```\n\n因此这个二级标题还是不要直接删掉的好，可以通过让它在网页上不显示，而在页面元素中依然存在的方式巧妙地隐藏掉。在 ``/next/layout/_partials/header/brand.swig`` 中找到二级标题相关部分的源码：\n\n```javascript\n{% if subtitle %}\n  {% if theme.seo %}\n    <h1 class=\"site-subtitle\" itemprop=\"description\">{{ subtitle }}</h1>\n  {% else %}\n    <p class=\"site-subtitle\">{{ subtitle }}</p>\n  {% endif %}\n{% endif %}\n```\n\n把其中的 ``<h1>`` 标签和 ``<p>`` 标签使用的样式 ``site-subtitle`` 替换掉，改为：\n\n```javascript\n{% if subtitle %}\n  {% if theme.seo %}\n    <h1 style=\"opacity: 0; font-size: 0px; margin: 0px;\" itemprop=\"description\">{{ subtitle }}</h1>\n  {% else %}\n    <p style=\"opacity: 0; font-size: 0px; margin: 0px;\">{{ subtitle }}</p>\n  {% endif %}\n{% endif %}\n```\n\n也就是改成透明，且去掉四周边距，这样在网页上就不会显示了，但实际上在页面元素中还是存在的，这样就不会影响 SEO 了：\n\n<center>\n\n![隐藏二级标题](/post_files/blogdiy/blogdiy-4-chat-comment/hide_subtitle.png \"TOPICS\")\n\n</center>\n\n然后仿照二级标题的方式，首先在博客站点配置文件 ``blog/_config.yml`` 中增加两个字段：\n\n```yml\n# Custom Subtitle\ntitleContact: \"&ensp;留 言&ensp;\"\ntitleContact_url: /about/\n```\n\n这里具体显示名称和链接地址以自定义的为准。然后再在 ``next/source/css/_common/components/header/site-meta.styl`` 中增加一个 CSS 样式：\n\n```javascript\n.site-titleContact {\n  font-size: $subtitle-font-size;\n  color: #EB6D39;\n  border-bottom-color: #EB6D39;\n  &:hover {\n    color: $subtitle-color;\n    border-bottom-color: $subtitle-color;\n  }\n}\n```\n\n当然，这里的样式也可以随意根据自己的喜好调整。其中 ``subtitle-font-size`` 和 ``subtitle-color`` 都是原本二级标题已经定义好的变量，可以直接用。\n\n最后在 ``/next/layout/_partials/header/brand.swig`` 中增加一条链接，使用上面定义的样式和数据：\n\n```javascript\n<div class=\"custom-logo-site-title\">\n......\n</div>\n\n<a href=\"{{ config.titleContact_url }}\" class=\"site-titleContact\">{{ config.contact }}</a>\n\n{% if subtitle %}\n......\n{% endif %}\n```\n\n放的位置以自定义为准。重新部署即可看到效果：\n\n<center>\n\n![自定义二级标题](/post_files/blogdiy/blogdiy-4-chat-comment/custom_subtitle.png \"TOPICS\")\n\n</center>\n\n到这一步其实基本效果已经实现了，但是还有个问题：页面上的其他元素都有个加载进来的动画效果，而这个自定义的 ``site-titleContact`` 会导致刚打开页面就显示“留 言”，而其他元素过一会才显示，显得不和谐，因此需要为这个自定义的 CSS 样式添加一个动画效果。首先在 ``next/source/css/_common/components/header/site-meta.styl`` 中找到最下面 ``use-motion`` 部分，给 ``site-titleContact`` 增加动画初始状态，默认的动画是顶部间距从 -10 渐进到 0，如果想用默认动画，则只需要把 ``site-titleContact`` 加到列表中：\n\n```javascript\n.use-motion {\n  .brand { opacity: 0; }\n\n  .logo, .site-title, .site-subtitle, .custom-logo-image, .site-titleContact {\n    opacity: 0;\n    position: relative;\n    top: -10px;\n  }\n}\n```\n\n由于我这个链接是从 -5 渐进到 5，因此需要单独设置：\n\n```javascript\n.use-motion {\n  .brand { opacity: 0; }\n\n  .logo, .site-title, .site-subtitle, .custom-logo-image {\n    opacity: 0;\n    position: relative;\n    top: -10px;\n  }\n\n  .site-titleContact {\n    opacity: 0;\n    position: relative;\n    top: -5px;\n  }\n}\n```\n\n然后找到动画脚本文件 ``next/source/js/motion.js``，现在本地变量定义区定义好这个 CSS 样式：\n\n```javascript\nNexT.motion.middleWares = {\n  logo: function(integrator) {\n    var sequence = [];\n    var $brand = $('.brand');\n    var $image = $('.custom-logo-image');\n    var $title = $('.site-title');\n    var $subtitle = $('.site-subtitle');\n    var $logoLineTop = $('.logo-line-before i');\n    var $logoLineBottom = $('.logo-line-after i');\n    // 定义本地变量\n    var $titleContact = $('.site-titleContact')\n    ......\n  }\n  ......\n}\n```\n\n然后实现动画效果（为了表示层级关系，保留几个方法，但省略了内部源码）：\n\n```javascript\nNexT.motion.middleWares = {\n  logo: function(integrator) {\n    ......\n    // ============== 定义本地变量 ==============\n    var $titleContact = $('.site-titleContact')\n    // ========================================\n\n    $brand.length > 0 && sequence.push({\n      ......\n    });\n    function hasElement($elements) {\n      ......\n    }\n    function getMistLineSettings(element, translateX) {\n      ......\n    }\n    function pushImageToSequence() {\n      ......\n    }\n    NexT.utils.isMist() && hasElement([$logoLineTop, $logoLineBottom])\n    && sequence.push(\n      ......\n    );\n    NexT.utils.isMuse() && hasElement($image) && pushImageToSequence();\n    hasElement($title) && sequence.push({\n      ......\n    });\n    hasElement($subtitle) && sequence.push({\n      ......\n    });\n\n    // ============ 透明度从 0 渐进到 1 ============\n    // ============ 顶间距从 -5 渐进到 5 ===========\n    // ============ 动画时间为 100 毫秒 ============\n    hasElement($titleContact) && sequence.push({\n      e: $titleContact,\n      p: {opacity: 1, top: 5},\n      // o: {duration: 200}\n      o: {duration: 100}\n    });\n    // ===========================================\n\n    ......\n  },\n\n  ......\n};\n```\n\n再次部署，动画效果已经加上了，一切和谐。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（3）字数、访客、阅读统计","url":"/post/blogdiy/blogdiy-3-counter/","content":"<!-- more -->\n\n***\n\n# 1. 字数与阅读时间统计\n\n字数统计的效果可以参见我的文章标题下方的本文统计以及整个博客最底部的全站统计。\n\n安装插件：\n\n```shell\nnpm install hexo-symbols-count-time --save\n```\n\n在主题配置文件中找到并修改以下配置：\n\n```yml\n# Post wordcount display settings\n# Dependencies: https://github.com/theme-next/hexo-symbols-count-time\n# AWL — Average Word Length (chars count in word). Default: 4, CN≈2, EN≈5, RU≈6\n# WPM — Words Per Minute. Default: 275, Slow≈200, Normal≈275, Fast≈350\nsymbols_count_time:\n  separated_meta: true\n  item_text_post: true\n  item_text_total: false\n  awl: 4\n  wpm: 275\n```\n\n其中\n  - ``separated_meta`` 表示在“总字数”和“阅读时间”中间加一条分割线\n  - ``item_text_post`` 为每篇文章内是否显示当前文章的字数和阅读时间统计\n  - ``item_text_total`` 为是否在博客最底下显示整个站点所有文章的字数总和及阅读时间总和\n  - ``awl`` 为每个单词的平均长度，根据提示，中文为 2，英文为 5，默认是 4，同样的文章，这个值设置的越大，估计的阅读时间越短。\n  - ``wpm`` 为每分钟阅读的单词数，默认为275，更慢则设置为200，更快则设置为350，由于我的文章多与代码有关，因此阅读时间应当属于偏慢的，所以我的设置是 225\n\n***\n\n# 2. 访客与阅读量统计\n\n阅读量有两种统计方案，一个是[不蒜子](http://busuanzi.ibruce.info \"TOLINKS\")，一个是 [LeanCloud](https://leancloud.cn \"TOLINKS\")，不蒜子可以同时提供每篇文章的访客计数以及整个站点的访客计数，而 LeanCloud 仅支持单个文章的访客计数，因此如果需要全站统计的话，则至少需要使用一个不蒜子。不过，不蒜子目前还没有开放后台，有时不太方便更复杂的数据统计等功能，因此我的选择是每篇文章使用 LeanCloud 统计，全站使用不蒜子统计。\n\n不蒜子的引入非常简单，直接在主题配置文件内搜索 ``busuanzi``，并修改以下部分即可：\n\n```yml\n# Show Views / Visitors of the website / page with busuanzi.\n# Get more information on http://ibruce.info/2015/04/04/busuanzi\nbusuanzi_count:\n  enable: true\n  # 开启访客总量统计\n  total_visitors: true\n  total_visitors_icon: user\n  # 开启查看文章总数统计\n  total_views: true\n  total_views_icon: eye\n  # 文章阅读量单独使用 LeanCloud\n  post_views: false\n  post_views_icon: eye\n```\n\n设置 ``enable: true`` 打开功能，icon 指的是计数左边的图标，使用 FontAwesome 图标代码。``visitors`` 和 ``views`` 分别代表了访客数和阅读数，比如一个人一次查看了三篇文章，则访客数 +1，而阅读数 +3.\n\n引入 LeanCloud 则需要先注册，然后在控制台点击创建一个新应用，名字可以随便输入，对于单日流量并不太高的个人博客页而言，不需要使用商用版，开发版的每日 30,000 次请求已经足足够够了。\n\n新建完应用后点击进入，然后在左侧选择 __存储__，然后点击“创建 Class”，新建一个新的表 ``Counter``，注意，由于 Next 主题的规定，表名必须是这个，下方的权限选择 __无限制__，安全性可以在成功建立后台后再修改。\n\n创建完毕后，再点击左侧栏最下方的 __设置__，然后在子目录中选择 __安全中心__，由于只用到了计数功能，因此只需要打开“存储”开关即可，并在下方“Web 安全域名”处输入自己的博客地址，如果博客有绑定自定义域名，则应该同时输入自定义域名，如图：\n\n<center>\n\n![LeanCloud 安全设置](/post_files/blogdiy/blogdiy-3-counter/leancloud_security_setting.png \"TOPICS\")\n\n</center>\n\n设置完毕后，再在左侧子栏找到 __应用 Key__，复制其中的 App ID 和 APP Key，并分别粘贴到主题配置文件中以下部分即可：\n\n```yml\n# Show number of visitors to each article.\n# You can visit https://leancloud.cn to get AppID and AppKey.\nleancloud_visitors:\n  enable: true\n  app_id:\n  app_key:\n```\n\n如果需要更高的安全性，需要安装组件：\n\n```shell\nnpm install hexo-leancloud-counter-security --save\n```\n\n安全组件的详情请查阅 LeanCloud 官方文档。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（2）内置的小功能扩展","url":"/post/blogdiy/blogdiy-2-extension/","content":"<!-- more -->\n\n***\n\n# 1. 文章版权\n\n作为一个码畜，版权意识还是要有的（虽然没什么用），文章的版权该加还是加上，在主题配置文件中找到：\n\n```yml\n# Creative Commons 4.0 International License.\n# See: https://creativecommons.org/share-your-work/licensing-types-examples\n# Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero\n# You can set a language value if you prefer a translated version of CC license.\n# CC licenses are available in 39 languages, where you can find the specific and correct abbreviation you need.\n# Valid values of language: deed.zh, deed.fr, deed.de, etc.\ncreative_commons:\n  license: by-nc-sa\n  sidebar: false\n  post: true\n  language: deed.zh\n```\n\n其中，如果开启 ``sidebar``，则文章的侧栏目录处会显示版权信息，如果开启 ``post``，则文章底部会显示版权信息。\n\n***\n\n# 2. 标签词云\n\n具体标签词云的效果可以参考：[我的标签页面](/tags/ \"TOLINKS\")，简单来说就是：所有文章中，出现次数不同的标签会具有不同大小、颜色，这样就能更好地区分哪些内容会是博客的主要部分。自定义效果在主题配置文件内：\n\n```yml\n# TagCloud settings for tags page.\ntagcloud:\n  # If true, font size, font color and amount of tags can be customized\n  enable: true\n  # All values below are same as default, change them by yourself\n  min: 13 # min font size in px\n  max: 30 # max font size in px\n  start: \"#008577\" # start color (hex, rgba, hsla or color keywords)\n  end: \"#EB6D39\" # end color (hex, rgba, hsla or color keywords)\n  amount: 200 # amount of tags, change it if you have more than 200 tags\n```\n\n其中 ``min`` 和 ``max`` 分别代表最冷门和最热门标签的大小，``start`` 和 ``end`` 分别代表最冷门和最热门标签的颜色，出现次数位于中间的标签会根据这个大小、颜色范围自动生成不同的大小和颜色。\n\n***\n\n# 3. 文件下载\n\n很多时候我们想要给读者提供一个小的例程或者说明文档时，会把文件传到网盘上然后分享出来，不过这么做不仅麻烦，而且随时面临文件失效、被移动、修改后要重新上传等问题，所以如果能直接在博客内提供下载会更好。实际上这种静态博客的所有文件都是能下载的，因为其都对应了一个具体的地址，只不过一般我们在文章内放入的，点击链接会跳转到浏览器打开后的界面，我们希望这个链接可以是下载链接的形式，就能用以下方法实现：\n\n  1. 在站点配置文件内找到：\n\n  ```yml\n  post_asset_folder: false\n  ```\n\n  2. 将其改为 ``true`` 即可，然后在 ``blog/source/`` 下建立一个文件夹（也可以放在已有文件夹内），比如我新建一个 __post_files__ 文件夹存放，然后文件放在：\n\n  ```\n  blog/source/post_files/blogdiy/blogdiy-2-extension/TestWord.docx\n  ```\n\n  3. 在文章内需要提供下载的地方这么写即可：\n\n  ```\n  [测试下载 Word](/post_files/blogdiy/blogdiy-2-extension/TestWord.docx)\n  ```\n\n  4. 测试一下：[点击下载 Word](/post_files/blogdiy/blogdiy-2-extension/TestWord.docx)、[点击下载 Excel](/post_files/blogdiy/blogdiy-2-extension/TestExcel.xlsx)\n\n不过，目前已知 TXT 文本、图片、RTF 富文本、MarkDown 文本等无法提供下载，点击后会直接跳转到浏览器打开文件的界面，建议多个小文件做成压缩包的形式再提供下载，大文件去掉扩展名或先改变扩展名，下载后再改回来。不过，如果去掉文件扩展名，下载下来之后会自动增加一个“dms”扩展名，需要手动改为正确扩展名才可用。\n\n***\n\n# 4. 更改文章URL路径\n\n默认情况下，当我们发布了一篇文章后，会发现文章的 URL 路径通常都是类似于：\n\n<center>\n\n![默认 URL 格式](/post_files/blogdiy/blogdiy-2-extension/url_format_default.png \"TOPICS\")\n\n</center>\n\n这种路径格式其实非常不适合作为长期维护的博客页使用，第一，有时分享的时候能记得住标题，但记不住时间，为了分享还要专门再看一次文章地址。第二，如果接入后台、接入分析统计接口等等，一堆文章前面都是日期打头的链接，不仅不方便分类管理，自己也看的头疼。为此，Hexo 其实提供了可以修改默认格式的设置，在站点配置文件里面：\n\n```yml\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: slliu96.github.io\nroot: /\npermalink: :year/:month/:day/:title/\npermalink_defaults:\n```\n\n把 ``permalink`` 修改为：``permalink: :postfrom/:title/``，然后在文章内顶部的信息区添加一个 ``postfrom`` 属性：\n\n```yml\n---\ntitle: 基于Hexo的博客DIY（2）—— 附加功能扩展\nauthor: SLLiu\ndate: 2019-01-09 11:26:17\npostfrom: aaa\ncategories:\ntags:\n---\n```\n\n``postfrom`` 和上面写的取值 ``aaa`` 只是示例，都可以自定义，只要站点配置文件内写的属性名和文章内写的属性名一致即可，这样就可以在写每篇文章的时候自定义一个 URL 格式了：\n\n<center>\n\n![自定义 URL 格式](/post_files/blogdiy/blogdiy-2-extension/url_format_custom.png \"TOPICS\")\n\n</center>\n\n当然，也可以直接把格式用固定字符串代替，这样就不用每篇文章都手动加格式了：\n\n```\npermalink: postfrom/:title/\n```\n\n这样，每篇文章的 URL 都会是这种格式：``xxx.github.io/postfrom/XXXXXXXX``。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Hexo博客DIY（1）建立基于Hexo的静态博客","url":"/post/blogdiy/blogdiy-1-create/","content":"<!-- more -->\n\n前言：作为一个码畜，各类博客应该是离不了手的，看着别人的博客花花绿绿，我想很多人都会想过自己写写博客。但是现在写博客面临着一些问题，第一个是免费博客网页越来越少了，新浪网易都已关停，另一个是支持好的博客系统，其自定义性又远不及自建博客，比如 CSDN。为此，作为 ___全球最大的同性交友平台—— GitHub___，其提供托管的静态页面 GitHub Page 就是一个非常好的选择，配合 Hexo 即可实现丰富的博客自定义功能。本文记录如何从零开始建立个人博客页，更多 DIY 选项欢迎参考：[博客 DIY 系列](/categories/BlogDIY/)。\n\n***\n\n# 1. 建立静态博客仓库\n\n我的博客选择的是 GitHub 托管、Hexo 生成静态页的形式，因此本文将基于这种模式介绍。\n\n首先，在 GitHub 上建立一个个人博客页，非常简单，直接新建一个仓库，名称为 ``xxx.github.io``，其中 ``xxx`` 为自己的 GitHub 用户名，要注意是用户名而不是名字，用户名是可以用来登录的那个。创建好了之后就已经可以通过 xxx.github.io 来访问了，初始页面大概长这个样子：\n\n<center>\n\n![初始 GitHub Page](/post_files/blogdiy/blogdiy-1-create/default_github_page.png \"TOPICS\")\n\n</center>\n\n需要注意的是，这个仓库和将来存放、自定义博客功能的文件夹不是同一个目录，这个仓库仅用来部署博客的最终效果。比如，在本地我的博客及相关功能管理目录在 A 文件夹，每次修改完之后，通过 Hexo 部署到 GitHub，会从 A 文件夹内自动获取相关设置再部署到 xxx.github.io 仓库内，但是 A 文件夹和这个仓库的文件并不是 Git 同步关系，仓库内的文件仅仅包含了最终网页显示需要的部分文件，而 A 文件夹则包括了所有建立和维护博客相关的文件。如果想要对 A 文件夹做 Git 备份，可以再新建一个仓库专门用来同步这个文件夹。\n\n***\n\n# 2. 连接SSH\n\nGitHub 中提供了一些便捷更换的主题，可以根据自己的喜好切换。Jekyll 主题部署快速，点几下鼠标即可，但由于 Hexo 主题具有更加自由的编辑性，因此还是选择后者。为了能在本地使用更方便的工具编写博客、定制外观，需要将这个仓库 Clone 到本地，而且使用 Hexo 驱动时，还需要和 GitHub 建立远程安全连接。建立连接的过程大致如下：\n\n  1. 在 Github 设置中点击新建SSH公钥\n  2. 查看本地是否存在目录 ``~/.ssh``\n  3. 若存在，建议删除后重新建立\n  4. 执行命令：\n\n  ```shell\n  # xxx@yyy.com 输入自己的 GitHub 账号邮箱\n  ssh-keygen -t rsa -C \"xxx@yyy.com\"\n  ```\n\n  回车执行后根据提示输入自己的账号密码，若提示 id 文件已保存，则创建成功\n\n  5. 目录下将生成两个文件：``id_rsa.pub`` 和 ``id_rsa``\n  6. 打开 id_rsa.pub，复制其内容并粘贴到 GitHub 新建公钥的 Key 栏并保存，Title 可随意输入\n\n  <center>\n\n  ![粘贴 SSH 密钥](/post_files/blogdiy/blogdiy-1-create/github_add_ssh_key.png \"TOPICS\")\n\n  </center>\n\n  7. 本地终端验证密钥，执行命令：\n\n  ```shell\n  shh -T git@github.com\n  ```\n\n  若显示 ``Hi XXX! You've successfully authenticated...`` 则连接成功\n\n\n***\n\n# 3. 安装必要环境\n\n由于需要在本地对博客进行管理，因此本地环境的重要性不言而喻。通常，基于 Hexo 驱动的静态博客，只需要这三个环境就够了：``Git``、``Hexo``、``Node.JS``，其中 Node.JS 主要是使用其内含的包管理器 ``npm``，通过这个管理器可以为博客部署很多有意思的插件。另外有个小提示，如果在国内使用感觉网速太慢的话，可以用 ``cnpm`` 命令替换。\n\n  1. Git 下载地址：[Git 下载](https://git-scm.com/downloads \"TOLINKS\")\n  2. Node.JS下载地址：[Node.JS 下载](https://nodejs.org/en/download/ \"TOLINKS\")\n  3. 终端安装 Hexo 命令（在安装完 Node.JS 之后）：\n\n  ```shell\n  npm install -g hexo-cli\n  ```\n\n  如果安装结果出现红字报错无权限的情况，可以尝试以下两个命令其中一个：\n\n  ```shell\n  # 尝试1：\n  sudo npm install -g hexo-cli\n\n  # 尝试2：\n  sudo npm install --unsafe-perm --verbose -g hexo\n  ```\n\n  4. 检查环境安装情况：\n\n  ```shell\n  # Git 环境检查：\n  git --version\n\n  # Node.JS 环境检查：\n  node -v\n\n  # Hexo 环境检查：\n  hexo --Version\n  ```\n\n  如果均能输出对应版本号即表示环境配置成功。\n\n***\n\n# 4. 初始化本地静态博客页\n\nHexo 环境安装完以后，就可以在本地建立管理目录了。在终端进入想要作为博客维护目录的路径，并执行以下命令初始化：\n\n```shell\nhexo init\n```\n\n执行完之后，目录下应该会出现大致如下的文件及文件夹：\n\n<center>\n\n![Hexo 目录](/post_files/blogdiy/blogdiy-1-create/hexo_folder.png \"TOPICS\")\n\n</center>\n\n简单介绍一下：\n\n  - __node_modules__ 是模块目录，包含了博客基础和自定义功能所需的组件\n  - __public__ 就是生成最终部署到网页上去所需文件的目录\n  - __scaffolds__ 是博客一些页面的模板，修改这里面的文件可以自定义新增对应类别的文件时默认的格式\n  - __source__ 就是博客内所有页面包括的文件了，包括文章、分类、标签等等\n  - __themes__ 就是博客的主题，目录内可以包括各种不同的主题，并且可以在博客设置文件内随时更换\n\n这些不同的目录及包括的文件、对应 DIY 会在下文更详细地介绍。\n\nHexo 目录初始化完毕后，通过命令：\n\n```shell\nnpm install\n```\n\n可以一键式安装所有必须的组件，为了能通过 Hexo 部署到 GitHub 上去，还要再额外安装 Git Deploy 组件：\n\n```shell\nnpm install hexo-deployer-git --save\n```\n\n***\n\n# 5. 常用Hexo命令\n\n常用的 Hexo 命令大致有如下数条：\n\n  - ``hexo init [folder]``：初始化本地项目，可指定路径 folder，或默认为当前目录\n  - ``hexo generate``：（可简写为 ``hexo g``）生成本地静态文件\n  - ``hexo server``：（可简写为 ``hexo s``）启动本地服务器，启动后可在 localhost:4000 查看页面效果\n  - ``hexo deploy``：（可简写为 ``hexo d``）部署到 Github（或其他代码托管网站），由根目录下的 __\\_config.yml__ 文件设定\n  - ``hexo clean``：清理缓存文件\n  - ``hexo new [layout] <title>``：新建文件（夹），可指定文件类型 layout，或默认由 __\\_config.yml__ 中的 default_layout 决定。必填项 title 用于指定文章标题，若参数值中含有空格，需使用英文双引号包括\n  - ``hexo --safe``：安全模式，禁用加载插件和脚本，可在安装新插件遇到问题时启用\n  - ``hexo --debug``：调试模式，用于将消息详细记录到终端和 debug.log 文件\n  - ``hexo --silent``：静默模式，用于静默输出到终端\n\n其中最最最常用的三个命令为：``hexo clean``、``hexo g``、``hexo s``，每一次对博客进行修改后，都需要用这三个命令（每条命令分别执行）清理之前的博客缓存、重新构建新博客页面、开启本地服务器并在本地预览效果，如果效果符合预期，就可以把 ``hexo s`` 替换为 ``hexo d``，再重新执行这三个命令（也就是：``hexo clean``、``hexo g``、``hexo d``）。当需要连续执行 ``hexo g`` 和 ``hexo d`` 时，可以用 ``hexo g -d`` 这一条命令代替前两条（也就是：``hexo clean``、``hexo g -d``）。\n\n***\n\n# 6. 部署博客基本功能\n\n到上一步为止，博客是已经建立完基础功能了，但此时本地博客和 GitHub 上的静态托管还没有建立联系，想要在本地维护的博客能同步到 GitHub 仓库上，使得外网能通过 xxx.github.io 网页形式访问，还需要配置一下本地的配置文件 __\\_config.yml__，改文件位于本地博客文件夹的根目录下面，使用任何一个文本编辑器打开，找到以下片段：\n\n```yml\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository:\n  branch: master\n```\n\n在其中的 ``repository`` 后面填写自己的博客页托管仓库地址：``https://github.com/xxx/xxx.github.io``，将其中的 xxx 替换为自己的 GitHub 用户名。修改完保存，至此即可通过上文讲述的 Hexo 命令将本地博客部署到 GitHub 上了。\n\n另外还可以预先安装站点地图和百度站点地图生成插件：\n\n```shell\n$ npm install --save hexo-generator-sitemap\n\n$ npm install --save hexo-generator-baidu-sitemap\n```\n\n并在站点配置文件中进行如下配置：\n\n```yml\n# 自动生成sitemap\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n这样在部署后就会自动在博客根目录下生成对应的文件，可通过 ``博客地址/sitemap.xml`` 或 ``博客地址/baidusitemap.xml`` 访问。\n\n***\n\n# 7. 引入Next主题\n\n默认的博客页使用的主题叫做“landscape”，可以在博客目录下的 themes 文件夹内找到，Hexo 官方的主题列表：[Themes | Hexo](https://hexo.io/themes/ \"TOLINKS\")，具体哪个主题好看就仁者见仁了，我自己在经过一段时间的搜索后找到两个比较心仪的，一个是简约风的 [AirCloud](https://github.com/aircloud/hexo-theme-aircloud \"TOLINKS\")，一个是偏浪漫的 [Next](http://theme-next.iissnan.com \"TOLINKS\")，后来觉得 AirCloud 实在是过于简约了（逃），最终选择后者。此外，除了 Hexo 平台，Next 主题还支持 Farbox 和 Jekyll 平台。部署主题的方式很简单，都是下载主题文件（[Next 主题下载](https://github.com/theme-next/hexo-theme-next/releases \"TOLINKS\")），然后放进 themes 文件夹中，并在博客根目录下的配置文件 \\_config.yml 中选择上这个主题：\n\n```yml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: next\n```\n\n这里的 ``next`` 是主题文件夹的名字，主题文件夹的名字可以随便改（比如加上版本号，next711），只要这里同步更改即可。\n\n___注意：由于在主题内，有许多设置或文件与博客站点的设置或文件有重名、覆盖等，因此从下文开始，一些名词的定义如下：___\n\n  - <font color=#EB6D39>站点根目录</font>：表示最开始新建博客时选择的那个目录，整个博客文件夹的根目录，在路径中用 __blog/...__ 表示，比如博客文章的目录即为：blog/source/\\_post/\n  - <font color=#EB6D39>主题根目录</font>：表示下载的主题文件夹的目录，我的主题是 Next，其所属位置即 blog/themes/next/，在下文路径中将用 __next/...__ 表示，比如 Next 主题文件中的语言包目录即为：next/languages/\n  - <font color=#EB6D39>站点配置文件</font>：表示站点根目录下的 ``_config.yml`` 文件\n  - <font color=#EB6D39>主题配置文件</font>：表示主题根目录下的 ``_config.yml`` 文件\n  - <font color=#EB6D39>安装组件</font>：表示在站点根目录下通过终端命令安装指定组件/模块\n  - <font color=#EB6D39>Hexo 命令三连</font>：表示依次执行：``hexo clean``、``hexo g``、``hexo s``，这三步仅是开启本地测试，可以在 ``localhost:4000`` 处查看效果，如果认为效果合意，请根据实际情况自行决定是否执行 ``hexo d`` 部署到仓库中\n\n[Hexo 官方网站](http://theme-next.iissnan.com/theme-settings.html#tags-page \"TOLINKS\")已经提供了很多基础个性化配置，包括主题样式、分类及标签、设置字体、RSS、代码块样式、公益 404、友链、搜索、打赏、背景等等，内置配置已经足够个性化，如果不追求更多自定义选项，现在的博客页面已经比较美观，想要写博客，只需要在博客根目录下执行：\n\n```shell\nhexo new \"XXXXX\"\n```\n\n其中 ``XXXXX`` 是新建的博客标题，同时也是文章的文件名，建议这里使用英文，不然博客文章的链接 URL 会有中文显得略不美观，如果想要正文标题是中文，只需要在：``blog/source/_post/`` 下找到刚才新建的文件，打开并修改上方 ``title`` 后面的文字即可，不会影响 URL 链接。在下方输入博客内容，完成后保存 + Hexo 命令三连即可。文章使用 MarkDown 格式编写，如果还不是很熟悉，可以搜索参照各种 MarkDown 格式介绍的文章，本文就不多做讲解了。\n\n***\n\n# 8. 解决low severity vulnerability\n\n有时，在通过 ``npm install`` 或 ``npm install xxx`` 安装完包以后，终端会出现大致如下的信息：\n\n```shell\n$ npm install\n\naudited 6879 packages in 2.402s\nfound 1 low severity vulnerability\n  run `npm audit fix` to fix them, or `npm audit` for details\n\n$\n```\n\n提示“有一个低严重性的漏洞”，根据提示输入：\n\n```shell\n$ npm audit fix\n\nup to date in 1.185s\nfixed 0 of 1 vulnerability in 6879 scanned packages\n  1 vulnerability required manual review and could not be updated\n\n$\n```\n\n很明显并没有用，反馈大致意思是“有 1 个漏洞需要人工检查，且无法更新”，使用强制修复试试：\n\n```shell\n$ npm audit fix --force\n\nnpm WARN using --force I sure hope you know what you are doing.\nup to date in 1.242s\nfixed 0 of 1 vulnerability in 6879 scanned packages\n  1 vulnerability required manual review and could not be updated\n\n$\n```\n\n看来强制修复也不行，那就只好按它的建议手动查看了：\n\n```shell\n$ npm audit\n\n                       === npm audit security report ===\n                                                                                \n┌──────────────────────────────────────────────────────────────────────────────┐\n│                                Manual Review                                 │\n│            Some vulnerabilities require your attention to resolve            │\n│                                                                              │\n│         Visit https://go.npm.me/audit-guide for additional guidance          │\n└──────────────────────────────────────────────────────────────────────────────┘\n┌───────────────┬──────────────────────────────────────────────────────────────┐\n│ Low           │ Regular Expression Denial of Service                         │\n├───────────────┼──────────────────────────────────────────────────────────────┤\n│ Package       │ marked                                                       │\n├───────────────┼──────────────────────────────────────────────────────────────┤\n│ Patched in    │ >=0.7.0                                                      │\n├───────────────┼──────────────────────────────────────────────────────────────┤\n│ Dependency of │ hexo-renderer-marked                                         │\n├───────────────┼──────────────────────────────────────────────────────────────┤\n│ Path          │ hexo-renderer-marked > marked                                │\n├───────────────┼──────────────────────────────────────────────────────────────┤\n│ More info     │ https://npmjs.com/advisories/1076                            │\n└───────────────┴──────────────────────────────────────────────────────────────┘\nfound 1 low severity vulnerability in 6879 scanned packages\n  1 vulnerability requires manual review. See the full report for details.\n\n$\n```\n\n这些信息似乎是和版本号有关，顺手打开给出来的网址：[More info](https://npmjs.com/advisories/1076 \"TOLINKS\")，看到如下信息：\n\n<center>\n\n![More info 网页信息](/post_files/blogdiy/blogdiy-1-create/more_info.png \"TOPICS\")\n\n</center>\n\n果然，NPM 官方给出的解决方案也是升级 marked 版本到 0.7.0，先看看当前的版本信息：\n\n```shell\n$ npm ls marked\n\nhexo-site@0.0.0 ~/Hexo\n└─┬ hexo-renderer-marked@1.0.1\n  └── marked@0.6.3\n\n$\n```\n\n果不其然版本不是 0.7.0，先尝试更新后再次查看版本：\n\n```shell\n$ npm update\n\n$ npm ls marked\n\nhexo-site@0.0.0 ~/Hexo\n└─┬ hexo-renderer-marked@1.0.1\n  └── marked@0.6.3\n\n$\n```\n\n依然无法手动更新，那就手动把这个 ``Blog/node_modules/marked`` 目录删掉：\n\n```shell\n$ npm ls marked\n\nhexo-site@0.0.0 ~/Hexo\n└─┬ hexo-renderer-marked@1.0.1\n  └── UNMET DEPENDENCY marked@0.6.3 \n\nnpm ERR! missing: marked@0.6.3, required by hexo-renderer-marked@1.0.1\n```\n\n提示依赖包 marked 被删除了，然后再重新安装：\n\n```shell\n$ npm install\n\nadded 1 package from 1 contributor and audited 6879 packages in 2.442s\nfound 1 low severity vulnerability\n  run `npm audit fix` to fix them, or `npm audit` for details\n\n$ npm ls marked\n\nhexo-site@0.0.0 ~/Hexo\n└─┬ hexo-renderer-marked@1.0.1\n  └── marked@0.6.3\n```\n\n仍然是 0.6.3 版本！内心是崩溃的，干脆直接覆盖安装一次 marked，再查看版本信息。执行：\n\n```shell\n$ npm install --save marked\n\n$ npm ls marked\n\nhexo-site@0.0.0 ~/Hexo\n├─┬ hexo-renderer-marked@1.0.1\n│ └── marked@0.6.3\n└── marked@0.7.0\n```\n\n现在问题来了，从层级结构上来看，手动执行安装后 Hexo 装了两个 marked，手动安装的这个 marked 是最新的 0.7.0 版本，被放在了原来老版本的目录下：``Blog/node_modules/marked``，而原本隶属于 ``hexo-renderer-marked`` 下面的老版本依赖包，由于被 ``hexo-renderer-marked`` 依赖，且手动安装了另一版本，导致其位置被自动放到：``Blog/node_modules/hexo-renderer-marked/node_modules/marked`` 目录下。\n\n**<font color=EB6D39>也就是说，这个老版本的 marked，其版本并不是由 npm 管理的，所以 update 和 删掉重新 install 都无法更新，而手动安装的 marked 是直接由 npm 管理的，因此默认会安装最新版。这也说明被依赖的 marked 的版本号是在 hexo-renderer-marked 渲染引擎中控制的。</font>**\n\n为了防止冲突，先卸载手动安装的 marked：\n\n```shell\n$ npm uninstall --save marked\n```\n\n现在 ``Blog/node_modules/`` 下已经没有 ``marked`` 目录了，同时也手动删掉老版本的 marked 目录：``Blog/node_modules/hexo-renderer-marked/node_modules/marked``。\n\n然后 再到之前的网页：[点击这里](https://npmjs.com/advisories/1076 \"TOLINKS\") 内点击 ``Versions`` 栏查看最新的 marked 版本：\n\n<center>\n\n![marked 最新版本](/post_files/blogdiy/blogdiy-1-create/marked_newest_version.png \"TOPICS\")\n\n</center>\n\n接着找到 ``Blog/node_modules/hexo-renderer-marked/package.json``，修改其中的依赖部分：\n\n```json\n......\n\n\"dependencies\": {\n  \"hexo-util\": \"^0.6.2\",\n  \"marked\": \"^0.6.1\",\n  \"strip-indent\": \"^2.0.0\"\n},\n\n......\n```\n\n把 ``\"marked\"`` 字段后面的 ``\"^0.6.1\"`` 强制改为 ``\"^0.7.0\"``，，最后再次执行：\n\n```shell\n$ npm install\n\nadded 1 package from 1 contributor, removed 1 package and audited 6879 packages in 3.168s\nfound 0 vulnerabilities\n\n$\n```\n\n看到这个结果说明已经没有报“低严重性漏洞”了，再查看一下版本号：\n\n```shell\n$ npm ls marked\n\nhexo-site@0.0.0 /Users/slliu/Downloads/Temp\n└─┬ hexo-renderer-marked@1.0.1\n  └── marked@0.7.0\n\n$\n```\n\nOK！成功更新到 0.7.0 版本！**<font color=EB6D39>假如执行这两步的时候依然报之前的信息，如果可以确保之前的步骤都是对的，可以暂时不管，通常是缓存信息还没有更新的缘故，把这两步执行完之后，退出并重新打开终端再查看 ``npm ls marked`` 即可看到已经更新。假如出现错误信息显示被删除，再执行一次 ``npm install`` 即可。</font>**\n\n其实挺简单的一个问题，由于没有经验导致折腾了这么久，记录在此望读者少走弯路。另外，此时由于已经卸载了之前手动安装的 marked，因此这个依赖包的位置又回到了：``Blog/node_modules/marked`` 下。\n\n***\n\n# 9. 解决FontAwesome不显示\n\n某些情况下，在构建博客后，会出现图标不显示的问题，例如正常情况下我的博客应该是如下图所示：\n\n<center>\n\n![FontAwesome 正常显示](/post_files/blogdiy/blogdiy-1-create/fontawesome_normal.png \"TOPICS\")\n\n</center>\n\n但可能会出现如下图所示的情况：\n\n<center>\n\n![FontAwesome 显示异常](/post_files/blogdiy/blogdiy-1-create/fontawesome_error.png \"TOPICS\")\n\n</center>\n\n同时，在页面上检查元素会出现一个报错信息：\n\n<center>\n\n![FontAwesome 显示异常](/post_files/blogdiy/blogdiy-1-create/fontawesome_error_info.png \"TOPICS\")\n\n</center>\n\n原因是没找到目录下 FontAwesome 的 CSS 文件，但其实我们并不需要手动下载，Next 主题在生成部署时会动态到 FontAwesome 网站上下载相关样式，这时就考虑可能是 FontAwesome 的某个 CDN 连接挂了，可以在 Next 的主题配置文件 ``next/_config.yml`` 中切换一下：\n\n```yml\n# Internal version: 4.6.2\n# See: https://fontawesome.com\n# Example:\n# fontawesome: //cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css\n# fontawesome: //cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css\nfontawesome: https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css\n```\n\n重新部署，恢复正常。\n\n***\n\n更多进一步的个性化欢迎参考：[博客 DIY 系列](/categories/BlogDIY/ \"TOLINKS\")\n","tags":["Hexo","自定义"],"categories":["BlogDIY"]},{"title":"Welcome","url":"/post/resume/Welcome/","content":"<!-- more -->\n\nThere's an idea always in my mind: recording something useful, interesting, advanced about technology. Shamefully found an empty blog after so long since what I said above, I've even changed my career from Java/Android to AI/Recommender system. Somehow, I left a few blogs at other sites like CSDN or another personal blog, transferring them to here now.\n\n<font color=EB6D39 size=5>Anyway</font>, I'm still not an expert in any technology, but I do love what I'm doing (Android development), and what I'm planning to do (Recommender System, at least for now). So, my blog will contain at least 2 or more types of posts, <font color=orange>Python</font>, <font color=orange>Recommender System</font>, <font color=orange>Java</font>, <font color=orange>Android</font>, even <font color=orange>Kotlin</font> may be on list. That'll be wonderful if there's anything useful for anyone.\n\nThis's what I really love and should keep in mind :\n\n<center>\n\n<font size=6 color=red> __Learn, or Lose. Keep Working !__</font>\n\n</center>\n\n<br/><br/><br/>\n\n<center>\n\nHere's my favourite song, helps me through the dark and makes me strong.\n\n<br/><br/>\n\n<font size=6>All About Us</font>\n\n<font color=#999>\n\nTake my hand, I'll teach you to dance. I'll spin you around, won't let you fall down.\nWould you let me lead, you can step on my feet. Give it a try, it'll be alright.\nThe room's hush hush and now's our moment. Take it in feel it all and hold it.\nEyes on you, eyes on me, we're doing this right.\nCause lovers dance when they're feeling in love.\nSpotlight shinning' it's all about us, it's oh oh all about uh uh us.\nAnd every heart in the room will melt, this is a feeling I've never felt but it's all about us.\n\n<br/>\n\nSuddenly'I'm feeling brave, I don't know what's got into me, why I feel this way\nCan we dance real slow, can I hold you, can I hold you close\nThe room's hush hush and now's our moment. Take it in feel it all and hold it\nEyes on you, eyes on me, we're doing this right\nCause lovers dance when they're feeling in love\nSpotlight shinning, it's all about us, it's oh-oh-all about uh-uh-us\nAnd every heart in the room will melt, this is a feeling I've never felt but it's all about us\n\n<br/>\n\nDo you hear that love, they're playing our song\nDo you think we're ready, oh I'm really feeling it, do you hear that love, do you hear that love\nDo you hear that love, they're playing our song\nDo you think we're ready yet love I'm really feeling it, do you hear that love, do you hear that love\nDo you hear that love, they're playing our song\nDo you think we're ready yet love I'm really feeling it, do you hear that love, do you hear that love\n\n<br/>\n\nLovers dance when they're feeling in love\nSpotlight shinning, it's all about (It's all about) us, it's oh-oh-(Do you hear that love)-oh-oh\nEvery heart in the room will melt, this is a feeling I've never felt but it's all about us\nCause lovers dance when they're feeling in love\nSpotlight shinning' it's all about us, it's oh-oh-all about (Hey-ey hey) us\nAnd every heart in the room will melt, this is a feeling I've never felt but it's oh-oh\n\n</font>\n\n<font color=#EB6D39>\n\nIt's all about us.\n\n</font>\n\n</center>"},{"title":"Topic","url":"/post/resume/blog-topic/","content":"<center>\n\n[<font color=#EB6D39>Welcome !</font>](/post/resume/Welcome/ \"TOLINKS\")&emsp;&emsp;&emsp;&emsp;&emsp;[<font color=#EB6D39><i class=\"fa fa-star\" />&emsp;[Categories]&emsp;<i class=\"fa fa-star\" /></font>](/categories/ \"TOLINKS\")\n\n[<font color=EB6D39 size=5>欢迎点此参考超详细的 Hexo 博客 DIY 系列</font>](/categories/BlogDIY/ \"TOLINKS\")\n\n</center>"}]